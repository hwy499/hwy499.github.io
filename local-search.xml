<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【每日一题】leetcode-665-非递减数列</title>
    <link href="/2021/02/07/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <url>/2021/02/07/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-665-非递减数列"><a href="#leetcode-665-非递减数列" class="headerlink" title="leetcode-665-非递减数列"></a>leetcode-665-非递减数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个长度为 n 的整数数组，请你判断在最多改变1个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [4,2,3]<br>输出: true<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [4,2,1]<br>输出: false<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</p></blockquote><p>说明：</p><ul><li><p>1 &lt;= n &lt;= 10 ^ 4</p></li><li><p>10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</p></li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/non-decreasing-array">https://leetcode-cn.com/problems/non-decreasing-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h2><p>题目要求只能改变一个元素，让数组满足非递减序列。我就只需要遍历数组，当遍历到前一个元素大于后一个元素时，即arr[i]&gt;arr[i+1]时，我就将arr[i+1]的值赋给arr[i]，然后判断数组是否满足非递减序列，满足则返回true，不满足的话将arr[i]的值恢复原状，将arr[i]的值赋值给arr[1+1]，然后在判断此时的数组是否满足非递减序列，然后将此结果返回。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 如果只有一个数字就直接返回true</span>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 遍历整个数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> curr = nums[i];            <span class="hljs-keyword">int</span> next = nums[i + <span class="hljs-number">1</span>];            <span class="hljs-comment">// 如果前一个大于后一个，不满足非递减</span>            <span class="hljs-keyword">if</span> (curr &gt; next) &#123;                <span class="hljs-comment">// 将前一个的值改为后一个的值</span>                nums[i] = next;                <span class="hljs-comment">// 此时对数组进行判断</span>                <span class="hljs-keyword">if</span> (checkArray(nums)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-comment">// 还原前一个值</span>                nums[i] = curr;                <span class="hljs-comment">// 将后一个的值改为前一个</span>                nums[i + <span class="hljs-number">1</span>] = curr;                <span class="hljs-comment">// 然后对数组进行判断，并将判断结果作为程序的结果返回</span>                <span class="hljs-keyword">return</span> checkArray(nums);            &#125;        &#125;        <span class="hljs-comment">// 如果没有发生改变，说明本身就是非递减序列</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断一个数组是不是非递减数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【nginx学习】第二章-正向代理与反向代理</title>
    <link href="/2021/02/06/%E3%80%90nginx%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/2021/02/06/%E3%80%90nginx%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="【nginx学习】第二章-正向代理与反向代理"><a href="#【nginx学习】第二章-正向代理与反向代理" class="headerlink" title="【nginx学习】第二章-正向代理与反向代理"></a>【nginx学习】第二章-正向代理与反向代理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nginx 服务器的反向代理服务是其最常用的重要功能，由反向代理服务也可以衍生出很多与此相关的 nginx 服务器重要功能，比如后面会介绍的负载均衡。当然在了解反向代理之前，我们需要先知道什么是正向代理。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="什么是正向代理？"><a href="#什么是正向代理？" class="headerlink" title="什么是正向代理？"></a>什么是正向代理？</h3><blockquote><p> 正向代理（forward proxy）：是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。 —-百度百科</p></blockquote><img src="https://i.loli.net/2021/02/06/82txGbOkVyWra1f.png" alt="正向代理" style="zoom: 67%;"><p>从上图可以看出，正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理。</p><h3 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h3><h4 id="突破访问限制"><a href="#突破访问限制" class="headerlink" title="突破访问限制"></a>突破访问限制</h4><p>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</p><h4 id="提高访问速度"><a href="#提高访问速度" class="headerlink" title="提高访问速度"></a>提高访问速度</h4><p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p><h4 id="隐藏客户端真实IP"><a href="#隐藏客户端真实IP" class="headerlink" title="隐藏客户端真实IP"></a>隐藏客户端真实IP</h4><p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。PS:目标服务器只记录代理服务器的IP，记录不到上网者的IP。但是正向代理服务器有可能记录你的IP</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h3><blockquote><p> 反向代理（reverse proxy）：反向代理的方向与正向代理相反，指代表外部网络用户向内部服务器发出请求，即接收来自Internet上用户的连接请求，并将这些请求转发给内部网络上的服务器，然后将从内部服务器上得到的响应返回给Internet上请求连接的客户。</p></blockquote><img src="https://i.loli.net/2021/02/06/LqV71YP8b5ENDnr.png" alt="反向代理" style="zoom:67%;"><p>从上图可以看出反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。</p><h3 id="反向代理的用途？"><a href="#反向代理的用途？" class="headerlink" title="反向代理的用途？"></a>反向代理的用途？</h3><h4 id="隐藏服务器真实IP"><a href="#隐藏服务器真实IP" class="headerlink" title="隐藏服务器真实IP"></a>隐藏服务器真实IP</h4><p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p><h4 id="提高访问速度-1"><a href="#提高访问速度-1" class="headerlink" title="提高访问速度"></a>提高访问速度</h4><p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p><h4 id="提供安全保障"><a href="#提供安全保障" class="headerlink" title="提供安全保障"></a>提供安全保障</h4><p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p><h3 id="反向代理为什么叫做反向代理？"><a href="#反向代理为什么叫做反向代理？" class="headerlink" title="反向代理为什么叫做反向代理？"></a>反向代理为什么叫做反向代理？</h3><p>正向反向都是针对用户而言，正向代理就是代理服务器代理用户自己，反向代理就是代理服务器代理的不是用户，反而是目标服务器，所以叫反向代理，即正向代理客户端，反向代理服务端。</p><h2 id="正向代理与反向代理的区别？"><a href="#正向代理与反向代理的区别？" class="headerlink" title="正向代理与反向代理的区别？"></a>正向代理与反向代理的区别？</h2><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><ol><li><strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</li><li><strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</li><li><strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</li><li>正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>反向代理</tag>
      
      <tag>正向代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一题】leetcode-1423-可获得的最大点数</title>
    <link href="/2021/02/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <url>/2021/02/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-1423-可获得的最大点数"><a href="#leetcode-1423-可获得的最大点数" class="headerlink" title="leetcode-1423-可获得的最大点数"></a>leetcode-1423-可获得的最大点数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p><p>示例 1：</p><blockquote><p> 输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</p></blockquote><p>示例 3：</p><blockquote><p>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</p></blockquote><p>示例 4：</p><blockquote><p>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 </p></blockquote><p>示例 5：</p><blockquote><p>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202</p></blockquote><p>提示：</p><ul><li>1 &lt;= cardPoints.length &lt;= 10^5</li><li>1 &lt;= cardPoints[i] &lt;= 10^4</li><li>1 &lt;= k &lt;= cardPoints.length</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards">https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据要求，我们只可以在开头或结尾拿走一张牌，一共拿k张卡牌（<strong>要保证k张卡牌的和最大</strong>），当我们拿走k张卡牌时，会剩下n-k张卡牌，并且这<strong>n-k张卡牌是连续</strong>的，n张卡牌的点数总和是一定的，如果我们保证剩下的n-k张卡牌点数和是最小的，那么我们拿走的k张卡牌的点数和一定是最大的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// 滑动窗口大小</span>        <span class="hljs-keyword">int</span> windowSize = cardPoints.length - k;        <span class="hljs-comment">// 所有卡牌点数总和</span>        <span class="hljs-keyword">int</span> totalSum = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 窗口卡牌点数最小和</span>        <span class="hljs-keyword">int</span> windowMinSum = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 计算出第一个窗口内卡牌的点数和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; windowSize; i++) &#123;            <span class="hljs-comment">// 窗口内卡牌点数进行累加</span>            windowMinSum += cardPoints[i];            <span class="hljs-comment">// 累计和</span>            totalSum += cardPoints[i];        &#125;        <span class="hljs-comment">// 用于临时存储窗口内卡牌的的和</span>        <span class="hljs-keyword">int</span> temp = windowMinSum;        <span class="hljs-comment">//将窗口向右移动，得到每一个窗口内卡牌的点数和，得出最小的窗口和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = windowSize; i &lt; cardPoints.length; i++) &#123;            <span class="hljs-comment">// 继续统计和</span>            totalSum += cardPoints[i];            <span class="hljs-comment">// 计算 i - windowSize 到 i 的窗口内卡牌点数和</span>            temp = temp + cardPoints[i] - cardPoints[i - windowSize];            <span class="hljs-comment">// 两者取最小</span>            windowMinSum = Math.min(windowMinSum, temp);        &#125;        <span class="hljs-comment">// 所有卡牌点数 - 窗口最小和</span>        <span class="hljs-keyword">return</span> totalSum - windowMinSum;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>每日一题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【每日一题】leetcode-547-省份数量</title>
    <link href="/2021/02/05/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2021/02/05/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-547-省份数量"><a href="#leetcode-547-省份数量" class="headerlink" title="leetcode-547-省份数量"></a>leetcode-547-省份数量</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p><p>示例 1：</p><blockquote><p>输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p><p>示例 2：</p><blockquote><p>输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p></blockquote><p>提示：</p><ul><li>1 &lt;= n &lt;= 200</li><li>n == isConnected.length</li><li>n == isConnected[i].length</li><li>isConnected[i][j] 为 1 或 0</li><li>isConnected[i][i] == 1</li><li>isConnected[i][j] == isConnected[j][i]</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-provinces">https://leetcode-cn.com/problems/number-of-provinces</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>我们可以将这个题转换为求无向图中的连通域的个数， isConnected 二维数组即为该无向图的邻接矩阵。求无向图中连通域的个数的求法就有好多种了，常见的有深度优先遍历(DFS)、广度优先遍历(BFS)、并查集</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="深度优先遍历："><a href="#深度优先遍历：" class="headerlink" title="深度优先遍历："></a>深度优先遍历：</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;        <span class="hljs-comment">// 城市的总个数</span>        <span class="hljs-keyword">int</span> total = isConnected.length;        <span class="hljs-comment">// 根据城市总个数初始化一个访问数组</span>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[total];        <span class="hljs-comment">// 统计省份个数的</span>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 遍历每一个城市</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            <span class="hljs-comment">// 如果当前城市i未被访问过，则遍历与城市i相邻的所有城市</span>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;                <span class="hljs-comment">// 遍历和城市i相连接的城市</span>                dfs(isConnected, visited, total, i);                <span class="hljs-comment">// 结果加一</span>                result++;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能：寻找与城市i所有相连的城市，并在visited数组中标记</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isConnected 所有城市组成的无向邻接矩阵</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> visited 访问数组 标记当前城市是否被访问过</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> total 城市的总个数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i 当前要遍历的城市i</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">int</span> total, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; total; j++) &#123;            <span class="hljs-comment">// 如果两个城市相连接，并且该城市未访问过，则将j城市标记为访问过，在接着找和j城市相连接的城市</span>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;                <span class="hljs-comment">// 将城市j标记为访问过</span>                visited[j] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">// 继续找和j城市相连的城市</span>                dfs(isConnected, visited, total, j);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;        <span class="hljs-comment">// 城市的总个数</span>        <span class="hljs-keyword">int</span> total = isConnected.length;        <span class="hljs-comment">// 根据城市总个数初始化一个访问数组</span>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[total];        <span class="hljs-comment">// 统计省份个数的</span>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 定义一个队列</span>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) &#123;            <span class="hljs-comment">// 如果城市i没有被访问过，则要访问它的所有相连的城市</span>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;                <span class="hljs-comment">// 将城市i加入到队列中，等待访问</span>                queue.offer(i);                <span class="hljs-comment">// 将城市i的访问状态设置成true</span>                visited[i] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">// 如果队列不空，就要访问队列中所有城市的相连城市</span>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    <span class="hljs-comment">// 取出城市v</span>                    <span class="hljs-keyword">int</span> v = queue.poll();                    <span class="hljs-comment">// 遍历与城市v相连的所有城市</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; total; j++) &#123;                        <span class="hljs-comment">// 如果j城市与v城市相连，且j城市未被访问过，就将城市j的访问状态置为true，</span>                        <span class="hljs-comment">// 并将j城市放入队列中，等待访问</span>                        <span class="hljs-keyword">if</span> (isConnected[v][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j]) &#123;                            visited[j] = <span class="hljs-keyword">true</span>;                            queue.offer(j);                        &#125;                    &#125;                &#125;                <span class="hljs-comment">// 访问玩城市i相连的城市了，省份加一</span>                result++;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>并查集</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nginx学习】Nginx.conf配置</title>
    <link href="/2021/02/02/%E3%80%90Nginx%E5%AD%A6%E4%B9%A0%E3%80%91nginx-conf%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/02/02/%E3%80%90Nginx%E5%AD%A6%E4%B9%A0%E3%80%91nginx-conf%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Nginx-conf"><a href="#Nginx-conf" class="headerlink" title="Nginx.conf"></a>Nginx.conf</h2><p><strong>Nginx.conf</strong> 我们要在这里配置一些文件。nginx.conf 是主配置文件，由若干个部分组成，每个大括号 <code>&#123;&#125;</code> 表示一个部分。每一行指令都由分号结束 <code>;</code>，标志着一行的结束。</p><h3 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h3><table><thead><tr><th>正则</th><th>说明</th><th>正则</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除换行符以外的任意字符</td><td><code>$</code></td><td>匹配字符串的结束</td></tr><tr><td><code>?</code></td><td>重复 0 次或 1 次</td><td><code>&#123;n&#125;</code></td><td>重复 n 次</td></tr><tr><td><code>+</code></td><td>重复 1 次或更多次</td><td><code>&#123;n,&#125;</code></td><td>重复 n 次或更多次</td></tr><tr><td><code>*</code></td><td>重复 0 次或更多次</td><td><code>[c]</code></td><td>匹配单个字符 c</td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td><code>[a-z]</code></td><td>匹配 a-z 小写字母的任意一个</td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td>-</td><td>-</td></tr></tbody></table><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><table><thead><tr><th>变量</th><th>说明</th><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$args</td><td>这个变量等于请求行中的参数，同 $query_string</td><td>$remote_port</td><td>客户端的端口。</td></tr><tr><td>$content_length</td><td>请求头中的 Content-length 字段。</td><td>$remote_user</td><td>已经经过 Auth Basic Module 验证的用户名。</td></tr><tr><td>$content_type</td><td>请求头中的 Content-Type 字段。</td><td>$request_filename</td><td>当前请求的文件路径，由 root 或 alias 指令与 URI 请求生成。</td></tr><tr><td>$document_root</td><td>当前请求在 root 指令中指定的值。</td><td>$scheme</td><td>HTTP 方法（如 http，https）。</td></tr><tr><td>$host</td><td>请求主机头字段，否则为服务器名称。</td><td>$server_protocol</td><td>请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。</td></tr><tr><td>$http_user_agent</td><td>客户端 agent 信息</td><td>$server_addr</td><td>服务器地址，在完成一次系统调用后可以确定这个值。</td></tr><tr><td>$http_cookie</td><td>客户端 cookie 信息</td><td>$server_name</td><td>服务器名称。</td></tr><tr><td>$limit_rate</td><td>这个变量可以限制连接速率。</td><td>$server_port</td><td>请求到达服务器的端口号。</td></tr><tr><td>$request_method</td><td>客户端请求的动作，通常为 GET 或 POST。</td><td>$request_uri</td><td>包含请求参数的原始 URI，不包含主机名，如：/foo/bar.php?arg=baz。</td></tr><tr><td>$remote_addr</td><td>客户端的 IP 地址。</td><td>$uri</td><td>不带请求参数的当前 URI，$uri 不包含主机名，如 /foo/bar.html。</td></tr><tr><td>$document_uri</td><td>与 $uri 相同。</td><td>-</td><td>-</td></tr></tbody></table><p>例如请求：<code>http://localhost:3000/test1/test2/test.php</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">$host：localhost</span><span class="hljs-attr">$server_port：3000</span><span class="hljs-attr">$request_uri：/test1/test2/test.php</span><span class="hljs-attr">$document_uri：/test1/test2/test.php</span><span class="hljs-attr">$document_root：/var/www/html</span><span class="hljs-attr">$request_filename：/var/www/html/test1/test2/test.php</span></code></pre></div><h3 id="符号参考"><a href="#符号参考" class="headerlink" title="符号参考"></a>符号参考</h3><table><thead><tr><th>符号</th><th>说明</th><th>符号</th><th>说明</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>k,K</td><td>千字节</td><td>m,M</td><td>兆字节</td><td>ms</td><td>毫秒</td></tr><tr><td>s</td><td>秒</td><td>m</td><td>分钟</td><td>h</td><td>小时</td></tr><tr><td>d</td><td>日</td><td>w</td><td>周</td><td>M</td><td>一个月，30 天</td></tr></tbody></table><p>例如，”8k”，”1m” 代表字节数计量。<br>例如，”1h 30m”，”1y 6M”。代表 “1 小时 30 分”，”1 年零 6 个月”。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于 nginx 安装目录下的 conf 目录下。</p><p>指令由 nginx 的各个模块提供，不同的模块会提供不同的指令来实现配置。 指令除了 Key-Value 的形式，还有作用域指令。</p><p>nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p><p>下面的这些上下文指令是用的比较多：</p><table><thead><tr><th>Directive</th><th>Description</th><th>Contains Directive</th></tr></thead><tbody><tr><td>main</td><td>nginx 在运行时与具体业务功能（比如 http 服务或者 email 服务代理）无关的一些参数，比如工作进程数，运行的身份等。</td><td>user, worker_processes, error_log, events, http, mail</td></tr><tr><td>http</td><td>与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用 gzip 进行压缩等。</td><td>server</td></tr><tr><td>server</td><td>http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server. 每个 server 通过监听的地址来区分。</td><td>listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient</td></tr><tr><td>location</td><td>http 服务中，某些特定的 URL 对应的一系列配置项。</td><td>index, root</td></tr><tr><td>mail</td><td>实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</td><td>server, http, imap_capabilities</td></tr><tr><td>include</td><td>以便增强配置文件的可读性，使得部分配置文件可以重新使用。</td><td>-</td></tr><tr><td>valid_referers</td><td>用来校验 Http 请求头 Referer 是否有效。</td><td>-</td></tr><tr><td>try_files</td><td>用在 server 部分，不过最常见的还是用在 location 部分，它会按照给定的参数顺序进行尝试，第一个被匹配到的将会被使用。</td><td>-</td></tr><tr><td>if</td><td>当在 location 块中使用 if 指令，在某些情况下它并不按照预期运行，一般来说避免使用 if 指令。</td><td>-</td></tr></tbody></table><p>例如我们再 <strong>nginx.conf</strong> 里面引用两个配置 vhost/example.com.conf 和 vhost/gitlab.com.conf 它们都被放在一个我自己新建的目录 vhost 下面。nginx.conf 配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span>    <span class="hljs-comment">#access_log  logs/access.log  main;</span>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment">#keepalive_timeout  0;</span>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-comment">#gzip  on;</span>    <span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  localhost;        <span class="hljs-attribute">location</span> / &#123;            <span class="hljs-attribute">root</span>   html;            <span class="hljs-attribute">index</span>  index.html index.htm;        &#125;        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;        <span class="hljs-attribute">location</span> = /50x.html &#123;            <span class="hljs-attribute">root</span>   html;        &#125;    &#125;    <span class="hljs-attribute">include</span>  vhost/example.com.conf;    <span class="hljs-attribute">include</span>  vhost/gitlab.com.conf;&#125;</code></pre></div><p>简单的配置: example.com.conf</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment">#侦听的80端口</span>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  baidu.com app.baidu.com; <span class="hljs-comment"># 这里指定域名</span>    <span class="hljs-attribute">index</span>        index.html index.htm;    <span class="hljs-comment"># 这里指定默认入口页面</span>    <span class="hljs-attribute">root</span> /home/www/app.baidu.com;         <span class="hljs-comment"># 这里指定目录</span>&#125;</code></pre></div><h3 id="内置预定义变量"><a href="#内置预定义变量" class="headerlink" title="内置预定义变量"></a>内置预定义变量</h3><p>Nginx 提供了许多预定义的变量，也可以通过使用 set 来设置变量。你可以在 if 中使用预定义变量，也可以将它们传递给代理服务器。以下是一些常见的预定义变量，<a href="http://nginx.org/en/docs/varindex.html">更多详见</a></p><table><thead><tr><th>变量名称</th><th>值</th></tr></thead><tbody><tr><td>$args_name</td><td>在请求中的 name 参数</td></tr><tr><td>$args</td><td>所有请求参数</td></tr><tr><td>$query_string</td><td>$args 的别名</td></tr><tr><td>$content_length</td><td>请求头 Content-Length 的值</td></tr><tr><td>$content_type</td><td>请求头 Content-Type 的值</td></tr><tr><td>$host</td><td>如果当前有 Host，则为请求头 Host 的值；如果没有这个头，那么该值等于匹配该请求的 server_name 的值</td></tr><tr><td>$remote_addr</td><td>客户端的 IP 地址</td></tr><tr><td>$request</td><td>完整的请求，从客户端收到，包括 Http 请求方法、URI、Http 协议、头、请求体</td></tr><tr><td>$request_uri</td><td>完整请求的 URI，从客户端来的请求，包括参数</td></tr><tr><td>$scheme</td><td>当前请求的协议</td></tr><tr><td>$uri</td><td>当前请求的标准化 URI</td></tr></tbody></table><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理是一个 Web 服务器，它接受客户端的连接请求，然后将请求转发给上游服务器，并将从服务器得到的结果返回给连接的客户端。下面简单的反向代理的例子：</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;                                                          <span class="hljs-attribute">server_name</span>  localhost;                                                <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">1024M</span>;  <span class="hljs-comment"># 允许客户端请求的最大单文件字节数</span>  <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">proxy_pass</span>                         http://localhost:8080;    <span class="hljs-attribute">proxy_set_header</span> Host              $host:$server_port;    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For   $remote_addr; <span class="hljs-comment"># HTTP的请求端真实的IP</span>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto $scheme;      <span class="hljs-comment"># 为了正确地识别实际用户发出的协议是 http 还是 https</span>  &#125;&#125;</code></pre></div><p>复杂的配置: gitlab.com.conf。</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment">#侦听的80端口</span>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  git.example.cn;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_pass</span>   http://localhost:3000;        <span class="hljs-comment">#以下是一些反向代理的配置可删除</span>        <span class="hljs-attribute">proxy_redirect</span>             <span class="hljs-literal">off</span>;        <span class="hljs-comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>        <span class="hljs-attribute">proxy_set_header</span>           Host $host;        <span class="hljs-attribute">client_max_body_size</span>       <span class="hljs-number">10m</span>; <span class="hljs-comment">#允许客户端请求的最大单文件字节数</span>        <span class="hljs-attribute">client_body_buffer_size</span>    <span class="hljs-number">128k</span>; <span class="hljs-comment">#缓冲区代理缓冲用户端请求的最大字节数</span>        <span class="hljs-attribute">proxy_connect_timeout</span>      <span class="hljs-number">300</span>; <span class="hljs-comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span>        <span class="hljs-attribute">proxy_send_timeout</span>         <span class="hljs-number">300</span>; <span class="hljs-comment">#后端服务器数据回传时间(代理发送超时)</span>        <span class="hljs-attribute">proxy_read_timeout</span>         <span class="hljs-number">300</span>; <span class="hljs-comment">#连接成功后，后端服务器响应时间(代理接收超时)</span>        <span class="hljs-attribute">proxy_buffer_size</span>          <span class="hljs-number">4k</span>; <span class="hljs-comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>        <span class="hljs-attribute">proxy_buffers</span>              <span class="hljs-number">4</span> <span class="hljs-number">32k</span>; <span class="hljs-comment">#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span>        <span class="hljs-attribute">proxy_busy_buffers_size</span>    <span class="hljs-number">64k</span>; <span class="hljs-comment">#高负荷下缓冲大小（proxy_buffers*2）</span>    &#125;&#125;</code></pre></div><p>代理到上游服务器的配置中，最重要的是 proxy_pass 指令。以下是代理模块中的一些常用指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>proxy_connect_timeout</td><td>Nginx 从接受请求至连接到上游服务器的最长等待时间</td></tr><tr><td>proxy_send_timeout</td><td>后端服务器数据回传时间 (代理发送超时)</td></tr><tr><td>proxy_read_timeout</td><td>连接成功后，后端服务器响应时间 (代理接收超时)</td></tr><tr><td>proxy_cookie_domain</td><td>替代从上游服务器来的 Set-Cookie 头的 domain 属性</td></tr><tr><td>proxy_cookie_path</td><td>替代从上游服务器来的 Set-Cookie 头的 path 属性</td></tr><tr><td>proxy_buffer_size</td><td>设置代理服务器（nginx）保存用户头信息的缓冲区大小</td></tr><tr><td>proxy_buffers</td><td>proxy_buffers 缓冲区，网页平均在多少 k 以下</td></tr><tr><td>proxy_set_header</td><td>重写发送到上游服务器头的内容，也可以通过将某个头部的值设置为空字符串，而不发送某个头部的方法实现</td></tr><tr><td>proxy_ignore_headers</td><td>这个指令禁止处理来自代理服务器的应答。</td></tr><tr><td>proxy_intercept_errors</td><td>使 nginx 阻止 HTTP 应答代码为 400 或者更高的应答。</td></tr></tbody></table><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>upstream 指令启用一个新的配置区段，在该区段定义一组上游服务器。这些服务器可能被设置不同的权重，也可能出于对服务器进行维护，标记为 down。</p><div class="hljs code-wrapper"><pre><code class="hljs axapta">upstream gitlab &#123;    ip_hash;    <span class="hljs-meta"># upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span>    <span class="hljs-keyword">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.122</span><span class="hljs-number">.11</span>:<span class="hljs-number">8081</span> ;    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">82</span> weight=<span class="hljs-number">3</span>;    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">83</span> weight=<span class="hljs-number">3</span> down;    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">84</span> weight=<span class="hljs-number">3</span>; max_fails=<span class="hljs-number">3</span>  fail_timeout=<span class="hljs-number">20</span>s;    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">85</span> weight=<span class="hljs-number">4</span>;;    keepalive <span class="hljs-number">32</span>;&#125;<span class="hljs-keyword">server</span> &#123;    <span class="hljs-meta">#侦听的80端口</span>    listen       <span class="hljs-number">80</span>;    server_name  git.example.cn;    location / &#123;        proxy_pass   http:<span class="hljs-comment">//gitlab;    #在这里设置一个代理，和upstream的名字一样</span>        <span class="hljs-meta">#以下是一些反向代理的配置可删除</span>        proxy_redirect             off;        <span class="hljs-meta">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>        proxy_set_header           Host $host;        proxy_set_header           X-Real-IP $remote_addr;        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;        client_max_body_size       <span class="hljs-number">10</span>m;  <span class="hljs-meta">#允许客户端请求的最大单文件字节数</span>        client_body_buffer_size    <span class="hljs-number">128</span>k; <span class="hljs-meta">#缓冲区代理缓冲用户端请求的最大字节数</span>        proxy_connect_timeout      <span class="hljs-number">300</span>;  <span class="hljs-meta">#nginx跟后端服务器连接超时时间(代理连接超时)</span>        proxy_send_timeout         <span class="hljs-number">300</span>;  <span class="hljs-meta">#后端服务器数据回传时间(代理发送超时)</span>        proxy_read_timeout         <span class="hljs-number">300</span>;  <span class="hljs-meta">#连接成功后，后端服务器响应时间(代理接收超时)</span>        proxy_buffer_size          <span class="hljs-number">4</span>k; <span class="hljs-meta">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>        proxy_buffers              <span class="hljs-number">4</span> <span class="hljs-number">32</span>k;<span class="hljs-meta"># 缓冲区，网页平均在32k以下的话，这样设置</span>        proxy_busy_buffers_size    <span class="hljs-number">64</span>k; <span class="hljs-meta">#高负荷下缓冲大小（proxy_buffers*2）</span>        proxy_temp_file_write_size <span class="hljs-number">64</span>k; <span class="hljs-meta">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>    &#125;&#125;</code></pre></div><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p><p><strong>负载均衡：</strong></p><p>upstream 模块能够使用 3 种负载均衡算法：轮询、IP 哈希、最少连接数。</p><p><strong>轮询：</strong> 默认情况下使用轮询算法，不需要配置指令来激活它，它是基于在队列中谁是下一个的原理确保访问均匀地分布到每个上游服务器；<br><strong>IP 哈希：</strong> 通过 ip_hash 指令来激活，Nginx 通过 IPv4 地址的前 3 个字节或者整个 IPv6 地址作为哈希键来实现，同一个 IP 地址总是能被映射到同一个上游服务器；<br><strong>最少连接数：</strong> 通过 least_conn 指令来激活，该算法通过选择一个活跃数最少的上游服务器进行连接。如果上游服务器处理能力不同，可以通过给 server 配置 weight 权重来说明，该算法将考虑到不同服务器的加权最少连接数。</p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><strong>简单配置</strong> ，这里我配置了 2 台服务器，当然实际上是一台，只是端口不一样而已，而 8081 的服务器是不存在的，也就是说访问不到，但是我们访问 <code>http://localhost</code> 的时候，也不会有问题，会默认跳转到 <code>http://localhost:8080</code> 具体是因为 Nginx 会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于 Nginx 默认是 RR 策略，所以我们不需要其他更多的设置</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> test &#123;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8080</span>;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8081</span>;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">81</span>;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">1024M</span>;     <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_pass</span> http://test;        <span class="hljs-attribute">proxy_set_header</span> Host $host:$server_port;    &#125;&#125;</code></pre></div><p><strong>负载均衡的核心代码为</strong></p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> test &#123;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8080</span>;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8081</span>;&#125;</code></pre></div><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream test &#123;   <span class="hljs-built_in"> server </span>localhost:8080 <span class="hljs-attribute">weight</span>=9;   <span class="hljs-built_in"> server </span>localhost:8081 <span class="hljs-attribute">weight</span>=1;&#125;</code></pre></div><p>那么 10 次一般只会有 1 次会访问到 8081，而有 9 次会访问到 8080</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>上面的 2 种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了 session 保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 iphash 了，iphash 的每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p><div class="hljs code-wrapper"><pre><code class="hljs roboconf">upstream test &#123;    <span class="hljs-attribute">ip_hash;</span><span class="hljs-attribute">    server localhost</span>:8080;    <span class="hljs-attribute">server localhost</span>:8081;&#125;</code></pre></div><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>这是个第三方模块，按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><div class="hljs code-wrapper"><pre><code class="hljs roboconf">upstream backend &#123;    <span class="hljs-attribute">fair;</span><span class="hljs-attribute">    server localhost</span>:8080;    <span class="hljs-attribute">server localhost</span>:8081;&#125;</code></pre></div><h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>这是个第三方模块，按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。 在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> backend &#123;    <span class="hljs-attribute">hash</span> $request_uri;    <span class="hljs-attribute">hash_method</span> crc32;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8080</span>;    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">8081</span>;&#125;</code></pre></div><p>以上 5 种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式，不过 fair 和 url_hash 需要安装第三方模块才能使用</p><p><strong>server 指令可选参数：</strong></p><ol><li>weight：设置一个服务器的访问权重，数值越高，收到的请求也越多；</li><li>fail_timeout：在这个指定的时间内服务器必须提供响应，如果在这个时间内没有收到响应，那么服务器将会被标记为 down 状态；</li><li>max_fails：设置在 fail_timeout 时间之内尝试对一个服务器连接的最大次数，如果超过这个次数，那么服务器将会被标记为 down;</li><li>down：标记一个服务器不再接受任何请求；</li><li>backup：一旦其他服务器宕机，那么有该标记的机器将会接收请求。</li></ol><p><strong>keepalive 指令：</strong></p><p>Nginx 服务器将会为每一个 worker 进行保持同上游服务器的连接。</p><h3 id="屏蔽-ip"><a href="#屏蔽-ip" class="headerlink" title="屏蔽 ip"></a>屏蔽 ip</h3><p>在 nginx 的配置文件 <code>nginx.conf</code> 中加入如下配置，可以放到 http, server, location, limit_except 语句块，需要注意相对路径，本例当中 <code>nginx.conf</code>，<code>blocksip.conf</code> 在同一个目录中。</p><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span> blockip.conf;</span></code></pre></div><p>在 blockip.conf 里面输入内容，如：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">165.91.122.67</span>;<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> IP;   # 屏蔽单个ip访问<span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> IP;  # 允许单个ip访问<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-literal">all</span>;  # 屏蔽所有ip访问<span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-literal">all</span>; # 允许所有ip访问<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">123.0.0.0</span>/<span class="hljs-number">8</span>   # 屏蔽整个段即从<span class="hljs-number">123.0.0.1</span>到<span class="hljs-number">123.255.255.254</span>访问的命令<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">124.45.0.0</span>/<span class="hljs-number">16</span> # 屏蔽IP段即从<span class="hljs-number">123.45.0.1</span>到<span class="hljs-number">123.45.255.254</span>访问的命令<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">123.45.6.0</span>/<span class="hljs-number">24</span> # 屏蔽IP段即从<span class="hljs-number">123.45.6.1</span>到<span class="hljs-number">123.45.6.254</span>访问的命令<span class="hljs-comment"># 如果你想实现这样的应用，除了几个IP外，其他全部拒绝</span><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">1.1.1.1</span>; <span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">1.1.1.2</span>;<span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-literal">all</span>;</code></pre></div><h2 id="第三方模块安装方法"><a href="#第三方模块安装方法" class="headerlink" title="第三方模块安装方法"></a>第三方模块安装方法</h2><div class="hljs code-wrapper"><pre><code class="hljs routeros">./configure <span class="hljs-attribute">--prefix</span>=/你的安装目录  <span class="hljs-attribute">--add-module</span>=/第三方模块目录</code></pre></div><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul><li><code>permanent</code> 永久性重定向。请求日志中的状态码为 301</li><li><code>redirect</code> 临时重定向。请求日志中的状态码为 302</li></ul><h3 id="重定向整个网站"><a href="#重定向整个网站" class="headerlink" title="重定向整个网站"></a>重定向整个网站</h3><div class="hljs code-wrapper"><pre><code class="hljs elixir">server &#123;    server_name old-site.com    <span class="hljs-keyword">return</span> <span class="hljs-number">301</span> <span class="hljs-variable">$scheme</span><span class="hljs-symbol">://new-site</span>.com<span class="hljs-variable">$request_uri</span>;&#125;</code></pre></div><h3 id="重定向单页"><a href="#重定向单页" class="headerlink" title="重定向单页"></a>重定向单页</h3><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">location</span> = /oldpage.html &#123;        <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> http://example.org/newpage.html;    &#125;&#125;</code></pre></div><h3 id="重定向整个子路径"><a href="#重定向整个子路径" class="headerlink" title="重定向整个子路径"></a>重定向整个子路径</h3><div class="hljs code-wrapper"><pre><code class="hljs awk">location /old-site &#123;    rewrite ^<span class="hljs-regexp">/old-site/</span>(.*) http:<span class="hljs-regexp">//</span>example.org<span class="hljs-regexp">/new-site/</span><span class="hljs-variable">$1</span> permanent;&#125;</code></pre></div><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="内容缓存"><a href="#内容缓存" class="headerlink" title="内容缓存"></a>内容缓存</h3><p>允许浏览器基本上永久地缓存静态内容。 Nginx 将为您设置 Expires 和 Cache-Control 头信息。</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/static</span> &#123;    root /data;    expires max;&#125;</code></pre></div><p>如果要求浏览器永远不会缓存响应（例如用于跟踪请求），请使用 - 1。</p><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">location</span> = /empty.gif &#123;    empty_gif<span class="hljs-comment">;</span>    expires -<span class="hljs-number">1</span><span class="hljs-comment">;</span>&#125;</code></pre></div><h3 id="Gzip-压缩"><a href="#Gzip-压缩" class="headerlink" title="Gzip 压缩"></a>Gzip 压缩</h3><div class="hljs code-wrapper"><pre><code class="hljs applescript">gzip  <span class="hljs-keyword">on</span>;gzip_buffers <span class="hljs-number">16</span> <span class="hljs-number">8</span>k;gzip_comp_level <span class="hljs-number">6</span>;gzip_http_version <span class="hljs-number">1.1</span>;gzip_min_length <span class="hljs-number">256</span>;gzip_proxied any;gzip_vary <span class="hljs-keyword">on</span>;gzip_types    <span class="hljs-built_in">text</span>/xml <span class="hljs-built_in">application</span>/xml <span class="hljs-built_in">application</span>/atom+xml <span class="hljs-built_in">application</span>/rss+xml <span class="hljs-built_in">application</span>/xhtml+xml image/svg+xml    <span class="hljs-built_in">text</span>/javascript <span class="hljs-built_in">application</span>/javascript <span class="hljs-built_in">application</span>/x-javascript    <span class="hljs-built_in">text</span>/x-json <span class="hljs-built_in">application</span>/json <span class="hljs-built_in">application</span>/x-web-app-manifest+json    <span class="hljs-built_in">text</span>/css <span class="hljs-built_in">text</span>/plain <span class="hljs-built_in">text</span>/x-component    font/opentype <span class="hljs-built_in">application</span>/x-font-ttf <span class="hljs-built_in">application</span>/vnd.ms-fontobject    image/x-icon;gzip_disable  <span class="hljs-string">&quot;msie6&quot;</span>;</code></pre></div><h3 id="打开文件缓存"><a href="#打开文件缓存" class="headerlink" title="打开文件缓存"></a>打开文件缓存</h3><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">open_file_cache</span> max=<span class="hljs-number">1000</span> inactive=<span class="hljs-number">20</span>s;<span class="hljs-attribute">open_file_cache_valid</span> <span class="hljs-number">30</span>s;<span class="hljs-attribute">open_file_cache_min_uses</span> <span class="hljs-number">2</span>;<span class="hljs-attribute">open_file_cache_errors</span> <span class="hljs-literal">on</span>;</code></pre></div><h3 id="SSL-缓存"><a href="#SSL-缓存" class="headerlink" title="SSL 缓存"></a>SSL 缓存</h3><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">ssl_session_cache</span> shared:SSL:<span class="hljs-number">10</span>m;<span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">10</span>m;</code></pre></div><h3 id="上游-Keepalive"><a href="#上游-Keepalive" class="headerlink" title="上游 Keepalive"></a>上游 Keepalive</h3><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">upstream backend &#123;    server 127.0.0.1<span class="hljs-function">:8080</span>;    keepalive 32;&#125;server &#123;    <span class="hljs-string">...</span>    location <span class="hljs-string">/api/</span> &#123;        proxy_pass http:<span class="hljs-string">//backend</span>;        proxy_http_<span class="hljs-keyword">version</span> 1.1;        proxy_<span class="hljs-keyword">set</span>_header Connection <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;</code></pre></div><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>使用 <code>ngxtop</code> 实时解析 nginx 访问日志，并且将处理结果输出到终端，功能类似于系统命令 top。所有示例都读取 nginx 配置文件的访问日志位置和格式。如果要指定访问日志文件和 / 或日志格式，请使用 - f 和 - a 选项。</p><p>注意：在 nginx 配置中 <code>/usr/local/nginx/conf/nginx.conf</code> 日志文件必须是绝对路径。</p><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 安装 ngxtop</span>pip install ngxtop<span class="hljs-meta"># 实时状态</span>ngxtop<span class="hljs-meta"># 状态为404的前10个请求的路径：</span>ngxtop top request_path --filter <span class="hljs-string">&#x27;status == 404&#x27;</span><span class="hljs-meta"># 发送总字节数最多的前10个请求</span>ngxtop --order-by <span class="hljs-string">&#x27;avg(bytes_sent) * count&#x27;</span><span class="hljs-meta"># 排名前十位的IP，例如，谁攻击你最多</span>ngxtop --group-by remote_addr<span class="hljs-meta"># 打印具有4xx或5xx状态的请求，以及status和http referer</span>ngxtop -i <span class="hljs-string">&#x27;status &gt;= 400&#x27;</span> print request status http_referer<span class="hljs-meta"># 由200个请求路径响应发送的平均正文字节以&#x27;foo&#x27;开始：</span>ngxtop avg bytes_sent --filter <span class="hljs-string">&#x27;status == 200 and request_path.startswith(&quot;foo&quot;)&#x27;</span><span class="hljs-meta"># 使用“common”日志格式从远程机器分析apache访问日志</span>ssh remote tail -f /<span class="hljs-keyword">var</span>/log/apache2/access.log | ngxtop -f common</code></pre></div><p><a href="https://github.com/jaywcjlove/nginx-tutorial#%E9%85%8D%E7%BD%AE">https://github.com/jaywcjlove/nginx-tutorial#%E9%85%8D%E7%BD%AE</a></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【nginx学习】第一章</title>
    <link href="/2021/02/02/%E3%80%90nginx%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2021/02/02/%E3%80%90nginx%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="【nginx学习】第一章"><a href="#【nginx学习】第一章" class="headerlink" title="【nginx学习】第一章"></a>【nginx学习】第一章</h1><p><strong>nginx</strong>是一款面向性能设计的 HTTP 服务器，能反向代理 HTTP，HTTPS 和邮件相关 (SMTP，POP3，IMAP) 的协议链接。并且提供了负载均衡以及 HTTP 缓存。它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。采用了模块化设计，提供了丰富模块的第三方模块。</p><p>所以关于 Nginx，有这些标签：<strong>「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」</strong></p><h2 id="nginx下载"><a href="#nginx下载" class="headerlink" title="nginx下载"></a>nginx下载</h2><p>nginx下载网址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p><img src="https://i.loli.net/2021/02/02/DeG1vI2i3JmZSza.png" alt="nginxdownload.png"></p><p>看nginx的下载页面：nginx官网提供了三个类型的版本:</p><p><strong>Mainline version：</strong>Mainline 是 Nginx 目前主力在做的版本，可以说是开发版<br><strong>Stable version：</strong>最新稳定版，生产环境上建议使用的版本 <strong>推荐选择这个</strong><br><strong>Legacy versions：</strong>遗留的老版本的稳定版</p><p>我下载的是windows版本。</p><p>下载完毕后，解压在任意目录</p><p><img src="https://i.loli.net/2021/02/02/9ZvnMKdk2JxqzSY.png" alt="nginx01.png"></p><h2 id="nginx启动"><a href="#nginx启动" class="headerlink" title="nginx启动"></a>nginx启动</h2><p><strong>方法一</strong>：双击nginx.exe</p><p><strong>方法二</strong>：在此目录打开cmd，运行<code>start nginx</code></p><p>启动后：访问<code>localhost:80</code>出现如下页面</p><p><img src="https://i.loli.net/2021/02/02/nIY5UboOQsgljr7.png" alt="nginx02.png"></p><h2 id="nginx相关命令"><a href="#nginx相关命令" class="headerlink" title="nginx相关命令"></a>nginx相关命令</h2><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看帮助信息</span>nginx -h<span class="hljs-comment"># 查看nginx版本</span>nginx -v<span class="hljs-comment"># 启动nginx</span>start nginx<span class="hljs-comment"># 关闭nginx，完整有序的停止nginx，保存相关信息</span>nginx -s quit<span class="hljs-comment"># 关闭nginx，快速停止nginx，可能不保存相关信息</span>nginx -s stop<span class="hljs-comment"># 重新载入nginx，当配置信息需要重新加载配置时使用</span>nginx -s reload<span class="hljs-comment"># 测试nginx配置文件是否正确</span>nginx -t -c filename<span class="hljs-comment"># 重新打开日志文件</span>nginx -s reopen</code></pre></div><h2 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h2><h3 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h3><p> 在 nginx 的配置文件中，大概分为几个区域：<code>events &#123;&#125;</code>、<code>http &#123;&#125;</code>、和没有被 <code>&#123;&#125;</code>包裹的区域。而 <code>http &#123;&#125;</code> 中还有 <code>server &#123;&#125;</code>，以及 <code>server &#123;&#125;</code> 中的 <code>location &#123;&#125;</code>。结构如下：</p><div class="hljs code-wrapper"><pre><code class="hljs undefined">...worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    ...    server &#123;        ...        location &#123;            ...        &#125;    &#125;    server &#123;        ...    &#125;&#125;</code></pre></div><ul><li>没有被 <code>&#123;&#125;</code> 包裹的部分为全局配置，如 <code>worker_processes 1;</code> 设置工作进程（子进程）数为 1</li><li><code>events &#123;&#125;</code> 为 nginx 连接配置的模块，如 <code>worker_connections 1024;</code> 设置每一个子进程最大允许连接 1024 个连接</li><li><code>http &#123;&#125;</code> 为 nginx http 核心配置模块</li><li><code>server &#123;&#125;</code> 为虚拟主机配置模块，包括监听端口、监听域名等</li><li><code>location &#123;&#125;</code> URI 匹配</li></ul><h3 id="配置文件分析"><a href="#配置文件分析" class="headerlink" title="配置文件分析"></a><strong>配置文件分析</strong></h3><p>nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于 nginx 安装目录下的 conf 目录下。</p><p><img src="https://i.loli.net/2021/02/05/VfnJPcg9ukpsSqi.png" alt="nginx03.png"></p><p>这里我们对nginx.conf文件进行分析</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># user 指定运行 nginx 的用户和组（第一个参数为用户第二个为组，这里只有用户）</span><span class="hljs-comment">#user  nobody;</span><span class="hljs-comment"># 指定工作进程数（一般设置为CPU核数）</span><span class="hljs-attr">worker_processes</span>  <span class="hljs-string">1;   </span><span class="hljs-comment"># 指定错误日志为 logs/ 目录下的 error.log 文件</span><span class="hljs-comment">#error_log  logs/error.log;</span><span class="hljs-comment"># 指定错误日志，并指定写入格式为 notice</span><span class="hljs-comment">#error_log  logs/error.log  notice;</span><span class="hljs-comment"># 指定错误日志，并指定写入格式为 info  </span><span class="hljs-comment">#error_log  logs/error.log  info;</span><span class="hljs-comment"># 指定 pid 文件（存放主进程 pid 号）</span><span class="hljs-comment">#pid        logs/nginx.pid;</span><span class="hljs-comment"># nginx 连接配置模块</span><span class="hljs-attr">events</span> <span class="hljs-string">&#123;</span><span class="hljs-comment">    # 指定每个工作进程最大连接数为 1024</span>    <span class="hljs-attr">worker_connections</span>  <span class="hljs-string">1024;</span><span class="hljs-attr">&#125;</span><span class="hljs-comment"># http 配置模块</span><span class="hljs-attr">http</span> <span class="hljs-string">&#123;</span><span class="hljs-comment">    # 通过 include 加载 mime.types 文件，里面的 types &#123;&#125; 模块将文件扩展名映射到响应的 MIME 类型</span>    <span class="hljs-attr">include</span>       <span class="hljs-string">mime.types;</span><span class="hljs-comment">    # 定义响应的默认 MIME 类型</span>    <span class="hljs-attr">default_type</span>  <span class="hljs-string">application/octet-stream;</span><span class="hljs-comment">    # 写入格式 main 的内容格式如下</span><span class="hljs-comment">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><span class="hljs-comment">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><span class="hljs-comment">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><span class="hljs-comment">    # 指定访问日志和写入格式为 main</span><span class="hljs-comment">    #access_log  logs/access.log  main;</span><span class="hljs-comment">    # 启用或者禁用 sendfile()</span>    <span class="hljs-attr">sendfile</span>        <span class="hljs-string">on;</span><span class="hljs-comment">    # 启用或者禁用使用套接字选项（仅在 sendfile 使用时使用）</span><span class="hljs-comment">    #tcp_nopush     on;</span><span class="hljs-comment">    # 0 值禁用保持活动的客户端连接</span><span class="hljs-comment">    #keepalive_timeout  0;</span><span class="hljs-comment">    # 65 s 超时</span>    <span class="hljs-attr">keepalive_timeout</span>  <span class="hljs-string">65;</span><span class="hljs-comment">    # 启用或者禁用 gzip</span><span class="hljs-comment">    #gzip  on;</span><span class="hljs-comment">    # 虚拟主机配置模块</span>    <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><span class="hljs-comment">        # 监听 80 端口</span>        <span class="hljs-attr">listen</span>       <span class="hljs-string">80;</span><span class="hljs-comment">        # 监听域名为 localhost</span>        <span class="hljs-attr">server_name</span>  <span class="hljs-string">localhost;</span><span class="hljs-comment">        # 将指定的 charset 添加到 “Content-Type” 响应头字段。如果此charset与source_charset指令中指定的charset不同，则执行转换。</span><span class="hljs-comment">        #charset koi8-r;</span><span class="hljs-comment">        # 指定该虚拟主机的访问日志</span><span class="hljs-comment">        #access_log  logs/host.access.log  main;</span><span class="hljs-comment">        # 将特定的文件或目录重新定位，如 php 文件，image 目录等</span>        <span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><span class="hljs-comment">            # 设置请求的根目录</span>            <span class="hljs-attr">root</span>   <span class="hljs-string">html;</span><span class="hljs-comment">            # 定义索引，按顺序匹配</span>            <span class="hljs-attr">index</span>  <span class="hljs-string">index.html index.htm;</span>        <span class="hljs-attr">&#125;</span><span class="hljs-comment">        # 定义显示 404 错误的 uri</span><span class="hljs-comment">        #error_page  404              /404.html;</span><span class="hljs-comment">        # redirect server error pages to the static page /50x.html</span><span class="hljs-comment">        #</span>        <span class="hljs-attr">error_page</span>   <span class="hljs-string">500 502 503 504  /50x.html;</span><span class="hljs-comment">        # location 精准匹配 &#x27;/50x.html&#x27;</span>        <span class="hljs-attr">location</span> = <span class="hljs-string">/50x.html &#123;</span>            <span class="hljs-attr">root</span>   <span class="hljs-string">html;</span>        <span class="hljs-attr">&#125;</span><span class="hljs-comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><span class="hljs-comment">        # 正则表达式匹配 php 文件</span><span class="hljs-comment">        #location ~ \.php$ &#123;</span><span class="hljs-comment">            # 设置代理服务器的协议和地址，以及应该映射位置的可选URI。作为协议，可以指定“http”或“https”。该地址可以指定为一个域名或IP地址，以及一个可选端口</span><span class="hljs-comment">        #    proxy_pass   http://127.0.0.1;</span><span class="hljs-comment">        #&#125;</span><span class="hljs-comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><span class="hljs-comment">        #</span><span class="hljs-comment">        #location ~ \.php$ &#123;</span><span class="hljs-comment">        #    root           html;</span><span class="hljs-comment">             # 设置 FastCGI 服务器的地址。地址可以指定为一个域名或 IP 地址，以及一个端口</span><span class="hljs-comment">        #    fastcgi_pass   127.0.0.1:9000;</span><span class="hljs-comment">             # 设置将在以斜杠结尾的URI之后追加的文件名，</span><span class="hljs-comment">        #    fastcgi_index  index.php;</span><span class="hljs-comment">             # 设置一个应该传递给FastCGI服务器的参数。</span><span class="hljs-comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><span class="hljs-comment">             # 加载 conf/fastcgi_params 文件</span><span class="hljs-comment">        #    include        fastcgi_params;</span><span class="hljs-comment">        #&#125;</span><span class="hljs-comment">        # deny access to .htaccess files, if Apache&#x27;s document root</span><span class="hljs-comment">        # concurs with nginx&#x27;s one</span><span class="hljs-comment">        #</span><span class="hljs-comment">        #location ~ /\.ht &#123;</span><span class="hljs-comment">        #    deny  all;</span><span class="hljs-comment">        #&#125;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span><span class="hljs-comment">    #</span><span class="hljs-comment">    #server &#123;</span><span class="hljs-comment">    #    listen       8000;</span><span class="hljs-comment">    #    listen       somename:8080;</span><span class="hljs-comment">    #    server_name  somename  alias  another.alias;</span><span class="hljs-comment">    #    location / &#123;</span><span class="hljs-comment">    #        root   html;</span><span class="hljs-comment">    #        index  index.html index.htm;</span><span class="hljs-comment">    #    &#125;</span><span class="hljs-comment">    #&#125;</span><span class="hljs-comment">    # HTTPS server</span><span class="hljs-comment">    #</span><span class="hljs-comment">    # ssl 配置，要启用 ssl 模块需要在编译 nginx 时加上 --with-http_ssl_module 参数</span><span class="hljs-comment">    #server &#123;</span><span class="hljs-comment">    #    listen       443 ssl;</span><span class="hljs-comment">    #    server_name  localhost;</span><span class="hljs-comment">    #    ssl_certificate      cert.pem;</span><span class="hljs-comment">    #    ssl_certificate_key  cert.key;</span><span class="hljs-comment">    #    ssl_session_cache    shared:SSL:1m;</span><span class="hljs-comment">    #    ssl_session_timeout  5m;</span><span class="hljs-comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><span class="hljs-comment">    #    ssl_prefer_server_ciphers  on;</span><span class="hljs-comment">    #    location / &#123;</span><span class="hljs-comment">    #        root   html;</span><span class="hljs-comment">    #        index  index.html index.htm;</span><span class="hljs-comment">    #    &#125;</span><span class="hljs-comment">    #&#125;</span><span class="hljs-attr">&#125;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>服务器</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Mybatis】基于XML的增删改查</title>
    <link href="/2021/02/01/%E3%80%90Mybatis%E3%80%91%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/2021/02/01/%E3%80%90Mybatis%E3%80%91%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="Mybatis-基于xml的简单增删改查"><a href="#Mybatis-基于xml的简单增删改查" class="headerlink" title="Mybatis 基于xml的简单增删改查"></a>Mybatis 基于xml的简单增删改查</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="1-创建一个Maven工程"><a href="#1-创建一个Maven工程" class="headerlink" title="1. 创建一个Maven工程"></a>1. 创建一个Maven工程</h4><h4 id="2-添加pom依赖"><a href="#2-添加pom依赖" class="headerlink" title="2. 添加pom依赖"></a>2. 添加pom依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h4 id="3-在src-main-resources下创建log4j-properties文件，内容如下"><a href="#3-在src-main-resources下创建log4j-properties文件，内容如下" class="headerlink" title="3. 在src/main/resources下创建log4j.properties文件，内容如下"></a>3. 在src/main/resources下创建log4j.properties文件，内容如下</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># Set root category priority to INFO and its only appender to CONSOLE.</span><span class="hljs-comment">#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal</span><span class="hljs-meta">log4j.rootCategory</span>=<span class="hljs-string">debug, CONSOLE, LOGFILE</span><span class="hljs-comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span><span class="hljs-meta">log4j.logger.org.apache.axis.enterprise</span>=<span class="hljs-string">FATAL, CONSOLE</span><span class="hljs-comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span><span class="hljs-meta">log4j.appender.CONSOLE</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.CONSOLE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.CONSOLE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span><span class="hljs-comment"># LOGFILE is set to be a File appender using a PatternLayout.</span><span class="hljs-meta">log4j.appender.LOGFILE</span>=<span class="hljs-string">org.apache.log4j.FileAppender</span><span class="hljs-meta">log4j.appender.LOGFILE.File</span>=<span class="hljs-string">d:\axis.log</span><span class="hljs-meta">log4j.appender.LOGFILE.Append</span>=<span class="hljs-string">true</span><span class="hljs-meta">log4j.appender.LOGFILE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.LOGFILE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span></code></pre></div><h4 id="4-在src-main-resources下创建mydbconfig-properties-文件，内容如下"><a href="#4-在src-main-resources下创建mydbconfig-properties-文件，内容如下" class="headerlink" title="4. 在src/main/resources下创建mydbconfig.properties 文件，内容如下"></a>4. 在src/main/resources下创建mydbconfig.properties 文件，内容如下</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">db.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">db.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/你的数据库名</span><span class="hljs-meta">db.username</span>=<span class="hljs-string">username</span><span class="hljs-meta">db.password</span>=<span class="hljs-string">password</span></code></pre></div><h4 id="5-在src-main-java-下的com-beans包创建实体类-UserBean"><a href="#5-在src-main-java-下的com-beans包创建实体类-UserBean" class="headerlink" title="5. 在src/main/java/下的com.beans包创建实体类 UserBean"></a>5. 在src/main/java/下的com.beans包创建实体类 UserBean</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBean</span> </span>&#123;<span class="hljs-keyword">private</span> Integer id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> String email;<span class="hljs-keyword">private</span> Integer age;    &lt;!-- getset方法自行实现 --&gt;&#125;</code></pre></div><h4 id="6-在src-main-java-下的com-mapper包创建持久层接口-UserMapper"><a href="#6-在src-main-java-下的com-mapper包创建持久层接口-UserMapper" class="headerlink" title="6. 在src/main/java/下的com.mapper包创建持久层接口 UserMapper"></a>6. 在src/main/java/下的com.mapper包创建持久层接口 UserMapper</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;  &#125;</code></pre></div><h4 id="7-在src-main-resources-mapping下创建持久层接口UserMapper的映射文件UserMapper-xml"><a href="#7-在src-main-resources-mapping下创建持久层接口UserMapper的映射文件UserMapper-xml" class="headerlink" title="7. 在src/main/resources/mapping下创建持久层接口UserMapper的映射文件UserMapper.xml"></a>7. 在src/main/resources/mapping下创建持久层接口UserMapper的映射文件UserMapper.xml</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 中填写持久层接口的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h4 id="8-在src-main-resources下创建mybatis-config-xml配置如下"><a href="#8-在src-main-resources下创建mybatis-config-xml配置如下" class="headerlink" title="8. 在src/main/resources下创建mybatis-config.xml配置如下"></a>8. 在src/main/resources下创建mybatis-config.xml配置如下</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mydbconfig.properties&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.driver&#125;&quot;</span>/&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.username&#125;&quot;</span> /&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.password&#125;&quot;</span> /&gt;</span>             <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>      <span class="hljs-comment">&lt;!----&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapping/UserMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h3 id="一、-增加"><a href="#一、-增加" class="headerlink" title="一、 增加"></a>一、 增加</h3><h4 id="持久层接口中增加-insertUser-方法"><a href="#持久层接口中增加-insertUser-方法" class="headerlink" title="持久层接口中增加 insertUser 方法"></a>持久层接口中增加 insertUser 方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//持久层接口中增加 insertUser 方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">//返回一个true or false 添加成功为true,失败为false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(UserBean ub)</span></span>; &#125;</code></pre></div><h4 id="映射文件UserMapper-xml实现持久层接口中的方法-insertUser"><a href="#映射文件UserMapper-xml实现持久层接口中的方法-insertUser" class="headerlink" title="映射文件UserMapper.xml实现持久层接口中的方法 insertUser"></a>映射文件UserMapper.xml实现持久层接口中的方法 insertUser</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 中填写持久层接口的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 insertUser id为方法名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        insert into user (name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="二、-删除"><a href="#二、-删除" class="headerlink" title="二、 删除"></a>二、 删除</h3><h4 id="持久层接口中增加-deleteUserById方法"><a href="#持久层接口中增加-deleteUserById方法" class="headerlink" title="持久层接口中增加 deleteUserById方法"></a>持久层接口中增加 deleteUserById方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//持久层接口中增加 insertUser 方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">//返回一个true or false 添加成功为true,失败为false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(UserBean ub)</span></span>;     <span class="hljs-comment">//返回一个true or false 删除成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><h4 id="映射文件UserMapper-xml中实现持久层接口中的方法-deleteUserById"><a href="#映射文件UserMapper-xml中实现持久层接口中的方法-deleteUserById" class="headerlink" title="映射文件UserMapper.xml中实现持久层接口中的方法 deleteUserById"></a>映射文件UserMapper.xml中实现持久层接口中的方法 deleteUserById</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 中填写持久层接口的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 insertUser id为方法名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        insert into user (name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 deleteUserById id为方法名--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        delete from user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="三、修改"><a href="#三、修改" class="headerlink" title="三、修改"></a>三、修改</h3><h4 id="持久层接口中增加-updateUser方法"><a href="#持久层接口中增加-updateUser方法" class="headerlink" title="持久层接口中增加 updateUser方法"></a>持久层接口中增加 updateUser方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//持久层接口中增加 updateUser 方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">//返回一个true or false 添加成功为true,失败为false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(UserBean ub)</span></span>;     <span class="hljs-comment">//返回一个true or false 删除成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">//返回一个true or false 修改成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(UserBean ub)</span></span>;&#125;</code></pre></div><h4 id="映射文件UserMapper-xml实现持久层接口中的方法-updateUser"><a href="#映射文件UserMapper-xml实现持久层接口中的方法-updateUser" class="headerlink" title="映射文件UserMapper.xml实现持久层接口中的方法 updateUser"></a>映射文件UserMapper.xml实现持久层接口中的方法 updateUser</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 中填写持久层接口的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 insertUser id为方法名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        insert into user (name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 deleteUserById id为方法名--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        delete from user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 updateUser id为方法名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>update user set name = #&#123;name&#125;,age = #&#123;age&#125;,email = #&#123;email&#125; where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="四、查询"><a href="#四、查询" class="headerlink" title="四、查询"></a>四、查询</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><h5 id="持久层接口中增加-getAllUser方法"><a href="#持久层接口中增加-getAllUser方法" class="headerlink" title="持久层接口中增加 getAllUser方法"></a>持久层接口中增加 getAllUser方法</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//持久层接口中增加 updateUser 方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">//返回一个true or false 添加成功为true,失败为false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(UserBean ub)</span></span>;     <span class="hljs-comment">//返回一个true or false 删除成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">//返回一个true or false 修改成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(UserBean ub)</span></span>;    <span class="hljs-comment">//返回一个集合，元素为 UserBean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserBean&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h5 id="映射文件UserMapper-xml实现持久层接口中的方法-getAllUser"><a href="#映射文件UserMapper-xml实现持久层接口中的方法-getAllUser" class="headerlink" title="映射文件UserMapper.xml实现持久层接口中的方法 getAllUser"></a>映射文件UserMapper.xml实现持久层接口中的方法 getAllUser</h5><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 中填写持久层接口的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 insertUser id为方法名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        insert into user (name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 deleteUserById id为方法名--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        delete from user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 updateUser id为方法名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>update user set name = #&#123;name&#125;,age = #&#123;age&#125;,email = #&#123;email&#125; where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 getAllUser id为方法名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        select * from user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="持久层接口中增加-getListUserLikeName方法"><a href="#持久层接口中增加-getListUserLikeName方法" class="headerlink" title="持久层接口中增加 getListUserLikeName方法"></a>持久层接口中增加 getListUserLikeName方法</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//持久层接口中增加 updateUser 方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-comment">//返回一个true or false 添加成功为true,失败为false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(UserBean ub)</span></span>;     <span class="hljs-comment">//返回一个true or false 删除成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-comment">//返回一个true or false 修改成功为true,失败为false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(UserBean ub)</span></span>;    <span class="hljs-comment">//返回一个集合，元素为 UserBean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserBean&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//返回一个集合 参数为姓名 实现模糊查找</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserBean&gt; <span class="hljs-title">getListUserLikeName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><h5 id="映射文件UserMapper-xml实现持久层接口中的方法-getAllUser-1"><a href="#映射文件UserMapper-xml实现持久层接口中的方法-getAllUser-1" class="headerlink" title="映射文件UserMapper.xml实现持久层接口中的方法 getAllUser"></a>映射文件UserMapper.xml实现持久层接口中的方法 getAllUser</h5><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span>  </span><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.mapper.UserMapper&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 insertUser id为方法名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        insert into user (name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 deleteUserById id为方法名--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span>        delete from user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 updateUser id为方法名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>update user set name = #&#123;name&#125;,age = #&#123;age&#125;,email = #&#123;email&#125; where id = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 getAllUser id为方法名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>        select * from user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 实现持久层接口中的方法 getListUserLikeName id为方法名 利用concat函数防止sql注入 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getListUserLikeName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span>             <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.beans.UserBean&quot;</span>&gt;</span>select * from user where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitTest</span> </span>&#123;SqlSession sqlSession = <span class="hljs-keyword">null</span>;UserMapper userMapper = <span class="hljs-keyword">null</span>;<span class="hljs-meta">@Before</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 1.加载类路径下的配置文件</span><span class="hljs-comment">// 2.InputStream in= Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span>InputStream in = Test.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<span class="hljs-comment">// 3.创建SqlSessionFactory的构建者对象</span>SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<span class="hljs-comment">// 4.使用构建者对象创建工厂对象SqlSessionFactory</span>SqlSessionFactory factory = builder.build(in);<span class="hljs-comment">// 5.使用SqlSessionFactory产生sqlSession对象</span>sqlSession = factory.openSession();<span class="hljs-comment">// 6.使用sqlSession创建接口userMapper的代理对象</span>userMapper = sqlSession.getMapper(UserMapper.class);&#125;<span class="hljs-meta">@After</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 提交事务</span>sqlSession.commit();        <span class="hljs-comment">// 关闭</span>sqlSession.close();&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;UserBean ub = <span class="hljs-keyword">new</span> UserBean();ub.setName(<span class="hljs-string">&quot;ttt&quot;</span>);ub.setAge(<span class="hljs-number">12</span>);ub.setEmail(<span class="hljs-string">&quot;ttt@qq.com&quot;</span>);Integer res = userMapper.insertUser(ub); <span class="hljs-comment">///调用方法</span><span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);System.out.println(<span class="hljs-string">&quot;自增Id为：&quot;</span> + res);&#125;&#125;    <span class="hljs-comment">// 其他方法自行实现吧</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>增删改查</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SpringBoot】整合WebSocket</title>
    <link href="/2021/02/01/%E3%80%90SpringBoot%E3%80%91%E9%9B%86%E6%88%90WebSocket/"/>
    <url>/2021/02/01/%E3%80%90SpringBoot%E3%80%91%E9%9B%86%E6%88%90WebSocket/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot整合WebSocket"><a href="#SpringBoot整合WebSocket" class="headerlink" title="SpringBoot整合WebSocket"></a>SpringBoot整合WebSocket</h2><h3 id="用到的依赖"><a href="#用到的依赖" class="headerlink" title="用到的依赖"></a>用到的依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="java服务端代码"><a href="#java服务端代码" class="headerlink" title="java服务端代码"></a>java服务端代码</h3><h5 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title">serverEndpointExporter</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerEndpointExporter();    &#125;&#125;</code></pre></div><h5 id="WebSocket服务"><a href="#WebSocket服务" class="headerlink" title="WebSocket服务"></a>WebSocket服务</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明websocket的服务地址</span><span class="hljs-meta">@ServerEndpoint(&quot;/websocket/&#123;sid&#125;&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 静态变量，用来记录当前在线连接数。线程安全。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger onlineCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServer&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 与某个客户端的连接会话，需要通过它来给客户端发送数据</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Session session;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接收sid</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String sid = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接建立成功调用的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnOpen</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session, <span class="hljs-meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> </span>&#123;        <span class="hljs-keyword">this</span>.session = session; <span class="hljs-comment">//保存当前客户端的session</span>        webSocketSet.add(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 加入set中</span>        addOnlineCount();<span class="hljs-comment">// 在线数加1</span>        System.out.println(session.getRequestURI());        log.info(<span class="hljs-string">&quot;有新用户登录:&quot;</span> + sid + <span class="hljs-string">&quot;, 当前在线人数为&quot;</span> + getOnlineCount());        <span class="hljs-keyword">this</span>.sid = sid;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 前台连接关闭调用的方法</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnClose</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>&#123;        webSocketSet.remove(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">//从set中删除已关闭的连接</span>        subOnlineCount(); <span class="hljs-comment">// 在线人数数减 1</span>        log.info(<span class="hljs-string">&quot;有一用户连接关闭！当前在线人数为&quot;</span> + getOnlineCount());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 收到客户端消息后调用的方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 客户端发送过来的消息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnMessage</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message, Session session)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;收到来自窗口&quot;</span> + sid + <span class="hljs-string">&quot;的信息:&quot;</span> + message);        <span class="hljs-comment">//群发消息</span>        <span class="hljs-keyword">for</span> (WebSocketServer item : webSocketSet) &#123;            item.sendMessage(<span class="hljs-string">&quot;欢迎客户登录&quot;</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接发生错误</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> session</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> error</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnError</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Session session, Throwable error)</span> </span>&#123;        log.error(<span class="hljs-string">&quot;发生错误&quot;</span>);        error.printStackTrace();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 服务器推送数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息内容</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.session.getBasicRemote().sendText(message);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            log.error(<span class="hljs-string">&quot;消息推送失败&quot;</span>);            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 管理元推送全部消息给用户 一对多</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushMessageToAllUser</span><span class="hljs-params">(String message)</span></span>&#123;        <span class="hljs-comment">// 只要在集合中的（也就是全部用户） 就给他发送消息</span>        <span class="hljs-keyword">for</span> (WebSocketServer item : webSocketSet) &#123;            item.sendMessage(message);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 点对点发送消息</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String message, String sid)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;推送消息到窗口&quot;</span> + sid + <span class="hljs-string">&quot;，推送内容:&quot;</span> + message);        <span class="hljs-keyword">for</span> (WebSocketServer item : webSocketSet) &#123;            <span class="hljs-keyword">if</span>(item.sid.equals(sid))&#123;                item.sendMessage(message);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取在线人数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOnlineCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> onlineCount.get();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在线人数加一</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOnlineCount</span><span class="hljs-params">()</span> </span>&#123;        WebSocketServer.onlineCount.addAndGet(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在线人数减一</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subOnlineCount</span><span class="hljs-params">()</span> </span>&#123;        WebSocketServer.onlineCount.decrementAndGet();    &#125;&#125;</code></pre></div><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> socket; <span class="hljs-comment">// 创建一个socket</span>   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(WebSocket) == <span class="hljs-string">&quot;undefined&quot;</span>) &#123;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;您的浏览器不支持WebSocket&quot;</span>);   &#125;<span class="hljs-keyword">else</span>&#123;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;您的浏览器支持WebSocket&quot;</span>);       socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:8080/websocket/&quot;</span> + <span class="hljs-number">55</span>); <span class="hljs-comment">// 请求连接 注意一定是ws://+你的websocket服务端口</span>              <span class="hljs-comment">//客户端与服务端成功建立连接后的回调函数</span>       socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Socket 已打开&quot;</span>);           socket.send(<span class="hljs-string">&quot;这是来自客户端的消息&quot;</span> + location.href + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());       &#125;;              <span class="hljs-comment">//服务端发送消息后回调函数</span>       socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>&#123;           <span class="hljs-built_in">console</span>.log(msg.data);           <span class="hljs-comment">//发现消息进入 开始处理前端触发逻辑</span>           alert(msg.data)       &#125;;       <span class="hljs-comment">//关闭事件</span>       socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Socket已关闭&quot;</span>);       &#125;;       <span class="hljs-comment">//发生了错误事件</span>       socket.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;           alert(<span class="hljs-string">&quot;Socket发生了错误&quot;</span>);           <span class="hljs-comment">//此时可以尝试刷新页面</span>       &#125;       <span class="hljs-comment">//离开页面时，关闭socket</span>       <span class="hljs-comment">//jquery1.8中已经被废弃，3.0中已经移除</span>       <span class="hljs-comment">// $(window).unload(function()&#123;</span>       <span class="hljs-comment">//     socket.close();</span>       <span class="hljs-comment">//&#125;);</span>   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>SpringBoot</category>
      
      <category>整合案例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【JVM学习】-垃圾回收算法</title>
    <link href="/2021/02/01/%E3%80%90JVM%E5%AD%A6%E4%B9%A0%E3%80%91-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/01/%E3%80%90JVM%E5%AD%A6%E4%B9%A0%E3%80%91-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除算法（-Mark-Sweep）"><a href="#标记清除算法（-Mark-Sweep）" class="headerlink" title="标记清除算法（ Mark-Sweep）"></a>标记清除算法（ Mark-Sweep）</h2><blockquote><p> 最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段 回收被标记的对象所占用的空间。如图 </p></blockquote><p><img src="https://i.loli.net/2021/02/01/Phqaz2mZcF5pfvx.png" alt="标记清除法.png"></p><p>从图中我们就可以发现，该算法最大的问题是内存碎片化严重，这会导致后续可能发生大对象不能找到可利用空 间的问题。</p><h2 id="复制算法（copying）"><a href="#复制算法（copying）" class="headerlink" title="复制算法（copying）"></a>复制算法（copying）</h2><blockquote><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两 块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清 掉，如图</p></blockquote><p><img src="https://i.loli.net/2021/02/01/yjGk2NxMpL75vt3.png" alt="复制.png"></p><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一 半。且存活对象增多的话， Copying 算法的效率会大大降低。</p><h2 id="标记复制算法-Mark-Compact"><a href="#标记复制算法-Mark-Compact" class="headerlink" title="标记复制算法(Mark-Compact)"></a>标记复制算法(Mark-Compact)</h2><blockquote><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对 象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：</p></blockquote><p><img src="https://i.loli.net/2021/02/01/ywM7PkdFxVegGrt.png" alt="标记整理法.png"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为 不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代 (YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><p>单纯从 JVM 的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收 (GC) 的性能。更具体说，把堆划分为新生代和老年代有 2 个好处：简化了新对象的分配 (只在新生代分配内存), 可以更有效的清除不再需要的对象 (即死对象)(新生代和老年代使用不同的 GC 算法)</p><p>通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这 2 个特点，很明显 GC 会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC 可以快速标记回收” 死对象”，而不需要扫描整个 Heap 中的存活一段时间的” 老对象”。</p><p>SUN/Oracle 的 HotSpot JVM 又把新生代进一步划分为 3 个区域：一个相对大点的区域，称为” 伊甸园区 (Eden)”；两个相对小点的区域称为”From 幸存区 (survivor)” 和”To 幸存区 (survivor)”。按照规定，新对象会首先分配在 Eden 中 (如果新对象过大，会直接分配在老年代中)。在 GC 中，Eden 中的对象会被移动到 survivor 中，直至对象满足一定的年纪 (定义为熬过 GC 的次数), 会被移动到老年代。</p><h3 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h3><p>基于大多数新生对象都会在 GC 中被收回的假设。在 GC 前 To 幸存区 (survivor) 保持清空，对象保存在 Eden 和 From 幸存区 (survivor) 中，GC 运行时，Eden 中的幸存对象被复制到 To 幸存区 (survivor)。针对 From 幸存区 (survivor) 中的幸存对象，会考虑对象年龄，如果年龄没达到阀值 (tenuring threshold)，对象会被复制到 To 幸存区 (survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和 From 幸存区中只保存死对象，可以视为清空。如果在复制过程中 To 幸存区被填满了，剩余的对象会被复制到老年代中。最后 From 幸存区和 To 幸存区会调换下名字，在下次 GC 时，To 幸存区会成为 From 幸存区。如下图：</p><p><img src="https://i.loli.net/2021/02/01/TcKz4fGmUVkvbR6.png" alt="young.png"></p><h3 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h3><p>老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>垃圾回收算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【面试题】JVM专题</title>
    <link href="/2021/02/01/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JVM%E4%B8%93%E9%A2%98/"/>
    <url>/2021/02/01/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91JVM%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="描述一下-JVM-加载-class-文件的原理机制"><a href="#描述一下-JVM-加载-class-文件的原理机制" class="headerlink" title="描述一下 JVM 加载 class 文件的原理机制"></a>描述一下 JVM 加载 class 文件的原理机制</h2><p>​         JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p><p>​        由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类 的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后 产生与所加载类对应 的 Class 对象。 加载完成后，Class 对象还不完整（<strong>只是将Class描述信息加载进内存，并未针对每个Class分配内存</strong>），所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段 包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三 个步骤。最后 JVM 对 类进行初始化，包括：</p><ol><li><p>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；</p></li><li><p>如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、 系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。</p></li></ol><p>​         从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台 的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会 向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类 加载器的说明：</p><ol><li>Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；</li><li>Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； </li><li>System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 ，java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加 载器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>JVM专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试题</tag>
      
      <tag>JVM专题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【面试题】海量数据处理问题</title>
    <link href="/2021/01/31/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/31/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="海量数据中位数"><a href="#海量数据中位数" class="headerlink" title="海量数据中位数"></a>海量数据中位数</h2><p><strong>问题:</strong>   在一个文件中有 10G 个整数，乱序排列，要求找出中位数。只写出思路即可。（文件内存储的是32位无符号整数，占4个字节）</p><h3 id="内存无限制"><a href="#内存无限制" class="headerlink" title="内存无限制"></a>内存无限制</h3><blockquote><p><strong>小顶堆</strong>：每个结点的值都<strong>大于</strong>或<strong>等于</strong>其左右孩子结点的值</p><p>可以维护一个<strong>小顶堆</strong>。堆的大小由文件中整数的<strong>个数N决定</strong>，<strong>堆大小为N/2(向上取整)**，然后读取文件，每次读取到一个数字，将其放进</strong>最大堆<strong>，文件读完后</strong>小顶堆的根节点**即为中位数。</p></blockquote><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><ol><li><p>计算10G大小的文件中有多少个整数，<code>10*2^30B/4B=10*2^28 </code> 一共有<code>10*2^28</code>个数字</p></li><li><p>全量读取文件，将读到的数字放入堆中。</p></li><li><p>读完文件，返回大顶堆的根节点的存储的数。</p></li></ol><h3 id="内存有限制"><a href="#内存有限制" class="headerlink" title="内存有限制"></a>内存有限制</h3><blockquote><p>基于桶排序的思想解决。将10G大小的文件，根据</p></blockquote><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><ol><li><p>读一遍10G个整数，把整数映射到256M个区段中，用一个64位无符号整数给每个相应区段记数。<br>说明：整数范围是0 - 2^32 - 1，一共有4G种取值，映射到256M个区段，则每个区段有16（4G/256M = 16）种值，每16个值算一段， 0～15是第1段，16～31是第2段，……2^32-16 ～2^32-1是第256M段。一个64位无符号整数最大值是0～8G-1，这里先不考虑溢出的情况。总共占用内存256M×8B=2GB。</p></li><li><p>从前到后对每一段的计数累加，当累加的和超过5G时停止，找出这个区段（即累加停止时达到的区段，也是中位数所在的区段）的数值范围，设为[a，a+15]，同时记录累加到前一个区段的总数，设为m。然后，释放除这个区段占用的内存。</p></li><li><p>再读一遍10G个整数，把在[a，a+15]内的每个值计数，即有16个计数。</p></li><li><p>对新的计数依次累加，每次的和设为n，当m+n的值超过5G时停止，此时的这个计数所对应的数就是中位数。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>算法</category>
      
      <category>海量数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试题</tag>
      
      <tag>海量数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty【HelloWorld】</title>
    <link href="/2021/01/26/Netty%E3%80%90HelloWorld%E3%80%91/"/>
    <url>/2021/01/26/Netty%E3%80%90HelloWorld%E3%80%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码分析【IOC容器】</title>
    <link href="/2021/01/26/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90IOC%E5%AE%B9%E5%99%A8%E3%80%91/"/>
    <url>/2021/01/26/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90IOC%E5%AE%B9%E5%99%A8%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1、创建一个Maven项目"><a href="#1、创建一个Maven项目" class="headerlink" title="1、创建一个Maven项目"></a>1、创建一个Maven项目</h3><h3 id="2、在pom-xml文件中引入下方依赖"><a href="#2、在pom-xml文件中引入下方依赖" class="headerlink" title="2、在pom.xml文件中引入下方依赖"></a>2、在pom.xml文件中引入下方依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><blockquote><p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p></blockquote><h3 id="3、如何快速启动一个容器："><a href="#3、如何快速启动一个容器：" class="headerlink" title="3、如何快速启动一个容器："></a>3、如何快速启动一个容器：</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;classpath:applicationfile.xml&quot;</span>);&#125;</code></pre></div><h3 id="4、ApplicationContext-继承结构"><a href="#4、ApplicationContext-继承结构" class="headerlink" title="4、ApplicationContext 继承结构"></a>4、ApplicationContext 继承结构</h3><p><code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/1.png" alt="1"></p><p>我们可以看到，ClassPathXmlApplicationContext 距离 ApplicationContext 接口有好几层，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类来构建 ApplicationContext 。</p><p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式。</p><h3 id="5、ApplicationContext-Demo"><a href="#5、ApplicationContext-Demo" class="headerlink" title="5、ApplicationContext Demo"></a>5、ApplicationContext Demo</h3><p>本文选用 ClassPathXmlApplicationContext 进行分析。</p><p>首先，定义一个接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MessageService</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>定义接口实现类：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;    &#125;&#125;</code></pre></div><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span> <span class="hljs-attr">default-autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>这样，我们就可以跑起来了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 用我们的配置文件来启动一个 ApplicationContext</span>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;classpath:application.xml&quot;</span>);        System.out.println(<span class="hljs-string">&quot;context 启动成功&quot;</span>);        <span class="hljs-comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span>        MessageService messageService = context.getBean(MessageService.class);        <span class="hljs-comment">// 这句将输出: hello world</span>        System.out.println(messageService.getMessage());    &#125;&#125;</code></pre></div><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/2.png" alt="2"></p><p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p><ol><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li><li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li></ol><p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p><p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractXmlApplicationContext</span> </span>&#123;  <span class="hljs-keyword">private</span> Resource[] configResources;    <span class="hljs-comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(ApplicationContext parent)</span> </span>&#123;    <span class="hljs-keyword">super</span>(parent);  &#125;  ...  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(String[] configLocations, <span class="hljs-keyword">boolean</span> refresh, ApplicationContext parent)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">super</span>(parent);    <span class="hljs-comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span>    setConfigLocations(configLocations);    <span class="hljs-keyword">if</span> (refresh) &#123;      refresh(); <span class="hljs-comment">// 核心方法</span>    &#125;  &#125;    ...&#125;</code></pre></div><p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;   <span class="hljs-comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;      <span class="hljs-comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span>      prepareRefresh();           <span class="hljs-comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span>      <span class="hljs-comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span>      <span class="hljs-comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span>      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      <span class="hljs-comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span>      <span class="hljs-comment">// 这块待会会展开说</span>      prepareBeanFactory(beanFactory);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span>         <span class="hljs-comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span>                 <span class="hljs-comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span>         <span class="hljs-comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span>         postProcessBeanFactory(beanFactory);         <span class="hljs-comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span>         invokeBeanFactoryPostProcessors(beanFactory);         <span class="hljs-comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span>         <span class="hljs-comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span>         <span class="hljs-comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span>         registerBeanPostProcessors(beanFactory);         <span class="hljs-comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span>         initMessageSource();         <span class="hljs-comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span>         initApplicationEventMulticaster();         <span class="hljs-comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span>         <span class="hljs-comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span>         onRefresh();         <span class="hljs-comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span>         registerListeners();         <span class="hljs-comment">// 重点，重点，重点</span>         <span class="hljs-comment">// 初始化所有的 singleton beans</span>         <span class="hljs-comment">//（lazy-init 的除外）</span>         finishBeanFactoryInitialization(beanFactory);         <span class="hljs-comment">// 最后，广播事件，ApplicationContext 初始化完成</span>         finishRefresh();      &#125;      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;         <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;            logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +                  <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);         &#125;         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>         <span class="hljs-comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span>         destroyBeans();         <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span>         cancelRefresh(ex);         <span class="hljs-comment">// 把异常往外抛</span>         <span class="hljs-keyword">throw</span> ex;      &#125;      <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span>         <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>         resetCommonCaches();      &#125;   &#125;&#125;</code></pre></div><p>下面，我们开始一步步来肢解这个 refresh() 方法。</p><h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareRefresh</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 记录启动时间，</span>   <span class="hljs-comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span>   <span class="hljs-keyword">this</span>.startupDate = System.currentTimeMillis();   <span class="hljs-keyword">this</span>.closed.set(<span class="hljs-keyword">false</span>);   <span class="hljs-keyword">this</span>.active.set(<span class="hljs-keyword">true</span>);   <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;      logger.info(<span class="hljs-string">&quot;Refreshing &quot;</span> + <span class="hljs-keyword">this</span>);   &#125;   <span class="hljs-comment">// Initialize any placeholder property sources in the context environment</span>   initPropertySources();   <span class="hljs-comment">// 校验 xml 配置文件</span>   getEnvironment().validateRequiredProperties();   <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();&#125;</code></pre></div><h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p><p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p><p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p><p>// AbstractApplicationContext.java</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span>   refreshBeanFactory();     <span class="hljs-comment">// 返回刚刚创建的 BeanFactory</span>   ConfigurableListableBeanFactory beanFactory = getBeanFactory();   <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;      logger.debug(<span class="hljs-string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="hljs-string">&quot;: &quot;</span> + beanFactory);   &#125;   <span class="hljs-keyword">return</span> beanFactory;&#125;</code></pre></div><p>// AbstractRefreshableApplicationContext.java 120</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;   <span class="hljs-comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span>   <span class="hljs-comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span>   <span class="hljs-comment">// ApplicationContext 是否有 BeanFactory</span>   <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;      destroyBeans();      closeBeanFactory();   &#125;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span>      DefaultListableBeanFactory beanFactory = createBeanFactory();      <span class="hljs-comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span>      beanFactory.setSerializationId(getId());           <span class="hljs-comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span>      <span class="hljs-comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span>      customizeBeanFactory(beanFactory);           <span class="hljs-comment">// 加载 Bean 到 BeanFactory 中</span>      loadBeanDefinitions(beanFactory);      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanFactoryMonitor) &#123;         <span class="hljs-keyword">this</span>.beanFactory = beanFactory;      &#125;   &#125;   <span class="hljs-keyword">catch</span> (IOException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);   &#125;&#125;</code></pre></div><blockquote><p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p></blockquote><p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p><p><img src="https://www.javadoop.com/blogimages/spring-context/3.png" alt="3"></p><p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p><p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p><p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p></blockquote><p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p><p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p><p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p><blockquote><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p></blockquote><h4 id="BeanDefinition-接口定义"><a href="#BeanDefinition-接口定义" class="headerlink" title="BeanDefinition 接口定义"></a>BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;   <span class="hljs-comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span>   <span class="hljs-comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span>   <span class="hljs-comment">// 不过，它们属于基于 web 的扩展。</span>   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;   <span class="hljs-comment">// 比较不重要，直接跳过吧</span>   <span class="hljs-keyword">int</span> ROLE_APPLICATION = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> ROLE_SUPPORT = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> ROLE_INFRASTRUCTURE = <span class="hljs-number">2</span>;   <span class="hljs-comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span>   <span class="hljs-comment">// 一句话就是：继承父 Bean 的配置信息而已</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(String parentName)</span></span>;     <span class="hljs-comment">// 获取父 Bean</span>   <span class="hljs-function">String <span class="hljs-title">getParentName</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(String beanClassName)</span></span>;      <span class="hljs-comment">// 获取 Bean 的类名称</span>   <span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 设置 bean 的 scope</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(String scope)</span></span>;   <span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 设置是否懒加载</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;      <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span>   <span class="hljs-comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(String... dependsOn)</span></span>;   <span class="hljs-comment">// 返回该 Bean 的所有依赖</span>   String[] getDependsOn();   <span class="hljs-comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span>   <span class="hljs-comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autowireCandidate)</span></span>;   <span class="hljs-comment">// 该 Bean 是否可以注入到其他 Bean 中</span>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;   <span class="hljs-comment">// 是否是 primary 的</span>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span>   <span class="hljs-comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryBeanName</span><span class="hljs-params">(String factoryBeanName)</span></span>;   <span class="hljs-comment">// 获取工厂名称</span>   <span class="hljs-function">String <span class="hljs-title">getFactoryBeanName</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 指定工厂类中的 工厂方法名称</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryMethodName</span><span class="hljs-params">(String factoryMethodName)</span></span>;   <span class="hljs-comment">// 获取工厂类中的 工厂方法名称</span>   <span class="hljs-function">String <span class="hljs-title">getFactoryMethodName</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 构造器参数</span>   <span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span>   <span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 是否 singleton</span>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 是否 prototype</span>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span>   <span class="hljs-comment">// 常用于作为 父bean 用于继承，其实也很少用......</span>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRole</span><span class="hljs-params">()</span></span>;   <span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;   <span class="hljs-function">String <span class="hljs-title">getResourceDescription</span><span class="hljs-params">()</span></span>;   <span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><blockquote><p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p><p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p><div class="hljs code-wrapper"><pre><code class="hljs java">customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory);</code></pre></div><p>虽然只有两个方法，但路还很长啊。。。</p><h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customizeBeanFactory</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 是否允许 Bean 定义覆盖</span>      beanFactory.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);   &#125;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.allowCircularReferences != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 是否允许 Bean 间的循环依赖</span>      beanFactory.setAllowCircularReferences(<span class="hljs-keyword">this</span>.allowCircularReferences);   &#125;&#125;</code></pre></div><p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p><p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p><p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p><p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p><h4 id="加载-Bean-loadBeanDefinitions"><a href="#加载-Bean-loadBeanDefinitions" class="headerlink" title="加载 Bean: loadBeanDefinitions"></a>加载 Bean: loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><p>// AbstractXmlApplicationContext.java 80</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;   <span class="hljs-comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span>   XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);   <span class="hljs-comment">// Configure the bean definition reader with this context&#x27;s</span>   <span class="hljs-comment">// resource loading environment.</span>   beanDefinitionReader.setEnvironment(<span class="hljs-keyword">this</span>.getEnvironment());   beanDefinitionReader.setResourceLoader(<span class="hljs-keyword">this</span>);   beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> ResourceEntityResolver(<span class="hljs-keyword">this</span>));   <span class="hljs-comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span>   <span class="hljs-comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span>   initBeanDefinitionReader(beanDefinitionReader);   <span class="hljs-comment">// 重点来了，继续往下</span>   loadBeanDefinitions(beanDefinitionReader);&#125;</code></pre></div><p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p><p>// AbstractXmlApplicationContext.java 120</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;   Resource[] configResources = getConfigResources();   <span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 往下看</span>      reader.loadBeanDefinitions(configResources);   &#125;   String[] configLocations = getConfigLocations();   <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 2</span>      reader.loadBeanDefinitions(configLocations);   &#125;&#125;<span class="hljs-comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   Assert.notNull(resources, <span class="hljs-string">&quot;Resource array must not be null&quot;</span>);   <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span>   <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;      <span class="hljs-comment">// 继续往下看</span>      counter += loadBeanDefinitions(resource);   &#125;   <span class="hljs-comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span>   <span class="hljs-keyword">return</span> counter;&#125;<span class="hljs-comment">// XmlBeanDefinitionReader 303</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));&#125;<span class="hljs-comment">// XmlBeanDefinitionReader 314</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   Assert.notNull(encodedResource, <span class="hljs-string">&quot;EncodedResource must not be null&quot;</span>);   <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;      logger.info(<span class="hljs-string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());   &#125;   <span class="hljs-comment">// 用一个 ThreadLocal 来存放配置文件资源</span>   Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();   <span class="hljs-keyword">if</span> (currentResources == <span class="hljs-keyword">null</span>) &#123;      currentResources = <span class="hljs-keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="hljs-number">4</span>);      <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);   &#125;   <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(            <span class="hljs-string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="hljs-string">&quot; - check your import definitions!&quot;</span>);   &#125;   <span class="hljs-keyword">try</span> &#123;      InputStream inputStream = encodedResource.getResource().getInputStream();      <span class="hljs-keyword">try</span> &#123;         InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);         <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;            inputSource.setEncoding(encodedResource.getEncoding());         &#125;         <span class="hljs-comment">// 核心部分是这里，往下面看</span>         <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());      &#125;      <span class="hljs-keyword">finally</span> &#123;         inputStream.close();      &#125;   &#125;   <span class="hljs-keyword">catch</span> (IOException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(            <span class="hljs-string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);   &#125;   <span class="hljs-keyword">finally</span> &#123;      currentResources.remove(encodedResource);      <span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;         <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();      &#125;   &#125;&#125;<span class="hljs-comment">// 还在这个文件中，第 388 行</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span>      Document doc = doLoadDocument(inputSource, resource);      <span class="hljs-comment">// 继续</span>      <span class="hljs-keyword">return</span> registerBeanDefinitions(doc, resource);   &#125;   <span class="hljs-keyword">catch</span> (...&#125;<span class="hljs-comment">// 还在这个文件中，第 505 行</span><span class="hljs-comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();   <span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();   <span class="hljs-comment">// 这里</span>   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));   <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;&#125;<span class="hljs-comment">// DefaultBeanDefinitionDocumentReader 90</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;   <span class="hljs-keyword">this</span>.readerContext = readerContext;   logger.debug(<span class="hljs-string">&quot;Loading bean definitions&quot;</span>);   Element root = doc.getDocumentElement();   <span class="hljs-comment">// 从 xml 根节点开始解析文件</span>   doRegisterBeanDefinitions(root);&#125;</code></pre></div><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p><h5 id="doRegisterBeanDefinitions："><a href="#doRegisterBeanDefinitions：" class="headerlink" title="doRegisterBeanDefinitions："></a>doRegisterBeanDefinitions：</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DefaultBeanDefinitionDocumentReader 116</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;   <span class="hljs-comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span>   <span class="hljs-comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span>   <span class="hljs-comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span>   BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;   <span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;      <span class="hljs-comment">// 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，</span>      <span class="hljs-comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span>      <span class="hljs-comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span>      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);      <span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);         <span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;            <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;               logger.info(<span class="hljs-string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +                     <span class="hljs-string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());            &#125;            <span class="hljs-keyword">return</span>;         &#125;      &#125;   &#125;   preProcessXml(root); <span class="hljs-comment">// 钩子</span>   <span class="hljs-comment">// 往下看</span>   parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);   postProcessXml(root); <span class="hljs-comment">// 钩子</span>   <span class="hljs-keyword">this</span>.delegate = parent;&#125;</code></pre></div><p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p><p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span><span class="hljs-comment">// 其他的属于 custom 的</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;   <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;      NodeList nl = root.getChildNodes();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;         Node node = nl.item(i);         <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;            Element ele = (Element) node;            <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;               <span class="hljs-comment">// 解析 default namespace 下面的几个元素</span>               parseDefaultElement(ele, delegate);            &#125;            <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 解析其他 namespace 的元素</span>               delegate.parseCustomElement(ele);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-keyword">else</span> &#123;      delegate.parseCustomElement(root);   &#125;&#125;</code></pre></div><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p><p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p><blockquote><p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.springframework.org<span class="hljs-regexp">/schema/</span>beans</code></pre></div><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><span class="hljs-tag"><span class="hljs-string">         http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">default-autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span></code></pre></div><p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p><p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p><p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans </span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc   </span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span><span class="hljs-tag"><span class="hljs-string">    &quot;</span></span><span class="hljs-tag">   <span class="hljs-attr">default-autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span></code></pre></div><p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p></blockquote><p>回过神来，看看处理 default 标签的方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;   <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;      <span class="hljs-comment">// 处理 &lt;import /&gt; 标签</span>      importBeanDefinitionResource(ele);   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;      <span class="hljs-comment">// 处理 &lt;alias /&gt; 标签定义</span>      <span class="hljs-comment">// &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</span>      processAliasRegistration(ele);   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;      <span class="hljs-comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span>      processBeanDefinition(ele, delegate);   &#125;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;      <span class="hljs-comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span>      doRegisterBeanDefinitions(ele);   &#125;&#125;</code></pre></div><p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p><h5 id="processBeanDefinition-解析-bean-标签"><a href="#processBeanDefinition-解析-bean-标签" class="headerlink" title="processBeanDefinition 解析 bean 标签"></a>processBeanDefinition 解析 bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p><p>// DefaultBeanDefinitionDocumentReader 298</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;   <span class="hljs-comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span>   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);     <span class="hljs-comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span>     <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// Register the final decorated instance.</span>         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());      &#125;      <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;         getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +               bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);      &#125;      <span class="hljs-comment">// Send registration event.</span>      getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));   &#125;&#125;</code></pre></div><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p><p>简单地说就是像下面这样子：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name1, name2, name3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.ExampleBean&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;cleanup&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7500000&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;years&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7500000&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;7500000&quot;</span>/&gt;</span>      <span class="hljs-comment">&lt;!-- property 的几种情况 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanOne&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanTwo&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;integerProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele)</span> </span>&#123;    <span class="hljs-keyword">return</span> parseBeanDefinitionElement(ele, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;   String id = ele.getAttribute(ID_ATTRIBUTE);   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);   List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();         <span class="hljs-comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span>   <span class="hljs-comment">// 当然，如果你不定义 name 属性的话，就是空的了</span>   <span class="hljs-comment">// 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span>   <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);      aliases.addAll(Arrays.asList(nameArr));   &#125;   String beanName = id;   <span class="hljs-comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span>   <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;      beanName = aliases.remove(<span class="hljs-number">0</span>);      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;         logger.debug(<span class="hljs-string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +               <span class="hljs-string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="hljs-string">&quot; as aliases&quot;</span>);      &#125;   &#125;   <span class="hljs-keyword">if</span> (containingBean == <span class="hljs-keyword">null</span>) &#123;      checkNameUniqueness(beanName, aliases, ele);   &#125;     <span class="hljs-comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span>   <span class="hljs-comment">// 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span>   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);      <span class="hljs-comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span>   <span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span>      <span class="hljs-comment">// 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span>      <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;         <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 按照我们的思路，这里 containingBean 是 null 的</span>               beanName = BeanDefinitionReaderUtils.generateBeanName(                     beanDefinition, <span class="hljs-keyword">this</span>.readerContext.getRegistry(), <span class="hljs-keyword">true</span>);            &#125;            <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span>               <span class="hljs-comment">//   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span>               <span class="hljs-comment">//   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span>                             beanName = <span class="hljs-keyword">this</span>.readerContext.generateBeanName(beanDefinition);                              String beanClassName = beanDefinition.getBeanClassName();               <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-keyword">null</span> &amp;&amp;                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;                     !<span class="hljs-keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;                  <span class="hljs-comment">// 把 beanClassName 设置为 Bean 的别名</span>                  aliases.add(beanClassName);               &#125;            &#125;            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;               logger.debug(<span class="hljs-string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +                     <span class="hljs-string">&quot;using generated bean name [&quot;</span> + beanName + <span class="hljs-string">&quot;]&quot;</span>);            &#125;         &#125;         <span class="hljs-keyword">catch</span> (Exception ex) &#123;            error(ex.getMessage(), ele);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;      &#125;      String[] aliasesArray = StringUtils.toStringArray(aliases);      <span class="hljs-comment">// 返回 BeanDefinitionHolder</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;   <span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));   String className = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();   &#125;   <span class="hljs-keyword">try</span> &#123;      String parent = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;         parent = ele.getAttribute(PARENT_ATTRIBUTE);      &#125;      <span class="hljs-comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span>      AbstractBeanDefinition bd = createBeanDefinition(className, parent);      <span class="hljs-comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span>      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));          <span class="hljs-comment">/**</span><span class="hljs-comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span><span class="hljs-comment">       * 解析出来以后的信息都放到 bd 的属性中</span><span class="hljs-comment">       */</span>           <span class="hljs-comment">// 解析 &lt;meta /&gt;</span>      parseMetaElements(ele, bd);      <span class="hljs-comment">// 解析 &lt;lookup-method /&gt;</span>      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());      <span class="hljs-comment">// 解析 &lt;replaced-method /&gt;</span>      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());    <span class="hljs-comment">// 解析 &lt;constructor-arg /&gt;</span>      parseConstructorArgElements(ele, bd);      <span class="hljs-comment">// 解析 &lt;property /&gt;</span>      parsePropertyElements(ele, bd);      <span class="hljs-comment">// 解析 &lt;qualifier /&gt;</span>      parseQualifierElements(ele, bd);      bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());      bd.setSource(extractSource(ele));      <span class="hljs-keyword">return</span> bd;   &#125;   <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;      error(<span class="hljs-string">&quot;Bean class [&quot;</span> + className + <span class="hljs-string">&quot;] not found&quot;</span>, ele, ex);   &#125;   <span class="hljs-keyword">catch</span> (NoClassDefFoundError err) &#123;      error(<span class="hljs-string">&quot;Class that bean class [&quot;</span> + className + <span class="hljs-string">&quot;] depends on not found&quot;</span>, ele, err);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      error(<span class="hljs-string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);   &#125;   <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">this</span>.parseState.pop();   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;   <span class="hljs-comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span>   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);   <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span>      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 我们把这步叫做 注册Bean 吧</span>         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());      &#125;      <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;         getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +               bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);      &#125;      <span class="hljs-comment">// 注册完成后，发送事件，本文不展开说这个</span>      getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));   &#125;&#125;</code></pre></div><p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanMetadataElement</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinition beanDefinition;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String beanName;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] aliases;...</code></pre></div><p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p><p>下面，我们开始说说注册 Bean 吧。</p><h5 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h5><p>// BeanDefinitionReaderUtils 143</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   String beanName = definitionHolder.getBeanName();   <span class="hljs-comment">// 注册这个 Bean</span>   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());   <span class="hljs-comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span>   String[] aliases = definitionHolder.getAliases();   <span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (String alias : aliases) &#123;         <span class="hljs-comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span>         <span class="hljs-comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span>         registry.registerAlias(beanName, alias);      &#125;   &#125;&#125;</code></pre></div><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 793</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;   Assert.hasText(beanName, <span class="hljs-string">&quot;Bean name must not be empty&quot;</span>);   Assert.notNull(beanDefinition, <span class="hljs-string">&quot;BeanDefinition must not be null&quot;</span>);   <span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;      <span class="hljs-keyword">try</span> &#123;         ((AbstractBeanDefinition) beanDefinition).validate();      &#125;      <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(...);      &#125;   &#125;   <span class="hljs-comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span>   BeanDefinition oldBeanDefinition;     <span class="hljs-comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span>   oldBeanDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);     <span class="hljs-comment">// 处理重复名称的 Bean 定义的情况</span>   <span class="hljs-keyword">if</span> (oldBeanDefinition != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;         <span class="hljs-comment">// 如果不允许覆盖的话，抛异常</span>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription()...      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;         <span class="hljs-comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span>      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;         <span class="hljs-comment">// log...用新的 Bean 覆盖旧的 Bean</span>      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span>      &#125;      <span class="hljs-comment">// 覆盖</span>      <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 判断是否已经有其他的 Bean 开始初始化了.</span>      <span class="hljs-comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span>      <span class="hljs-comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span>      <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;         <span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;            <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);            List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);            updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);            updatedDefinitions.add(beanName);            <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;               Set&lt;String&gt; updatedSingletons = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="hljs-keyword">this</span>.manualSingletonNames);               updatedSingletons.remove(beanName);               <span class="hljs-keyword">this</span>.manualSingletonNames = updatedSingletons;            &#125;         &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 最正常的应该是进到这个分支。</span>                 <span class="hljs-comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span>         <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);         <span class="hljs-comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span>         <span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);         <span class="hljs-comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span>         <span class="hljs-comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span>         <span class="hljs-comment">// 手动指的是通过调用以下方法注册的 bean ：</span>         <span class="hljs-comment">//     registerSingleton(String beanName, Object singletonObject)</span>         <span class="hljs-comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span>         <span class="hljs-comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span>         <span class="hljs-keyword">this</span>.manualSingletonNames.remove(beanName);      &#125;      <span class="hljs-comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span>      <span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-keyword">if</span> (oldBeanDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) &#123;      resetBeanDefinition(beanName);   &#125;&#125;</code></pre></div><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>——— 分割线 ———</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p><p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;   <span class="hljs-comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;      <span class="hljs-comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span>      prepareRefresh();           <span class="hljs-comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span>      <span class="hljs-comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span>      <span class="hljs-comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span>      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      <span class="hljs-comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span>      <span class="hljs-comment">// 这块待会会展开说</span>      prepareBeanFactory(beanFactory);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span>         <span class="hljs-comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span>                 <span class="hljs-comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span>         <span class="hljs-comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span>         postProcessBeanFactory(beanFactory);         <span class="hljs-comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span>         invokeBeanFactoryPostProcessors(beanFactory);                                      <span class="hljs-comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span>         <span class="hljs-comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span>         <span class="hljs-comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span>         registerBeanPostProcessors(beanFactory);         <span class="hljs-comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span>         initMessageSource();         <span class="hljs-comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span>         initApplicationEventMulticaster();         <span class="hljs-comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span>         <span class="hljs-comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span>         onRefresh();         <span class="hljs-comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span>         registerListeners();         <span class="hljs-comment">// 重点，重点，重点</span>         <span class="hljs-comment">// 初始化所有的 singleton beans</span>         <span class="hljs-comment">//（lazy-init 的除外）</span>         finishBeanFactoryInitialization(beanFactory);         <span class="hljs-comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span>         finishRefresh();      &#125;      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;         <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;            logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +                  <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);         &#125;         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>         <span class="hljs-comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span>         destroyBeans();         <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span>         cancelRefresh(ex);         <span class="hljs-comment">// 把异常往外抛</span>         <span class="hljs-keyword">throw</span> ex;      &#125;      <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span>         <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>         resetCommonCaches();      &#125;   &#125;&#125;</code></pre></div><h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Configure the factory&#x27;s standard context characteristics,</span><span class="hljs-comment"> * such as the context&#x27;s ClassLoader and post-processors.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanFactory the BeanFactory to configure</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;   <span class="hljs-comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span>   <span class="hljs-comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span>   beanFactory.setBeanClassLoader(getClassLoader());       <span class="hljs-comment">// 设置 BeanExpressionResolver</span>   beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));   <span class="hljs-comment">// </span>   beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> ResourceEditorRegistrar(<span class="hljs-keyword">this</span>, getEnvironment()));   <span class="hljs-comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span>   <span class="hljs-comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span>   <span class="hljs-comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span>   <span class="hljs-comment">// 注意：它不仅仅回调 ApplicationContextAware，</span>   <span class="hljs-comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span>   beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationContextAwareProcessor(<span class="hljs-keyword">this</span>));     <span class="hljs-comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span>   <span class="hljs-comment">// Spring 会通过其他方式来处理这些依赖。</span>   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><span class="hljs-comment">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span><span class="hljs-comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><span class="hljs-comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span><span class="hljs-comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><span class="hljs-comment">    */</span>   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-keyword">this</span>);   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-keyword">this</span>);   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-keyword">this</span>);   <span class="hljs-comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span>   <span class="hljs-comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span>   beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(<span class="hljs-keyword">this</span>));   <span class="hljs-comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span>   <span class="hljs-comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span>   <span class="hljs-comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span>   <span class="hljs-keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;      beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));      <span class="hljs-comment">// Set a temporary ClassLoader for type matching.</span>      beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span><span class="hljs-comment">    * 我们也可以选择覆盖</span><span class="hljs-comment">    */</span>     <span class="hljs-comment">// 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span>   <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());   &#125;   <span class="hljs-comment">// 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span>   <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());   &#125;   <span class="hljs-comment">// 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span>   <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());   &#125;&#125;</code></pre></div><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p><h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 初始化剩余的 singleton beans</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;   <span class="hljs-comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span>   <span class="hljs-comment">// 什么，看代码这里没有初始化 Bean 啊！</span>   <span class="hljs-comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span>   <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;      beanFactory.setConversionService(            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));   &#125;   <span class="hljs-comment">// Register a default embedded value resolver if no bean post-processor</span>   <span class="hljs-comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span>   <span class="hljs-comment">// at this point, primarily for resolution in annotation attribute values.</span>   <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;      beanFactory.addEmbeddedValueResolver(<span class="hljs-keyword">new</span> StringValueResolver() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveStringValue</span><span class="hljs-params">(String strVal)</span> </span>&#123;            <span class="hljs-keyword">return</span> getEnvironment().resolvePlaceholders(strVal);         &#125;      &#125;);   &#125;   <span class="hljs-comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span>   <span class="hljs-comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span>   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);   <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;      getBean(weaverAwareName);   &#125;   <span class="hljs-comment">// Stop using the temporary ClassLoader for type matching.</span>   beanFactory.setTempClassLoader(<span class="hljs-keyword">null</span>);   <span class="hljs-comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span>   <span class="hljs-comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span>   beanFactory.freezeConfiguration();   <span class="hljs-comment">// 开始初始化</span>   beanFactory.preInstantiateSingletons();&#125;</code></pre></div><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;      <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-keyword">this</span>);   &#125;   <span class="hljs-comment">// this.beanDefinitionNames 保存了所有的 beanNames</span>   List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);   <span class="hljs-comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span>   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;           <span class="hljs-comment">// 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，</span>      <span class="hljs-comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下</span>      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);           <span class="hljs-comment">// 非抽象、非懒加载的 singletons。如果配置了 &#x27;abstract = true&#x27;，那是不需要初始化的</span>      <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;         <span class="hljs-comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span>         <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;            <span class="hljs-comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span>            <span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);            <span class="hljs-comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span>            <span class="hljs-keyword">boolean</span> isEagerInit;            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;               isEagerInit = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;                  <span class="hljs-meta">@Override</span>                  <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                     <span class="hljs-keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();                  &#125;               &#125;, getAccessControlContext());            &#125;            <span class="hljs-keyword">else</span> &#123;               isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());            &#125;            <span class="hljs-keyword">if</span> (isEagerInit) &#123;                              getBean(beanName);            &#125;         &#125;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span>            getBean(beanName);         &#125;      &#125;   &#125;   <span class="hljs-comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span>   <span class="hljs-comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span>   <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;      Object singletonInstance = getSingleton(beanName);      <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;         <span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;         <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;            AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;               <span class="hljs-meta">@Override</span>               <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                  smartSingleton.afterSingletonsInstantiated();                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;               &#125;            &#125;, getAccessControlContext());         &#125;         <span class="hljs-keyword">else</span> &#123;            smartSingleton.afterSingletonsInstantiated();         &#125;      &#125;   &#125;&#125;</code></pre></div><p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p><h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p><p>// AbstractBeanFactory 196</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;   <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><span class="hljs-comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">final</span> String name, <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType, <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeansException </span>&#123;   <span class="hljs-comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span>   <span class="hljs-comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span>   <span class="hljs-keyword">final</span> String beanName = transformedBeanName(name);     <span class="hljs-comment">// 注意跟着这个，这个是返回值</span>   Object bean;    <span class="hljs-comment">// 检查下是不是已经创建过了</span>   Object sharedInstance = getSingleton(beanName);     <span class="hljs-comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span>   <span class="hljs-comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span>   <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;         <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;            logger.debug(<span class="hljs-string">&quot;...&quot;</span>);         &#125;         <span class="hljs-keyword">else</span> &#123;            logger.debug(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);         &#125;      &#125;      <span class="hljs-comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span>      <span class="hljs-comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span>      <span class="hljs-comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span>      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;         <span class="hljs-comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span>         <span class="hljs-comment">// 往往是因为陷入了循环引用</span>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);      &#125;      <span class="hljs-comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span>      BeanFactory parentBeanFactory = getParentBeanFactory();      <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;         <span class="hljs-comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span>         String nameToLookup = originalBeanName(name);         <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 返回父容器的查询结果</span>            <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);         &#125;         <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span>            <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);         &#125;      &#125;      <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;         <span class="hljs-comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span>         markBeanAsCreated(beanName);      &#125;      <span class="hljs-comment">/*</span><span class="hljs-comment">       * 稍稍总结一下：</span><span class="hljs-comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><span class="hljs-comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);         checkMergedBeanDefinition(mbd, beanName, args);         <span class="hljs-comment">// 先初始化依赖的所有 Bean，这个很好理解。</span>         <span class="hljs-comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span>         String[] dependsOn = mbd.getDependsOn();         <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;               <span class="hljs-comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span>               <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);               &#125;               <span class="hljs-comment">// 注册一下依赖关系</span>               registerDependentBean(dep, beanName);               <span class="hljs-comment">// 先初始化被依赖项</span>               getBean(dep);            &#125;         &#125;         <span class="hljs-comment">// 如果是 singleton scope 的，创建 singleton 的实例</span>         <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;            sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;               <span class="hljs-meta">@Override</span>               <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;                  <span class="hljs-keyword">try</span> &#123;                     <span class="hljs-comment">// 执行创建 Bean，详情后面再说</span>                     <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);                  &#125;                  <span class="hljs-keyword">catch</span> (BeansException ex) &#123;                     destroySingleton(beanName);                     <span class="hljs-keyword">throw</span> ex;                  &#125;               &#125;            &#125;);            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);         &#125;         <span class="hljs-comment">// 如果是 prototype scope 的，创建 prototype 的实例</span>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;            <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span>            Object prototypeInstance = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;               beforePrototypeCreation(beanName);               <span class="hljs-comment">// 执行创建 Bean</span>               prototypeInstance = createBean(beanName, mbd, args);            &#125;            <span class="hljs-keyword">finally</span> &#123;               afterPrototypeCreation(beanName);            &#125;            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);         &#125;         <span class="hljs-comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span>         <span class="hljs-keyword">else</span> &#123;            String scopeName = mbd.getScope();            <span class="hljs-keyword">final</span> Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);            <span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);            &#125;            <span class="hljs-keyword">try</span> &#123;               Object scopedInstance = scope.get(beanName, <span class="hljs-keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;                  <span class="hljs-meta">@Override</span>                  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;                     beforePrototypeCreation(beanName);                     <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">// 执行创建 Bean</span>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);                     &#125;                     <span class="hljs-keyword">finally</span> &#123;                        afterPrototypeCreation(beanName);                     &#125;                  &#125;               &#125;);               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);            &#125;            <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName,                     <span class="hljs-string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +                     <span class="hljs-string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,                     ex);            &#125;         &#125;      &#125;      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;         cleanupAfterBeanCreationFailure(beanName);         <span class="hljs-keyword">throw</span> ex;      &#125;   &#125;   <span class="hljs-comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span>   <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span> &amp;&amp; bean != <span class="hljs-keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);      &#125;      <span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;         <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;            logger.debug(<span class="hljs-string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27; to required type &#x27;&quot;</span> +                  ClassUtils.getQualifiedName(requiredType) + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);         &#125;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());      &#125;   &#125;   <span class="hljs-keyword">return</span> (T) bean;&#125;</code></pre></div><p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException</span>;</code></pre></div><p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p><p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userService.getMessage();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span> /&gt;</span></code></pre></div><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p><p>好了，读者要知道这么回事就可以了，继续向前。</p><p>// AbstractAutowireCapableBeanFactory 447</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Central method of this class: creates a bean instance,</span><span class="hljs-comment"> * populates the bean instance, applies post-processors, etc.</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doCreateBean</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;   <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;      logger.debug(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);   &#125;   RootBeanDefinition mbdToUse = mbd;   <span class="hljs-comment">// 确保 BeanDefinition 中的 Class 被加载</span>   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);   <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-keyword">null</span>) &#123;      mbdToUse = <span class="hljs-keyword">new</span> RootBeanDefinition(mbd);      mbdToUse.setBeanClass(resolvedClass);   &#125;   <span class="hljs-comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span>   <span class="hljs-comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span>   <span class="hljs-comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span>   <span class="hljs-keyword">try</span> &#123;      mbdToUse.prepareMethodOverrides();   &#125;   <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),            beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);   &#125;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span>      <span class="hljs-comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span>      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);      <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> bean;       &#125;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,            <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);   &#125;   <span class="hljs-comment">// 重头戏，创建 bean</span>   Object beanInstance = doCreateBean(beanName, mbdToUse, args);   <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;      logger.debug(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);   &#125;   <span class="hljs-keyword">return</span> beanInstance;&#125;</code></pre></div><h4 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Actually create the specified bean. Pre-creation processing has already happened</span><span class="hljs-comment"> * at this point, e.g. checking &#123;<span class="hljs-doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span><span class="hljs-comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><span class="hljs-comment"> * factory method, and autowiring a constructor.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName the name of the bean</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mbd the merged bean definition for the bean</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a new instance of the bean</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeanCreationException if the bean could not be created</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #instantiateBean</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #instantiateUsingFactoryMethod</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #autowireConstructor</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> Object[] args)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;   <span class="hljs-comment">// Instantiate the bean.</span>   BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;      instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);   &#125;   <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span>      instanceWrapper = createBeanInstance(beanName, mbd, args);   &#125;   <span class="hljs-comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;</span>   <span class="hljs-keyword">final</span> Object bean = (instanceWrapper != <span class="hljs-keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="hljs-keyword">null</span>);   <span class="hljs-comment">// 类型</span>   Class&lt;?&gt; beanType = (instanceWrapper != <span class="hljs-keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="hljs-keyword">null</span>);   mbd.resolvedTargetType = beanType;   <span class="hljs-comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span>   <span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;      <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;         <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span>            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);         &#125;         <span class="hljs-keyword">catch</span> (Throwable ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,                  <span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);         &#125;         mbd.postProcessed = <span class="hljs-keyword">true</span>;      &#125;   &#125;   <span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span>   <span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>   <span class="hljs-comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span>   <span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;         isSingletonCurrentlyInCreation(beanName));   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;         logger.debug(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +               <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);      &#125;      addSingletonFactory(beanName, <span class="hljs-keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;            <span class="hljs-keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);         &#125;      &#125;);   &#125;   <span class="hljs-comment">// Initialize the bean instance.</span>   Object exposedObject = bean;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span>      populateBean(beanName, mbd, instanceWrapper);      <span class="hljs-keyword">if</span> (exposedObject != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span>         <span class="hljs-comment">// 这里就是处理 bean 初始化完成后的各种回调</span>         exposedObject = initializeBean(beanName, exposedObject, mbd);      &#125;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;         <span class="hljs-keyword">throw</span> (BeanCreationException) ex;      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(               mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Initialization of bean failed&quot;</span>, ex);      &#125;   &#125;   <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;      <span class="hljs-comment">// </span>      Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);      <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;            exposedObject = earlySingletonReference;         &#125;         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;            String[] dependentBeans = getDependentBeans(beanName);            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;               <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;                  actualDependentBeans.add(dependentBean);               &#125;            &#125;            <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,                     <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                     <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +                     <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +                     <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +                     <span class="hljs-string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);            &#125;         &#125;      &#125;   &#125;   <span class="hljs-comment">// Register bean as disposable.</span>   <span class="hljs-keyword">try</span> &#123;      registerDisposableBeanIfNecessary(beanName, bean, mbd);   &#125;   <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);   &#125;   <span class="hljs-keyword">return</span> exposedObject;&#125;</code></pre></div><p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p><p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p><p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p><h5 id="创建-Bean-实例"><a href="#创建-Bean-实例" class="headerlink" title="创建 Bean 实例"></a>创建 Bean 实例</h5><p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;   <span class="hljs-comment">// 确保已经加载了此 class</span>   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);   <span class="hljs-comment">// 校验一下这个类的访问权限</span>   <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,            <span class="hljs-string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());   &#125;   <span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>)  &#123;      <span class="hljs-comment">// 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span>      <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);   &#125;   <span class="hljs-comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span>   <span class="hljs-comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span>   <span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;   <span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;         <span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) &#123;            resolved = <span class="hljs-keyword">true</span>;            autowireNecessary = mbd.constructorArgumentsResolved;         &#125;      &#125;   &#125;   <span class="hljs-keyword">if</span> (resolved) &#123;      <span class="hljs-keyword">if</span> (autowireNecessary) &#123;         <span class="hljs-comment">// 构造函数依赖注入</span>         <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 无参构造函数</span>         <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);      &#125;   &#125;   <span class="hljs-comment">// 判断是否采用有参构造函数</span>   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);   <span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> ||         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;      <span class="hljs-comment">// 构造函数依赖注入</span>      <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);   &#125;   <span class="hljs-comment">// 调用无参构造函数</span>   <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);&#125;</code></pre></div><p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">instantiateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;   <span class="hljs-keyword">try</span> &#123;      Object beanInstance;      <span class="hljs-keyword">final</span> BeanFactory parent = <span class="hljs-keyword">this</span>;      <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;         beanInstance = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                              <span class="hljs-keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);            &#125;         &#125;, getAccessControlContext());      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 实例化</span>         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);      &#125;      <span class="hljs-comment">// 包装一下，返回</span>      BeanWrapper bw = <span class="hljs-keyword">new</span> BeanWrapperImpl(beanInstance);      initBeanWrapper(bw);      <span class="hljs-keyword">return</span> bw;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Instantiation of bean failed&quot;</span>, ex);   &#125;&#125;</code></pre></div><p>我们可以看到，关键的地方在于：</p><div class="hljs code-wrapper"><pre><code class="hljs java">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</code></pre></div><p>这里会进行实际的实例化过程，我们进去看看:</p><p>// SimpleInstantiationStrategy 59</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;   <span class="hljs-comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span>   <span class="hljs-comment">// 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍</span>   <span class="hljs-keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;      Constructor&lt;?&gt; constructorToUse;      <span class="hljs-keyword">synchronized</span> (bd.constructorArgumentLock) &#123;         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;         <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();            <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInstantiationException(clazz, <span class="hljs-string">&quot;Specified class is an interface&quot;</span>);            &#125;            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;                  constructorToUse = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;                     <span class="hljs-meta">@Override</span>                     <span class="hljs-keyword">public</span> Constructor&lt;?&gt; run() <span class="hljs-keyword">throws</span> Exception &#123;                        <span class="hljs-keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="hljs-keyword">null</span>);                     &#125;                  &#125;);               &#125;               <span class="hljs-keyword">else</span> &#123;                  constructorToUse = clazz.getDeclaredConstructor((Class[]) <span class="hljs-keyword">null</span>);               &#125;               bd.resolvedConstructorOrFactoryMethod = constructorToUse;            &#125;            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInstantiationException(clazz, <span class="hljs-string">&quot;No default constructor found&quot;</span>, ex);            &#125;         &#125;      &#125;      <span class="hljs-comment">// 利用构造方法进行实例化</span>      <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(constructorToUse);   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span>      <span class="hljs-comment">// tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span>      <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);   &#125;&#125;</code></pre></div><p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p><h5 id="bean-属性注入"><a href="#bean-属性注入" class="headerlink" title="bean 属性注入"></a>bean 属性注入</h5><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p><p>// AbstractAutowireCapableBeanFactory 1203</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;   <span class="hljs-comment">// bean 实例的所有属性都在这里了</span>   PropertyValues pvs = mbd.getPropertyValues();   <span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (!pvs.isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(               mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);      &#125;      <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// Skip property population phase for null instance.</span>         <span class="hljs-keyword">return</span>;      &#125;   &#125;   <span class="hljs-comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span>   <span class="hljs-comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span>   <span class="hljs-comment">// 我也没找到有实际的使用，所以我们暂且忽略这块吧</span>   <span class="hljs-keyword">boolean</span> continueWithPropertyPopulation = <span class="hljs-keyword">true</span>;   <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;      <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;         <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;            <span class="hljs-comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span>            <span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;               continueWithPropertyPopulation = <span class="hljs-keyword">false</span>;               <span class="hljs-keyword">break</span>;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-keyword">if</span> (!continueWithPropertyPopulation) &#123;      <span class="hljs-keyword">return</span>;   &#125;   <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;      MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);      <span class="hljs-comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span>      <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;         autowireByName(beanName, mbd, bw, newPvs);      &#125;      <span class="hljs-comment">// 通过类型装配。复杂一些</span>      <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;         autowireByType(beanName, mbd, bw, newPvs);      &#125;      pvs = newPvs;   &#125;   <span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();   <span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);   <span class="hljs-keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);      <span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;         <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;               <span class="hljs-comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span>               <span class="hljs-comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span>               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);               <span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-keyword">return</span>;               &#125;            &#125;         &#125;      &#125;      <span class="hljs-keyword">if</span> (needsDepCheck) &#123;         checkDependencies(beanName, mbd, filteredPds, pvs);      &#125;   &#125;   <span class="hljs-comment">// 设置 bean 实例的属性值</span>   applyPropertyValues(beanName, mbd, bw, pvs);&#125;</code></pre></div><h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;   <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;      AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            invokeAwareMethods(beanName, bean);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;      &#125;, getAccessControlContext());   &#125;   <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span>      invokeAwareMethods(beanName, bean);   &#125;   Object wrappedBean = bean;   <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;      <span class="hljs-comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span>      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);   &#125;   <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 处理 bean 中定义的 init-method，</span>      <span class="hljs-comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span>      invokeInitMethods(beanName, wrappedBean, mbd);   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(            (mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>),            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);   &#125;   <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;      <span class="hljs-comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span>      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);   &#125;   <span class="hljs-keyword">return</span> wrappedBean;&#125;</code></pre></div><p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p><p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p><div class="hljs code-wrapper"><pre><code class="hljs java">beanFactory.getBean(<span class="hljs-string">&quot;beanName or alias&quot;</span>);</code></pre></div><p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageService&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;m1, m2, m3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></code></pre></div><p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;m1, m2, m3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span> /&gt;</span></code></pre></div><p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></code></pre></div><p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p><p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></code></pre></div><p>以上配置的结果就是：beanName 为 messageService，没有别名。</p><h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p><p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p><p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p><p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374">jira</a> 的讨论中说明了怎么配置这两个属性。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoBeanOverridingContextLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContextLoader</span> </span>&#123;   <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customizeContext</span><span class="hljs-params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> </span>&#123;    <span class="hljs-keyword">super</span>.customizeContext(servletContext, applicationContext);    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;    arac.setAllowBeanDefinitionOverriding(<span class="hljs-keyword">false</span>);  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContextLoaderListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">context</span>.<span class="hljs-title">ContextLoaderListener</span> </span>&#123;   <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> ContextLoader <span class="hljs-title">createContextLoader</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NoBeanOverridingContextLoader();  &#125;  &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.javadoop.MyContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div><p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;development&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jee&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p><p>当然，我们也可以在一个配置文件中使用：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jee&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>理解起来也很简单吧。</p><p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p><p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p><p>最简单的方式莫过于在程序启动的时候指定：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">-Dspring.profiles.active=&quot;profile1,profile2&quot;</code></pre></div><blockquote><p>profile 可以激活多个</p></blockquote><p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p><div class="hljs code-wrapper"><pre><code class="hljs java">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">&quot;development&quot;</span>);ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh(); <span class="hljs-comment">// 重启</span></code></pre></div><p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -Dspring.profiles.active=prod -jar JavaDoop.jar</code></pre></div><p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p><h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p><p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p><p>静态工厂：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ClientService&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientService();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClientService</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">// 静态方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> clientService;    &#125;&#125;</code></pre></div><p>实例工厂：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AccountService accountService = <span class="hljs-keyword">new</span> AccountServiceImpl();    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> clientService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountService <span class="hljs-title">createAccountServiceInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> accountService;    &#125;&#125;</code></pre></div><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;     <span class="hljs-keyword">private</span> Car car ;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(Car car)</span></span>&#123; <span class="hljs-keyword">this</span>.car = car;  &#125;  &#125;</code></pre></div><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCarFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Car</span>&gt;</span>&#123;    <span class="hljs-keyword">private</span> String make;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> year ;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMake</span><span class="hljs-params">(String m)</span></span>&#123; <span class="hljs-keyword">this</span>.make =m ; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span></span>&#123; <span class="hljs-keyword">this</span>.year = y; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span>      CarBuilder cb = CarBuilder.car();            <span class="hljs-keyword">if</span>(year!=<span class="hljs-number">0</span>) cb.setYear(<span class="hljs-keyword">this</span>.year);      <span class="hljs-keyword">if</span>(StringUtils.hasText(<span class="hljs-keyword">this</span>.make)) cb.setMake( <span class="hljs-keyword">this</span>.make );       <span class="hljs-keyword">return</span> cb.factory();     &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;Car&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Car.class ; &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; &#125;&#125;</code></pre></div><p>我们看看装配的时候是怎么配置的：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;com.javadoop.MyCarFactoryBean&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;car&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;make&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;Honda&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;year&quot;</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;1984&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;com.javadoop.Person&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;josh&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;car&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarConfiguration</span> </span>&#123;     <span class="hljs-meta">@Bean</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> MyCarFactoryBean <span class="hljs-title">carFactoryBean</span><span class="hljs-params">()</span></span>&#123;       MyCarFactoryBean cfb = <span class="hljs-keyword">new</span> MyCarFactoryBean();      cfb.setMake(<span class="hljs-string">&quot;Honda&quot;</span>);      cfb.setYear(<span class="hljs-number">1984</span>);      <span class="hljs-keyword">return</span> cfb;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">aPerson</span><span class="hljs-params">()</span></span>&#123;     Person person = <span class="hljs-keyword">new</span> Person();      <span class="hljs-comment">// 注意这里的不同</span>    person.setCar(carFactoryBean().getObject());    <span class="hljs-keyword">return</span> person;     &#125; &#125;</code></pre></div><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p><h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInitBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span>/&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherExampleBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// do some initialization work</span>    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean(initMethod = &quot;init&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Foo <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Foo();&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    &#125;</code></pre></div><h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInitBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;cleanup&quot;</span>/&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherExampleBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DisposableBean</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// do some destruction work (like releasing pooled connections)</span>    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bar();&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PreDestroy</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;    &#125;</code></pre></div><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p><p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> DateUtils.parseDate(source, <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd HH:mm&quot;</span>, <span class="hljs-string">&quot;HH:mm:ss&quot;</span>, <span class="hljs-string">&quot;HH:mm&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p><h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p><div class="hljs code-wrapper"><pre><code class="hljs java">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</code></pre></div><p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p><p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p><p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p><p>看如下一个例子:</p><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;inheritedTestBean&quot;</span> <span class="hljs-keyword">abstract</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;parent&quot;</span>/&gt;    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span>/&gt;&lt;/bean&gt;&lt;bean id=<span class="hljs-string">&quot;inheritsWithDifferentClass&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.beans.DerivedTestBean&quot;</span>        parent=<span class="hljs-string">&quot;inheritedTestBean&quot;</span> init-method=<span class="hljs-string">&quot;initialize&quot;</span>&gt;            &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;override&quot;</span>/&gt;&lt;/bean&gt;</code></pre></div><p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p><p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p><p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p><p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="hljs-keyword">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;parent&quot;</span>/&gt;    &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span>/&gt;&lt;/bean&gt;</code></pre></div><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p><p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p><p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p><h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> fiona.apple;<span class="hljs-comment">// no more Spring imports!</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Object commandState)</span> </span>&#123;        <span class="hljs-comment">// grab a new instance of the appropriate Command interface</span>        Command command = createCommand();        <span class="hljs-comment">// set the state on the (hopefully brand new) Command instance</span>        command.setState(commandState);        <span class="hljs-keyword">return</span> command.execute();    &#125;    <span class="hljs-comment">// okay... but where is the implementation of this method?</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Command <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCommand&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- inject dependencies here as required --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commandManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">lookup-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;createCommand&quot;</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myCommand&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p><p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Object commandState)</span> </span>&#123;        MyCommand command = createCommand();        command.setState(commandState);        <span class="hljs-keyword">return</span> command.execute();    &#125;    <span class="hljs-meta">@Lookup(&quot;myCommand&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Command <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><blockquote><p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p></blockquote><p>甚至，我们可以像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandManager</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Object commandState)</span> </span>&#123;        MyCommand command = createCommand();        command.setState(commandState);        <span class="hljs-keyword">return</span> command.execute();    &#125;    <span class="hljs-meta">@Lookup</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> MyCommand <span class="hljs-title">createCommand</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><blockquote><p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p></blockquote><h4 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyValueCalculator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">computeValue</span><span class="hljs-params">(String input)</span> </span>&#123;        <span class="hljs-comment">// some real code...</span>    &#125;    <span class="hljs-comment">// some other methods...</span>&#125;</code></pre></div><p>方法覆写，注意要实现 MethodReplacer 接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementComputeValue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">beans</span>.<span class="hljs-title">factory</span>.<span class="hljs-title">support</span>.<span class="hljs-title">MethodReplacer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">reimplement</span><span class="hljs-params">(Object o, Method m, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-comment">// get the input value, work with it, and return a computed result</span>        String input = (String) args[<span class="hljs-number">0</span>];        ...        <span class="hljs-keyword">return</span> ...;    &#125;&#125;</code></pre></div><p>配置也很简单：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myValueCalculator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">replaced-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;computeValue&quot;</span> <span class="hljs-attr">replacer</span>=<span class="hljs-string">&quot;replacementComputeValue&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">arg-type</span>&gt;</span>String<span class="hljs-tag">&lt;/<span class="hljs-name">arg-type</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">replaced-method</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;replacementComputeValue&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span></code></pre></div><blockquote><p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p></blockquote><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;   <span class="hljs-function">Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;   <span class="hljs-function">Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre></div><p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p><p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p><p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p><p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p><p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p><p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p><p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按理说，总结应该写在附录前面，我就不讲究了。</p><p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p><p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p><p>（全文完）</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>框架</tag>
      
      <tag>IOC</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring【IOC和AOP】</title>
    <link href="/2021/01/26/Spring%E3%80%90IOC%E5%92%8CAOP%E3%80%91/"/>
    <url>/2021/01/26/Spring%E3%80%90IOC%E5%92%8CAOP%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring【IOC和AOP】"><a href="#Spring【IOC和AOP】" class="headerlink" title="Spring【IOC和AOP】"></a>Spring【IOC和AOP】</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC（Inversion Of Controll，控制反转）是<strong>一种设计思想</strong>，就是将原本在程序中手动创建对象的控制权，交由给 Spring 框架来管理。IOC 在其他语言中也有应用，并非 Spring 特有。IOC 容器是 Spring 用来实现 IOC 思想的载体，IOC 容器实际上就是一个 Map (key, value)，Map 中存放的是各种对象。</p><p>将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件 / 注解即可，完全不用考虑对象是如何被创建出来的。在实际项目中一个 Service 类可能由几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，可能要每次都搞清楚这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，大大增加了项目的可维护性且降低了开发难度。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）<strong>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的<strong>可扩展性和可维护性。</strong></p><p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么 Spring AOP 就会使用 JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用 JDK 动态代理，转而使用 CGlib 动态代理生成一个被代理对象的子类来作为代理。</p><p><img src="https://img2018.cnblogs.com/blog/842514/201906/842514-20190611212955176-1474324049.png" alt="img"></p><p>当然也可以使用 AspectJ，Spring AOP 中已经集成了 AspectJ，AspectJ 应该算得上是 Java 生态系统中最完整的 AOP 框架了。使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了 AOP。</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>IOC</tag>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty【入门】</title>
    <link href="/2021/01/25/Netty%E3%80%90%E5%85%A5%E9%97%A8%E3%80%91/"/>
    <url>/2021/01/25/Netty%E3%80%90%E5%85%A5%E9%97%A8%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h1 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h1><p>对于这个问题，之前我写了一篇文章<a href="https://www.toutiao.com/i6842509002530619918/?group_id=6842509002530619918?group_id=6842509002530619918">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h1 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h1><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2Y5MGVhNWYwMmIzMzQ4OGRiNGFhNTlhN2EzOGJhMWZi?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p></blockquote><blockquote><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p></blockquote><blockquote><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzYzZmE3Y2MyMzQwYzQxNTY4ZTEyNTM5NGEzN2I0ZDE1?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h1><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.20.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组 boosGroup、workerGroup</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建服务端的启动对象，设置参数</span>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();           <span class="hljs-comment">//设置两个线程组boosGroup和workerGroup</span>            bootstrap.group(bossGroup, workerGroup)            <span class="hljs-comment">//设置服务端通道实现类型    </span>                .channel(NioServerSocketChannel.class)                <span class="hljs-comment">//设置线程队列得到连接个数    </span>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)                <span class="hljs-comment">//设置保持活动连接状态    </span>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)                <span class="hljs-comment">//使用匿名内部类的形式初始化通道对象    </span>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//给pipeline管道设置处理器</span>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyServerHandler());                    &#125;                &#125;);<span class="hljs-comment">//给workerGroup的EventLoop对应的管道设置处理器</span>            System.out.println(<span class="hljs-string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);            <span class="hljs-comment">//绑定端口号，启动服务端</span>            ChannelFuture channelFuture = bootstrap.bind(<span class="hljs-number">6666</span>).sync();            <span class="hljs-comment">//对关闭通道进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully()            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><h1 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><span class="hljs-comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取客户端发送过来的消息</span>        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;发送的消息：&quot;</span> +         byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发送消息给客户端</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));   &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发生异常，关闭通道</span>        ctx.close();    &#125;&#125;</code></pre></div><h1 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        NioEventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//创建bootstrap对象，配置参数</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-comment">//设置线程组</span>           bootstrap.group(eventExecutors)                <span class="hljs-comment">//设置客户端的通道实现类型    </span>               .channel(NioSocketChannel.class)                <span class="hljs-comment">//使用匿名内部类初始化通道</span>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加客户端通道的处理器</span>                     ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyClientHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);            <span class="hljs-comment">//连接服务端</span>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>).sync()            <span class="hljs-comment">//对通道关闭进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-comment">//关闭线程组</span>            eventExecutors.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><h1 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发送消息到服务端</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       <span class="hljs-comment">//接收服务端发送过来的消息</span>       ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));    &#125;&#125;</code></pre></div><h1 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h1><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzA3MjJjYzJiNzQ4ZjQxNzE4YmYzZTk2YjBkZDRkYWRl?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>MyClient打印结果：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzdkYzliNTc5ZTc3MDQ3NDBiMzVmZjE3MTQzNGQyMjNl?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h1 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h1><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取到线程池eventLoop，添加线程，执行</span>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span>                    Thread.sleep(<span class="hljs-number">1000</span>);                    System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2ExYTVhOTJjMjI3ZjRmMTA4NjBiYzJmMjNkNzRlYzE0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h1><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span>            Thread.sleep(<span class="hljs-number">1000</span>);            System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<span class="hljs-comment">//5秒后执行</span></code></pre></div><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2E4ZTUxZTdkMjFjYjQ0Yzg4MGRmMTFmMjk4NjU0MTFj?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h1><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);</code></pre></div><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//添加监听器</span>channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-comment">//使用匿名内部类，ChannelFutureListener接口</span>    <span class="hljs-comment">//重写operationComplete方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//判断是否操作成功 </span>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;            System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;连接失败&quot;</span>);        &#125;    &#125;&#125;);</code></pre></div><h1 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h1><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2JkMDg4NzAxODA2NDQxYjViNGU4ZGUzOTNiYjczYzI3?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzc1YzNjMWMzOWYxNTRjZTVhNjg1ZTJmODkyMjgyNDYx?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h1><p>在上一篇文章<a href="https://www.toutiao.com/i6844892035749511684/?group_id=6844892035749511684">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>在上一篇文章<a href="https://www.toutiao.com/i6844892035749511684/?group_id=6844892035749511684">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><div class="hljs code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用一个常量保存</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(            <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;        logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);    &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;        <span class="hljs-comment">//如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span>&#125;</code></pre></div><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置bossGroup线程数为1</span>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<span class="hljs-comment">//设置workerGroup线程数为16</span>EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">16</span>);</code></pre></div><h1 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h1><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzZkZmEyZTMwNGYyNDQ5MWI5NWM3OWQxMjU0MjNlZDc4?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>使用debug模式可以看到</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2ZlOWVmMzRkNWIxOTQyMDU4ZTcyNDg1ZDQxMDQwMjY0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。 <strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。 OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//server端代码，跟上面几乎一样，只需改三个地方</span><span class="hljs-comment">//这个地方使用的是OioEventLoopGroup</span>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> OioEventLoopGroup();ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();bootstrap.group(bossGroup)<span class="hljs-comment">//只需要设置一个线程组boosGroup</span>    .channel(OioServerSocketChannel.class)<span class="hljs-comment">//设置服务端通道实现类型</span>    <span class="hljs-comment">//client端代码，只需改两个地方</span>    <span class="hljs-comment">//使用的是OioEventLoopGroup</span>    EventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> OioEventLoopGroup();<span class="hljs-comment">//通道类型设置为OioSocketChannel</span>bootstrap.group(eventExecutors)<span class="hljs-comment">//设置线程组</span>.channel(OioSocketChannel.class)<span class="hljs-comment">//设置客户端的通道实现类型</span></code></pre></div><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。 NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h1 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h1><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。 <strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。 <strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h1 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h1><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类的形式初始化通道对象</span>bootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//给pipeline管道设置自定义的处理器</span>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyServerHandler());&#125;&#125;);</code></pre></div><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li>注册事件 fireChannelRegistered。</li><li>连接建立事件 fireChannelActive。</li><li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li>异常通知事件 fireExceptionCaught。</li><li>用户自定义事件 fireUserEventTriggered。</li><li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li>连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li>端口绑定 bind。</li><li>连接服务端 connect。</li><li>写事件 write。</li><li>刷新时间 flush。</li><li>读事件 read。</li><li>主动断开连接 disconnect。</li><li>关闭 channel 事件 close。</li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h1 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h1><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h1 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//释放掉所有的资源，包括创建的线程</span>bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre></div><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h1 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h1><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),</p><p>the configuration parameters of the channel (e.g. receive buffer size),</p><p>the I/O operations that the channel supports (e.g. read, write, connect, and bind),</p><p>and the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li>通道当前的状态（例如它是打开？还是已连接？）</li><li>channel的配置参数（例如接收缓冲区的大小）</li><li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h1 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//如果通道打开，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRegistered</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果通道注册到EventLoop，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果通道处于活动状态并且已连接，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</span></code></pre></div><p>以上就是获取channel的四种状态的方法。</p><h1 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h1><p>获取单条配置信息，使用getOption()，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelConfig config = channel.config();<span class="hljs-comment">//获取配置参数</span><span class="hljs-comment">//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);</span><span class="hljs-comment">//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</span></code></pre></div><p>获取多条配置信息，使用getOptions()，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();<span class="hljs-keyword">for</span> (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123; System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">SO_REUSEADDR : false</span><span class="hljs-comment">WRITE_BUFFER_LOW_WATER_MARK : 32768</span><span class="hljs-comment">WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)</span><span class="hljs-comment">SO_BACKLOG : 128</span><span class="hljs-comment"></span><span class="hljs-comment">以下省略...</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h1 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h1><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;这波啊，这波是肉蛋葱鸡~&quot;</span>, CharsetUtil.UTF_8))&#125;</code></pre></div><p>客户端控制台：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>收到服务端/<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6666</span>的消息：这波啊，这波是肉蛋葱鸡~</code></pre></div><p><strong>连接</strong>操作，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelFuture connect = channelFuture.channel().connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>));<span class="hljs-comment">//一般使用启动器，这种方式不常用</span></code></pre></div><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取ChannelPipeline对象</span>ChannelPipeline pipeline = ctx.channel().pipeline();<span class="hljs-comment">//往pipeline中添加ChannelHandler处理器，装配流水线</span>pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());</code></pre></div><h1 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h1><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://www.toutiao.com/i6842509002530619918/?group_id=6842509002530619918?group_id=6842509002530619918">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzRhOTA5NDc1MWFiZTRkODdhMDMxZTk0NGI2NTVjYzM0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h1><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzU2OGQ1ZTcxZjBlMzRiZWU4NzdiZTNhMjQ3NjBjNzZk?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h1 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h1><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzMyMzZlNDIzYjgwNzRmYjA5ZTkwYThjOTA4ODRjZjky?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123; <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>); succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>); voidPromise =  <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>); <span class="hljs-comment">//设置头结点head，尾结点tail</span> tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>); head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>); head.next = tail; tail.prev = head;&#125;</code></pre></div><p>下面我用一张图来表示，会更加清晰一点：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzlmYzRmYzQwNTljYTQyNDI5MmFhOGYwMjEwOTE0Zjc1?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h1><p>我们先看一下EventLoopGroup的类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzAzNjEwOTRjNDkzYzRmNTg5ZjExOWE3NzRlZmYyOTE3?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h1 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h1><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger idx = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//idx.getAndIncrement()相当于idx++，然后对任务长度取模</span>    <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];&#125;</code></pre></div><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2JiMDUzZDczMDZlMDRhYjI5ZWE0OGRkNTM2MjNjNmFj?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构【前缀树】</title>
    <link href="/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%89%8D%E7%BC%80%E6%A0%91%E3%80%91/"/>
    <url>/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%89%8D%E7%BC%80%E6%A0%91%E3%80%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ【高可用】</title>
    <link href="/2021/01/25/RabbitMQ%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%91/"/>
    <url>/2021/01/25/RabbitMQ%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h1><blockquote><p> RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。谈不到高可用。</p><h2 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h2><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个，生产者创建的queue只会放在一个RabbitMQ的实例中，其余的实例会同步queue的元数据(元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例)，在消费者进行消费的时候，连接到另一个实例上时，这个实例会通过同步的元数据找到queue所在的实例，然后请求数据。</p><p><img src="https://i.loli.net/2021/01/25/lFR4BHY8fn95hUE.png" alt="jiqun01.png"></p><p>这种方式很麻烦，也不怎么好。因为这中集群方式，导致消费者要么每次随机连接一个实例然后拉取数据，要么固定连接那个 <strong>queue</strong> 所在实例消费数据，前者有<strong>数据拉取的开销</strong>，后者会有<strong>单实例性能瓶颈</strong>。这种集群模式还会有一个<strong>严重的后果</strong>就是如果那个存放 queue 的RabbitMQ实例<strong>宕机</strong>了，会导致接下来其他RabbitMQ实例就无法从那个实例拉取，如果你<strong>开启了消息持久化</strong>，让 RabbitMQ 落地存储消息的话，<strong>消息不一定会丢</strong>，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据,如果<strong>没开消息持久化</strong>，queue的数据还会丢失。</p><p>这种集群其余节点<strong>高度依赖</strong>queue所在的RabbitMQ节点，这样就<strong>没有什么所谓的高可用性</strong>，<strong>这方案倒是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><h2 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h2><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/mq-8.png" alt="mq-8"></p><h3 id="如何开启这个镜像集群模式呢？"><a href="#如何开启这个镜像集群模式呢？" class="headerlink" title="如何开启这个镜像集群模式呢？"></a>如何开启这个镜像集群模式呢？</h3><p>其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><h3 id="镜像集群模式优缺点"><a href="#镜像集群模式优缺点" class="headerlink" title="镜像集群模式优缺点"></a>镜像集群模式优缺点</h3><p>优点：你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。</p><p>缺点：</p><ul><li>第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！</li><li>第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis【主从复制】</title>
    <link href="/2021/01/24/redis%E3%80%90%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%91/"/>
    <url>/2021/01/24/redis%E3%80%90%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="redis【主从复制】"><a href="#redis【主从复制】" class="headerlink" title="redis【主从复制】"></a>redis【主从复制】</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>如果redis要支撑超过10万+的并发，那应该怎么做？</p><p>单机的redis几乎不太可能说QPS超过10万+，除非一些特殊情况，比如你的机器性能特别好，配置特别高，物理机，维护做的特别好，而且你的整体的操作不是太复杂。一般来说redis单机在几万上下。</p><p>如果想要超过10w+的并发，就要读写分离了。一般来说，对缓存一般都是用来支撑读高并发的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千，大量的请求都是读，一秒钟二十万次读</p></blockquote><h2 id="利用-redis-master-salve-replication【主从复制】实现的读写分离"><a href="#利用-redis-master-salve-replication【主从复制】实现的读写分离" class="headerlink" title="利用 redis master-salve replication【主从复制】实现的读写分离"></a>利用 redis master-salve replication【主从复制】实现的读写分离</h2><h3 id="1、图解redis-replication基本原理"><a href="#1、图解redis-replication基本原理" class="headerlink" title="1、图解redis replication基本原理"></a>1、图解redis replication基本原理</h3><p><img src="https://i.loli.net/2021/01/24/vjDWRi76h5XK9I4.png" alt="redis_1.png"></p><h3 id="2、redis-replication的核心机制"><a href="#2、redis-replication的核心机制" class="headerlink" title="2、redis replication的核心机制"></a>2、redis replication的核心机制</h3><p>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量<br>（2）一个master node是可以配置多个slave node的<br>（3）slave node也可以连接其他的slave node<br>（4）slave node做复制的时候，是不会block master node的正常工作的<br>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了<br>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</p><h3 id="3、master-node-持久化对于主从架构的安全保障的意义"><a href="#3、master-node-持久化对于主从架构的安全保障的意义" class="headerlink" title="3、master node 持久化对于主从架构的安全保障的意义"></a>3、master node 持久化对于主从架构的安全保障的意义</h3><h4 id="如果采用了主从架构，建议必须开启master-node的持久化！"><a href="#如果采用了主从架构，建议必须开启master-node的持久化！" class="headerlink" title="如果采用了主从架构，建议必须开启master node的持久化！"></a>如果采用了主从架构，建议必须开启master node的持久化！</h4><p>答：我们知道主从复制的架构中，所有的写操作交由master负责，slave分担读的操作，slave中的数据是从master同步过来的。假如master的rdb和aof都关闭了，数据全部在内存中，那么master宕机重启时，发现本地没有可以恢复的数据，导致master内存数据为空，然后master将空的数据集同步到slave节点，导致slave的数据全部清空。因此master必须要开启持久化！<br>即使我们采用高可用机制的哨兵模式，即master宕机时，slave节点通过选举转变为master节点，在这种情况下，可能哨兵模式还没检测到master节点宕机，master节点就自动重启了，因此还是可能导致所有slave节点数据清空。</p><h4 id="使用持久化机制master的各种备份方案，要不要做？"><a href="#使用持久化机制master的各种备份方案，要不要做？" class="headerlink" title="使用持久化机制master的各种备份方案，要不要做？"></a>使用持久化机制master的各种备份方案，要不要做？</h4><p>答案：<strong>要做的</strong>，如果说本地的所有文件丢失了，这时我们就可以从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的。</p><h3 id="4、redis-replication主从复制的核心原理"><a href="#4、redis-replication主从复制的核心原理" class="headerlink" title="4、redis replication主从复制的核心原理"></a>4、redis replication主从复制的核心原理</h3><ul><li><p>slave node启动的时候，会发送一个PSYNC命令给master node，</p></li><li><p>slave node第一次连接master node，那么会触发一次full resynchronization（全量备份）：</p><p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p></li><li><p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据;。</p></li><li><p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p></li></ul><h3 id="5、主从复制的断点续传"><a href="#5、主从复制的断点续传" class="headerlink" title="5、主从复制的断点续传"></a>5、主从复制的断点续传</h3><p>​           从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份，master node会在内存中创建一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p><p>但是如果没有找到对应的offset，那么就会执行一次resynchronization</p><h3 id="6、无磁盘化复制"><a href="#6、无磁盘化复制" class="headerlink" title="6、无磁盘化复制"></a>6、无磁盘化复制</h3><p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p><p>repl-diskless-sync<br>repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p><h3 id="7、过期key处理"><a href="#7、过期key处理" class="headerlink" title="7、过期key处理"></a>7、过期key处理</h3><p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>redis</tag>
      
      <tag>读写分离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis【持久化】</title>
    <link href="/2021/01/23/redis%E3%80%90%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%91/"/>
    <url>/2021/01/23/redis%E3%80%90%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="redis【持久化】"><a href="#redis【持久化】" class="headerlink" title="redis【持久化】"></a>redis【持久化】</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​         redis的缓存是基于内存的缓存，当redis突然挂掉的时候（不管是因为什么原因），其存放在内存中的数据就全部都丢失了，redis重启后数据就全部都没有了，这个时候就体现到了redis持久化的意义了。对于一个企业级的redis架构来说，持久化更是不可减少的。企业级redis集群架构的特点<strong>海量数据、高并发、高可用</strong>，持久化主要是做灾难恢复，数据恢复，但可以归类到高可用。</p><p><strong>没有做持久化的后果？</strong></p><p>​        如果你的redis宕机了，因为没有做持久化redis重启redis后，redis内数据是空的，这个时候如果大量请求打过来，redis数据为空，这时就会发生<strong>缓存雪崩</strong>问题，所有请求，没有在redis中命中，这时就会去数据库这种数据源头中去查询数据，大量的sql查询导致数据库并发量激增，然后就挂掉了，数据库挂掉后，你都没法去找数据缓存到redis里面去，redis的数据从哪儿来？从数据库来。数据库挂掉后还会影响其他系统应用。发生更大的灾难。</p><h2 id="1、RDB和AOF两种持久化机制的介绍"><a href="#1、RDB和AOF两种持久化机制的介绍" class="headerlink" title="1、RDB和AOF两种持久化机制的介绍"></a>1、RDB和AOF两种持久化机制的介绍</h2><ul><li>RDB持久化机制：对redis中的数据执行<strong>周期性的持久化</strong>。</li><li>AOF机制：对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</li></ul><p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制。通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云，云服务，如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务，需要注意的是：如果<strong>同时使用</strong>RDB和AOF两种持久化机制，那么在<strong>redis重启</strong>的时候，会使用<strong>AOF来重新构建数据</strong>，因为<strong>AOF中的数据更加完整</strong></p><h2 id="2、redis使用RDB"><a href="#2、redis使用RDB" class="headerlink" title="2、redis使用RDB"></a>2、redis使用RDB</h2><h3 id="默认开启RDB策略"><a href="#默认开启RDB策略" class="headerlink" title="默认开启RDB策略"></a>默认开启RDB策略</h3><p><code>redis.config</code> 中RDB相关配置</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">################################ SNAPSHOTTING  ################################</span><span class="hljs-comment">#</span><span class="hljs-comment"># Save the DB on disk:</span><span class="hljs-comment">#</span><span class="hljs-comment">#   save &lt;seconds&gt; &lt;changes&gt;</span><span class="hljs-comment">#</span><span class="hljs-comment">#   Will save the DB if both the given number of seconds and the given</span><span class="hljs-comment">#   number of write operations against the DB occurred.</span><span class="hljs-comment">#</span><span class="hljs-comment">#   In the example below the behaviour will be to save:</span><span class="hljs-comment">#   after 900 sec (15 min) if at least 1 key changed</span><span class="hljs-comment">#   after 300 sec (5 min) if at least 10 keys changed</span><span class="hljs-comment">#   after 60 sec if at least 10000 keys changed</span><span class="hljs-comment">#</span><span class="hljs-comment">#   <span class="hljs-doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span><span class="hljs-comment">#</span><span class="hljs-comment">#   It is also possible to remove all the previously configured save</span><span class="hljs-comment">#   points by adding a save directive with a single empty string argument</span><span class="hljs-comment">#   like in the following example:</span><span class="hljs-comment">#</span><span class="hljs-comment">#   save &quot;&quot;</span><span class="hljs-attr">save</span> <span class="hljs-string">900 1</span><span class="hljs-attr">save</span> <span class="hljs-string">300 10</span><span class="hljs-attr">save</span> <span class="hljs-string">60 10000</span></code></pre></div><p><code>save 60 10000</code> 的说明：每隔60s，如果有超过10000个key发生了变更，就会生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，这个操作也被称之为snapshotting-快照。也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成，save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件，会覆盖之前的dump.rdb文件。</p><p><strong>注意：</strong>在执行<code>redis-cli shutdow</code>命令时，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照。要想测试发生故障的需要<code>ps -ef|grep redis</code> 查看redis进程号pid，然后<code>kill -9 pid</code> 。这样就能测试RDB了。</p><h3 id="RDB持久化机制的工作流程"><a href="#RDB持久化机制的工作流程" class="headerlink" title="RDB持久化机制的工作流程"></a>RDB持久化机制的工作流程</h3><p>（1）redis根据配置自己尝试去生成rdb快照文件<br>（2）fork一个子进程出来<br>（3）子进程尝试将数据dump到临时的rdb快照文件中<br>（4）完成rdb快照文件的生成之后，就替换之前的旧的快照文件</p><h2 id="3、redis-使用AOF"><a href="#3、redis-使用AOF" class="headerlink" title="3、redis 使用AOF"></a>3、redis 使用AOF</h2><p>AOF持久化：默认是关闭的，默认开启RDB机制。</p><h3 id="开启AOF持久化机制"><a href="#开启AOF持久化机制" class="headerlink" title="开启AOF持久化机制"></a>开启AOF持久化机制</h3><p><code>redis.config</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">############################# APPEND ONLY MODE ###############################</span><span class="hljs-comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><span class="hljs-comment"># good enough in many applications, but an issue with the Redis process or</span><span class="hljs-comment"># a power outage may result into a few minutes of writes lost (depending on</span><span class="hljs-comment"># the configured save points).</span><span class="hljs-comment">#</span><span class="hljs-comment"># The Append Only File is an alternative persistence mode that provides</span><span class="hljs-comment"># much better durability. For instance using the default data fsync policy</span><span class="hljs-comment"># (see later in the config file) Redis can lose just one second of writes in a</span><span class="hljs-comment"># dramatic event like a server power outage, or a single write if something</span><span class="hljs-comment"># wrong with the Redis process itself happens, but the operating system is</span><span class="hljs-comment"># still running correctly.</span><span class="hljs-comment">#</span><span class="hljs-comment"># AOF and RDB persistence can be enabled at the same time without problems.</span><span class="hljs-comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><span class="hljs-comment"># with the better durability guarantees.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Please check http://redis.io/topics/persistence for more information.</span><span class="hljs-comment"># appendonly no</span><span class="hljs-comment"># 需要将appendonly 设置为yes 来开启 appendonly</span><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes </span></code></pre></div><p>打开AOF持久化机制之后，redis每次接收到一条写命令，就会写入日志文件中，再写入日志文件之前，先写入os cache的，然后每隔一定时间再fsync一下，将数据刷入日志文件。RDB和AOF同时开启，恢复数据时采用AOF机制。</p><h3 id="redis在进行fsync时有三种策略可以选择"><a href="#redis在进行fsync时有三种策略可以选择" class="headerlink" title="redis在进行fsync时有三种策略可以选择"></a>redis在进行fsync时有三种策略可以选择</h3><ul><li><strong>always</strong>  每次写入一条数据，立即将这个数据对应的写日志 fsync 到磁盘上去，性能非常非常差，吞吐量很低; 确保说redis里的数据一条都不丢，那就只能这样了</li><li><strong>everysec</strong> 每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万。</li><li><strong>no</strong> 仅仅redis负责将数据写入os cache就撒手不管了，然后后面 os 自己会时不时有自己的策略将数据刷入磁盘，不可控了</li></ul><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># The fsync() call tells the Operating System to actually write data on disk</span><span class="hljs-comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span><span class="hljs-comment"># data on disk, some other OS will just try to do it ASAP.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Redis supports three different modes:</span><span class="hljs-comment">#</span><span class="hljs-comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster. </span><span class="hljs-comment"># always: fsync after every write to the append only log. Slow, Safest.</span><span class="hljs-comment"># everysec: fsync only one time every second. Compromise.</span><span class="hljs-comment">#</span><span class="hljs-comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><span class="hljs-comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><span class="hljs-comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span><span class="hljs-comment"># it wants, for better performances (but if you can live with the idea of</span><span class="hljs-comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><span class="hljs-comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><span class="hljs-comment"># everysec.</span><span class="hljs-comment">#</span><span class="hljs-comment"># More details please check the following article:</span><span class="hljs-comment"># http://antirez.com/post/redis-persistence-demystified.html</span><span class="hljs-comment">#</span><span class="hljs-comment"># If unsure, use &quot;everysec&quot;.</span><span class="hljs-comment"># appendfsync always </span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec</span><span class="hljs-comment"># appendfsync no</span></code></pre></div><h3 id="AOF-Rewrite"><a href="#AOF-Rewrite" class="headerlink" title="AOF Rewrite"></a>AOF Rewrite</h3><p>redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉，redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中，所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件只有一个，会不断的膨胀，到很大很大。</p><p>所以AOF会自动在后台每隔一定时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了; redis此时内存只剩下10万; 基于内存中当前的10万数据构建一套最新的日志并写入到AOF中，覆盖之前的老日志;。确保AOF日志文件不会过大，保持跟redis内存数据量一致。</p><p><strong>需要注意的是</strong>：<strong>redis 2.4</strong>之前，还需要手动，开发一些脚本，crontab，通过BGREWRITEAOF命令去执行AOF rewrite，但是redis 2.4之后，会自动进行rewrite操作。</p><p>在redis.config中，可以配置rewrite策略，这个一般不用配置。</p><p><strong>rewrite过程</strong></p><p>（1）redis fork一个子进程<br>（2）子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志<br>（3）redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件<br>（4）子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中<br>（5）用新的日志文件替换掉旧的日志文件</p><h3 id="AOF破损文件的修复"><a href="#AOF破损文件的修复" class="headerlink" title="AOF破损文件的修复"></a>AOF破损文件的修复</h3><p>如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损，用<code>redis-check-aof --fix filename  </code>命令来修复破损的AOF文件。</p><h2 id="4、AOF和RDB同时工作"><a href="#4、AOF和RDB同时工作" class="headerlink" title="4、AOF和RDB同时工作"></a>4、AOF和RDB同时工作</h2><p>（1）如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis在执行AOF rewrite，那么就不会执行RDB snapshotting。<br>（2）如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行 AOF rewrite。<br>（3）同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整。</p><h2 id="5、RDB持久化机制的优缺点"><a href="#5、RDB持久化机制的优缺点" class="headerlink" title="5、RDB持久化机制的优缺点"></a>5、RDB持久化机制的优缺点</h2><h3 id="RDB持久化机制的优点"><a href="#RDB持久化机制的优点" class="headerlink" title="RDB持久化机制的优点"></a>RDB持久化机制的优点</h3><p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，以预定好的备份策略来定期备份redis中的数据</p><p>（2）RDB对redis对外提供的读写服务，对redis影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。</p><p>（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速。</p><h3 id="RDB持久化机制的缺点"><a href="#RDB持久化机制的缺点" class="headerlink" title="RDB持久化机制的缺点"></a>RDB持久化机制的缺点</h3><p>（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候一旦redis进程宕机，那么会丢失最近5分钟的数据。</p><p>（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</p><h2 id="6、AOF持久化机制的优缺点"><a href="#6、AOF持久化机制的优缺点" class="headerlink" title="6、AOF持久化机制的优缺点"></a>6、AOF持久化机制的优缺点</h2><h3 id="AOF持久化机制的优点"><a href="#AOF持久化机制的优点" class="headerlink" title="AOF持久化机制的优点"></a>AOF持久化机制的优点</h3><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p><p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p><p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><h3 id="AOF持久化机制的缺点"><a href="#AOF持久化机制的缺点" class="headerlink" title="AOF持久化机制的缺点"></a>AOF持久化机制的缺点</h3><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。</p><p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p><h2 id="7、RDB和AOF到底该如何选择"><a href="#7、RDB和AOF到底该如何选择" class="headerlink" title="7、RDB和AOF到底该如何选择"></a>7、RDB和AOF到底该如何选择</h2><p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据</p><p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p><p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p><h2 id="8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？"><a href="#8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？" class="headerlink" title="8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？"></a>8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？</h2><h3 id="1、企业级的持久化的配置策略"><a href="#1、企业级的持久化的配置策略" class="headerlink" title="1、企业级的持久化的配置策略"></a>1、企业级的持久化的配置策略</h3><p>在企业中，RDB的生成策略，用默认的也差不多</p><p>对于这个save 60 10000：如果你希望尽可能确保说，RDB最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，低峰期，数据量很少，也没必要</p><p>10000-&gt;生成RDB，1000-&gt;RDB，这个根据你自己的应用和业务的数据量，你自己去决定</p><p>AOF机制要一定要打开，选择 everysec 即可。 </p><p>auto-aof-rewrite-percentage 100: 就是当前AOF大小膨胀到超过上次100%，上次的两倍<br>auto-aof-rewrite-min-size 64mb: 根据你的数据量来定，16mb，32mb</p><h3 id="2、企业级的数据备份方案"><a href="#2、企业级的数据备份方案" class="headerlink" title="2、企业级的数据备份方案"></a>2、企业级的数据备份方案</h3><p>RDB非常适合做冷备，每次生成之后，就不会再有修改了</p><h4 id="数据备份方案"><a href="#数据备份方案" class="headerlink" title="数据备份方案"></a>数据备份方案</h4><p>（1）写crontab定时调度脚本去做数据备份<br>（2）每小时都copy一份rdb的备份，到一个目录中去，仅仅保留最近48小时的备份<br>（3）每天都保留一份当日的rdb的备份，到一个目录中去，仅仅保留最近1个月的备份<br>（4）每次copy备份的时候，都把太旧的备份给删了<br>（5）每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去</p><h4 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h4><p>每小时copy一次备份，删除48小时前的数据</p><p><code>redis_rab_copy_hourly.sh</code></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh </span>cur_date=`date +%Y%m%d%k`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>mkdir /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>cp /var/redis/6379/dump.rdb /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>del_date=`date -d -48hour +%Y%m%d%k`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$del_date</span></code></pre></div><p>创建定时任务执行<code>crontab -e</code> 写入 下面内容 实现每小时执行redis_rab_copy_hourly.sh</p><div class="hljs code-wrapper"><pre><code class="hljs bash">0 * * * * sh /usr/<span class="hljs-built_in">local</span>/redis/copy/redis_rdb_copy_hourly.sh</code></pre></div><p>每天copy一次备份删除一个月以前的数据</p><p>执行<code>vi redis_rdb_copy_daily.sh</code> 写入一下内容</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh </span>cur_date=`date +%Y%m%d`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>mkdir /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>cp /var/redis/6379/dump.rdb /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>del_date=`date -d -1month +%Y%m%d`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$del_date</span></code></pre></div><p>创建定时任务执行<code>crontab -e</code> 写入 下面内容 实现每小时执行redis_rab_copy_hourly.sh</p><div class="hljs code-wrapper"><pre><code class="hljs bash">0 0 * * * sh /usr/<span class="hljs-built_in">local</span>/redis/copy/redis_rdb_copy_daily.sh</code></pre></div><h4 id="数据恢复方案"><a href="#数据恢复方案" class="headerlink" title="数据恢复方案"></a>数据恢复方案</h4><p>（1）如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据，如果fsync选择的策略为 everysec，最多就丢一秒的数</p><p>（2）如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，AOF没有破损，也是可以直接基于AOF恢复的，AOF append-only，顺序写入，如果AOF文件破损，那么用redis-check-aof fix进行修复。</p><p>（3）如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复</p><p>当前最新的AOF和RDB文件都出现了丢失/损坏到无法恢复，一般不是机器的故障，这时找到RDB最新的一份备份，小时级的备份可以了，小时级的肯定是最新的，copy到redis里面去，就可以恢复到某一个小时的数据。</p><p>（4）如果当前机器上的所有RDB文件全部损坏，那么从远程的云服务上拉取最新的RDB快照回来恢复数据</p><p>（5）如果是发现有重大的数据错误，比如某个小时上线的程序一下子将数据全部污染了，数据全错了，那么可以选择某个更早的时间点，对数据进行恢复。</p><h4 id="恢复注意"><a href="#恢复注意" class="headerlink" title="恢复注意"></a>恢复注意</h4><p>AOF和RDB都开启的时候，会优先用AOF恢复数据，如果此时appendonly.aof不存在，redis会创建一个新的空的aof文件，会导致redis中没有任何数据。因此如果开启了AOF机制，一定要保证appendonly.aof一定要存在，并且数据是正确的。</p><p>这时发现AOF文件出错，需要基于RDB进行恢复，我们怎么能，完美的恢复数据，同时还保持aof和rdb的双开？</p><p>停止redis，关闭aof，拷贝rdb备份，重启redis，确认数据恢复，直接在命令行热修改redis配置，打开aof，这个redis就会将内存中的数据对应的日志，写入aof文件中</p><p>此时aof和rdb两份数据文件的数据就同步了</p><p><strong>注意：</strong>redis config set 热修改配置参数，可能配置文件中的实际的参数没有被持久化的修改，再次停止redis，手动修改配置文件，打开aof的命令，再次重启redis。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
      <tag>持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq学习</title>
    <link href="/2021/01/19/RabbitMq%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/19/RabbitMq%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabbit-MQ-学习【7种工作模式】"><a href="#Rabbit-MQ-学习【7种工作模式】" class="headerlink" title="Rabbit MQ 学习【7种工作模式】"></a>Rabbit MQ 学习【7种工作模式】</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-首先安装Rabbit-MQ"><a href="#1-首先安装Rabbit-MQ" class="headerlink" title="1.首先安装Rabbit MQ"></a>1.首先安装Rabbit MQ</h3><blockquote><p> <strong>教程网址</strong> <a href="https://blog.csdn.net/qq_47588845/article/details/107986373">https://blog.csdn.net/qq_47588845/article/details/107986373</a></p></blockquote><h3 id="2-创建一个springboot项目"><a href="#2-创建一个springboot项目" class="headerlink" title="2.创建一个springboot项目"></a>2.创建一个springboot项目</h3><h3 id="3-导入依赖"><a href="#3-导入依赖" class="headerlink" title="3. 导入依赖"></a>3. 导入依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--lombok--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4-application-properties"><a href="#4-application-properties" class="headerlink" title="4.application.properties"></a>4.application.properties</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">##################</span><span class="hljs-comment">####rabbitmq######</span><span class="hljs-comment">##################</span><span class="hljs-comment">#主机地址</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx</span><span class="hljs-comment">#端口号</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">xxxx </span><span class="hljs-comment">#账号密码</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">xxxx</span><span class="hljs-comment">#密码</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">xxxx</span></code></pre></div><h2 id="一-简单模式-simple"><a href="#一-简单模式-simple" class="headerlink" title="一.简单模式 (simple)"></a>一.简单模式 (simple)</h2><h3 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，一个消费者。 一对一。消息发布者（Publish）将消息放入队列（默认交换机）。消息的消费者（Consumer）监听消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除</p><p><strong>隐患：</strong>消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失,这里可以设置成手动的 ack, 但如果设置成手动 ack，处理完后要及时发送 ack 消息给队列，否则会造成内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/20200103230605348.png" alt="simple模式"></p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p><strong>将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人</strong></p><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）"><a href="#3-1-发布端（Publish）" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类"><a href="#RabbitMQ-配置类" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口"><a href="#消息推送接口" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）"><a href="#3-2-消费端（Consumer）" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><blockquote><p>发送成功后，控制台会打印如下消息</p><p>Sender : hi, fanout msg </p><p>队列queue1 接收的消息 is hi, fanout msg </p></blockquote><h2 id="二-工作模式-work"><a href="#二-工作模式-work" class="headerlink" title="二.工作模式 (work)"></a>二.工作模式 (work)</h2><h3 id="1-要点-1"><a href="#1-要点-1" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，多个消费者，消息被多个消费者竞争接收。 一对多消息产生者将消息放入队列消费者可以有多个，消费者 1, 消费者 2, 同时监听同一个队列，消息被消费。C1 C2 共同争抢当前的消息队列内容，谁先拿到谁负责消费消息</p><p><strong>隐患：</strong>高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关 (syncronize, 与同步锁的性能不一样) 保证一条消息只能被一个消费者使用</p><p><img src="https://img-blog.csdnimg.cn/20200104104835781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="工作模式"></p><h3 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>一个订单的处理需要 10s，有多个订单可以同时放到消息队列，然后让多个消费者同时处理，这样就是并行了，而不是单个消费者的串行情况</p><h3 id="3-代码演示-1"><a href="#3-代码演示-1" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-1"><a href="#3-1-发布端（Publish）-1" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="rabbitMQ配置类"><a href="#rabbitMQ配置类" class="headerlink" title="rabbitMQ配置类"></a>rabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-1"><a href="#消息推送接口-1" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            messageProducer.send();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-1"><a href="#3-2-消费端（Consumer）-1" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/XJloczuLCaQtm6W.png" alt="result1.png"></p><h2 id="三-publish-subscribe：发布订阅-共享资源"><a href="#三-publish-subscribe：发布订阅-共享资源" class="headerlink" title="三. publish/subscribe：发布订阅 (共享资源)"></a>三. publish/subscribe：发布订阅 (共享资源)</h2><h3 id="1-要点-2"><a href="#1-要点-2" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，多个消费者，消息复制多份，每个消费者接收相同的消息。 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200104110859450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="发布订阅模式"></p><h3 id="2-应用场景-2"><a href="#2-应用场景-2" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p><strong>更新商品库存后需要通知多个缓存和多个数据库，这里的结构应该是：</strong></p><ul><li>一个 fanout 类型交换机扇出两个个消息队列，分别为缓存消息队列、数据库消息队列</li><li>一个缓存消息队列对应着多个缓存消费者</li><li>一个数据库消息队列对应着多个数据库消费者</li></ul><h3 id="3-代码演示-2"><a href="#3-代码演示-2" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-2"><a href="#3-1-发布端（Publish）-2" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类-1"><a href="#RabbitMQ-配置类-1" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> &#123;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;fanoutExchange&quot;</span>);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span>(<span class="hljs-params">Queue queue1, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span>(<span class="hljs-params">Queue queue2, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange);    &#125;&#125;</code></pre></div><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchange&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, context);    &#125;&#125;</code></pre></div><h5 id="接口消息推送接口"><a href="#接口消息推送接口" class="headerlink" title="接口消息推送接口"></a>接口消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-2"><a href="#3-2-消费端（Consumer）-2" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-2"><a href="#消息消费者-2" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue2&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/6OQDhpvs43y2RTN.png" alt="result2.png"></p><h2 id="四-路由模式（Routing）"><a href="#四-路由模式（Routing）" class="headerlink" title="四.路由模式（Routing）"></a>四.路由模式（Routing）</h2><h3 id="1-要点-3"><a href="#1-要点-3" class="headerlink" title="1.要点"></a>1.要点</h3><p>​        有选择地（Routing key）接收消息，发送消息到交换机并且要指定路由 key ，消费者将队列绑定到交换机时需要指定路由 key，仅消费指定路由 key 的消息</p><p><img src="https://i.loli.net/2021/01/18/JSeC3wVNFcdxUsK.png" alt="routing.png"></p><h3 id="2-应用场景-3"><a href="#2-应用场景-3" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p>​        如在商品库存中增加了 1 台 iphone12，iphone12 促销活动消费者指定 routing key 为 iphone12，只有此促销活动会接收到消息，其它促销活动不关心也不会消费此 routing key 的消息</p><h3 id="3-代码演示-3"><a href="#3-代码演示-3" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1-发布端"><a href="#3-1-发布端" class="headerlink" title="3.1 发布端"></a>3.1 发布端</h4><h5 id="RabbitMQ配置类"><a href="#RabbitMQ配置类" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.2&quot;</span>);    &#125;    &#125;</code></pre></div><h5 id="消息生产者-2"><a href="#消息生产者-2" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-2"><a href="#消息推送接口-2" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端"><a href="#3-2-消费端" class="headerlink" title="3.2 消费端"></a>3.2 消费端</h4><h5 id="消息消费者-3"><a href="#消息消费者-3" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/JGFDrAOxs7XaeqS.png" alt="result3.png"></p><h2 id="五-主题模式（Topics）"><a href="#五-主题模式（Topics）" class="headerlink" title="五.主题模式（Topics）"></a>五.主题模式（Topics）</h2><h3 id="1-要点-4"><a href="#1-要点-4" class="headerlink" title="1.要点"></a>1.要点</h3><p><img src="https://i.loli.net/2021/01/18/jC5eb47GIqRdcHz.png" alt="topic.png"></p><h3 id="2-应用场景-4"><a href="#2-应用场景-4" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><h3 id="3-代码演示-4"><a href="#3-代码演示-4" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1发布端"><a href="#3-1发布端" class="headerlink" title="3.1发布端"></a>3.1发布端</h4><h5 id="RabbitMQ配置类-1"><a href="#RabbitMQ配置类-1" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.*&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-3"><a href="#消息生产者-3" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-3"><a href="#消息推送接口-3" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2消费端"><a href="#3-2消费端" class="headerlink" title="3.2消费端"></a>3.2消费端</h4><h5 id="消息消费者-4"><a href="#消息消费者-4" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/t586oDyCvkFBlmu.png" alt="result5.png"></p><h2 id="六"><a href="#六" class="headerlink" title="六."></a>六.</h2><p>持续更新中……..</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息中间件</tag>
      
      <tag>Message Queue</tag>
      
      <tag>Rabbit MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析volatile</title>
    <link href="/2021/01/16/%E6%B5%85%E6%9E%90volatile/"/>
    <url>/2021/01/16/%E6%B5%85%E6%9E%90volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="浅析volatile"><a href="#浅析volatile" class="headerlink" title="浅析volatile"></a>浅析volatile</h2><h3 id="为什么引入volatile"><a href="#为什么引入volatile" class="headerlink" title="为什么引入volatile"></a>为什么引入volatile</h3><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>举个例子，比如说有两个线程，他们的代码里都需要读取data这个变量的值，那么他们都会从主内存里加载data变量的值到自己的工作内存，然后才可以使用那个值。好了，现在大家从图里看到，每个线程都把data这个变量的副本加载到了自己的工作内存里了，所以每个线程都可以读到data = 0这个值。</p><p>这样，在线程代码运行的过程中，对data的值都可以直接从工作内存里加载了，不需要再从主内存里加载了。</p></blockquote><p>为啥一定要让每个线程用一个工作内存来存放变量的副本以供读取呢？直接让线程每次都从主内存加载变量的值不行吗？</p><blockquote><p>因为线程运行的代码对应的是一些指令，是由CPU执行的！CPU每次执行指令运算的时候，每次需要一个变量的值，都从主内存加载，性能会比较差。</p><p>所以说后来，就是提出了线程工作内存的概念，类似于一个<strong>高速的本地缓存。</strong>这样一来，线程的代码在执行过程中，就可以直接从自己本地缓存里加载变量副本，不需要从主内存加载变量值，性能可以提升很多！</p></blockquote><p>思考：这种方法性能是提升了，但是会带来其他的问题么？</p><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>如上图：有两个线程，两个线程都需要data变量，都将变量的副本加载到了自己的工作内存。假如这时线程1需要修改data变量的值为1，修改完之后将这个修改写入自己的本地工作内存。如下图</p></blockquote><p><img src="https://i.loli.net/2021/01/17/wseOE28YBFnpZH6.png" alt="volatile1.png"></p><blockquote><p>那么此时，线程1的工作内存里的data值为1，但是，主内存以及线程2里的data值还是为0。那么接下来，在线程1的代码运行过程中，他可以直接读到data最新的值是1，但是线程2的代码运行过程中读到的data的值还是0。这就不符合逻辑了。</p></blockquote><p>上述问题就是：<strong>java并发编程中的可见性问题:</strong></p><p><strong>多个线程并发读写一个共享变量的时候，某个线程修改了共享变量的值，其他线程看不到，即对其他线程不可见。</strong></p><h3 id="引入volatile"><a href="#引入volatile" class="headerlink" title="引入volatile"></a>引入volatile</h3><blockquote><p>那如果要解决这个问题怎么办呢？这时就轮到<strong>volatile</strong>闪亮登场了！你只要给data这个变量在定义的时候加一个volatile，就直接可以完美的解决这个可见性的问题。</p></blockquote><p>比如下面的这样的代码，在加了volatile之后，会有啥作用呢？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 启用两个线程，一个线程会读取和修改data的值，一个线程会读取data的值</span></code></pre></div><ul><li><p>第一，一旦data变量定义的时候前面加了volatile来修饰的话，那么线程1只要修改data变量的值，就会在修改完自己本地工作内存的data变量值之后，强制将这个data变量最新的值刷回主内存，必须让主内存里的data变量值立马变成最新的值！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/R3dQ5fkvtGhZHCu.png" alt="volatile2.png"></p></li><li><p>第二，如果此时别的线程的工作内存中有这个data变量的本地缓存，也就是一个变量副本的话，那么会强制让其他线程的工作内存中的data变量缓存直接失效过期，不允许再次读取和使用了！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/Zh2f3Kmq8dxE1u6.png" alt="volatile3.png"></p></li></ul><ul><li><p>第三，如果线程2在代码运行过程中再次需要读取data变量的值，此时尝试从本地工作内存中读取，就会发现这个data = 0已经过期了！此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了！</p><p><strong>整个过程，参见下图：</strong></p><p><img src="https://i.loli.net/2021/01/17/CyEIxFn1TQOWa39.png" alt="volatile4.png"></p></li><li><p>至此，volatile完美解决了java并发中可见性的问题！对一个变量加了volatile关键字修饰之后，只要一个线程修改了这个变量的值，立马强制刷回主内存。接着强制过期其他线程的本地工作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！这样就保证，任何一个线程修改了变量值，其他线程立马就可以看见了。这就是所谓的volatile保证了可见性的工作原理。</p></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>注意：volatile主要作用是保证可见性以及有序性。volatile是不能保证原子性的！，原子性问题，得依赖synchronized、ReentrantLock等加锁机制来解决。</strong></p><blockquote><p>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</p><p>如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程------创建多线程的三种方式</title>
    <link href="/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程——创建多线程的三种方式"><a href="#多线程——创建多线程的三种方式" class="headerlink" title="多线程——创建多线程的三种方式"></a>多线程——创建多线程的三种方式</h2><h3 id="创建一个继承于java-lang-Thread的类"><a href="#创建一个继承于java-lang-Thread的类" class="headerlink" title="创建一个继承于java.lang.Thread的类"></a>创建一个继承于java.lang.Thread的类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>  + Thread.currentThread().getId());&#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 创建自定义线程</span>MyThread1 myThread1 = <span class="hljs-keyword">new</span> MyThread1();<span class="hljs-comment">// 开启线程</span>myThread1.start();&#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">123456789101112131415161718</span></code></pre></div><h3 id="实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装"><a href="#实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装" class="headerlink" title="实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装"></a>实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>     + Thread.currentThread().getId());   &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-comment">// 创建MyRunnable</span>   MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();   <span class="hljs-comment">// 用Thread 包装一下myRunnable</span>   Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);   <span class="hljs-comment">// 开启线程</span>   thread.start();   &#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">1234567891011121314151617181920</span></code></pre></div><blockquote><ol><li>这两种方式实现多线程的方式都是围绕着Thread类展开的，第一种方式实现线程是继承于java.lang.Thread类，然后实现run方法，最终调用Thread类中的start方法启动线程。而实现Runnable接口，则是把run写到了接口中，并由实现类实现run方法，然后再用Thread类对Runnable接口进行包装，然后在调用Thread中start方法启动线程。①②两种方式都是最终都是调用Thread中start方法进行启动线程。</li><li>两种方式在本质上没有明显的区别，但是在外观上有很大的区别，第一种方式是继承Thread类，由于Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就建议使用第二种方式。</li></ol></blockquote><h3 id="实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装"><a href="#实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装" class="headerlink" title="实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装"></a>实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tstarting...&quot;</span>);       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;           sum += i;       &#125;       Thread.sleep(<span class="hljs-number">5000</span>);       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tover...&quot;</span>);       <span class="hljs-keyword">return</span> sum;   &#125;&#125;<span class="hljs-comment">// 测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;   MyCallable myCallable = <span class="hljs-keyword">new</span> MyCallable();   <span class="hljs-comment">// 将Callable包装成FutureTask，FutureTask也是一种Runnable</span>   FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myCallable);   Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);   thread.start();   <span class="hljs-comment">// get方法会阻塞调用的线程</span>   Integer res = futureTask.get();   System.out.println(<span class="hljs-string">&quot;线程执行结果：&quot;</span>+res);   &#125;&#125;<span class="hljs-comment">//Thread-010Wed Apr 15 15:32:38 CST 2020 starting...</span><span class="hljs-comment">//Thread-010Wed Apr 15 15:32:43 CST 2020 over...</span><span class="hljs-comment">//线程执行结果：5050</span><span class="hljs-number">123456789101112131415161718192021222324252627282930</span></code></pre></div><h4 id="三种方式比较："><a href="#三种方式比较：" class="headerlink" title="三种方式比较："></a>三种方式比较：</h4><ul><li>Thread: 继承方式, 不建议使用, 因为Java是单继承的，继承了Thread就没办法继承其它类了，不够灵活</li><li>Runnable: 实现接口，比Thread类更加灵活，没有单继承的限制</li><li>Callable: Thread和Runnable都是重写的run()方法并且没有返回值，Callable是重写的call()方法并且有返回值并可以借助FutureTask类来判断线程是否已经执行完毕或者取消线程执行</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>当线程不需要返回值时使用Runnable，需要返回值时就使用Callable，一般情况下不直接把线程体代码放到Thread类中，一般通过Thread类来启动线程</li><li>Thread类是实现Runnable，</li><li>Callable封装成FutureTask，FutureTask实现RunnableFuture，RunnableFuture继承Runnable，所以Callable也算是一种Runnable，</li><li>所以三种实现方式本质上都是对Runnable实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列【解耦、异步、削峰】</title>
    <link href="/2021/01/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/"/>
    <url>/2021/01/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列作用【解耦、异步、削峰】"><a href="#消息队列作用【解耦、异步、削峰】" class="headerlink" title="消息队列作用【解耦、异步、削峰】"></a>消息队列作用【解耦、异步、削峰】</h1><blockquote><p>学习消息队列的笔记</p></blockquote><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://i.loli.net/2021/01/19/CfQSvH6btWscTle.png" alt="mq.png"></p><ul><li>MQ 全称为 <code>Message Queue</code>, 消息队列（MQ）<code>是一种应用程序对应用程序的通信方法</code>。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</li><li>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</li><li>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合</strong>，<strong>异步消息</strong>，<strong>流量削锋</strong>等问题</li></ul><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现有一个系统 A 要与其他系统（BCD）打交道（即调用其中的方法，推送的元数据一样）如下图</p><h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://i.loli.net/2021/01/19/6ubPkKTeQCAlYn2.png" alt="mq_1.png"></p><p>系统运行了一段时间后，D系统不需要A系统推送数据了，同时又新增加了一个E系统需要A系统推送数据，如下图</p><p><img src="https://i.loli.net/2021/01/19/4GzdOlYFSrvRHZx.png" alt="mq_2.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果其它系统改变或者新增系统，那么 A 系统都会改变，这样的话耦合度比较高，比较麻烦,在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？。</p><h3 id="消息队列解耦"><a href="#消息队列解耦" class="headerlink" title="消息队列解耦"></a>消息队列解耦</h3><p>使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://i.loli.net/2021/01/19/WhMGblrtjYzKdRU.png" alt="mq_3.png"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><blockquote><p>用户注册后，需要发注册邮件和注册短信</p></blockquote><h3 id="传统模式-1"><a href="#传统模式-1" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h4><h5 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h5><p><img src="https://i.loli.net/2021/01/19/fQGWLHUCo4Zl9i2.png" alt="mq_5.png"></p><p><strong>响应时间150ms</strong></p><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p><img src="https://i.loli.net/2021/01/19/UmYfDwJpGaZTSie.png" alt="mq_4.png"></p><p><strong>响应时间100ms</strong></p><h3 id="消息队列优化"><a href="#消息队列优化" class="headerlink" title="消息队列优化"></a>消息队列优化</h3><p><img src="https://i.loli.net/2021/01/19/lU2Q9BxNcCDFt6a.png" alt="mq_6.png"></p><p><strong>响应时间55ms</strong></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式【Java】</title>
    <link href="/2021/01/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90Java%E3%80%91/"/>
    <url>/2021/01/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90Java%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong>。</p></blockquote><p><strong>注意：</strong></p><ul><li><p>单例类只能有一个实例。</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p></li></ul><p>为什么使用单例设计模式</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点对象</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h2 id="单例设计模式8-种方法"><a href="#单例设计模式8-种方法" class="headerlink" title="单例设计模式8 种方法"></a>单例设计模式8 种方法</h2><ol><li><strong>饿汉式（静态常量）</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="单例设计模式具体实现"><a href="#单例设计模式具体实现" class="headerlink" title="单例设计模式具体实现"></a>单例设计模式具体实现</h3><h4 id="1-）饿汉式（静态常量）实例"><a href="#1-）饿汉式（静态常量）实例" class="headerlink" title="1 ）饿汉式（静态常量）实例"></a>1 ）饿汉式（静态常量）实例</h4><p> <strong>代码实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">// 公开一个方法，获得唯一实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true </span><span class="hljs-comment">    singleton.hashCode: 366712642 </span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：这种方式写法简单，在类装载的时候就完成实例化，避免了线程同步问题</li><li>缺点：在类装载的时候就完成实例化，没有达到<strong>Lazy Loading 懒加载</strong> 的效果，如果从始至终未使用过这个类，则会造成内存的浪费。（<strong>懒加载的意思就是什么时候用什么时候才加载</strong>）</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="2-）饿汉式（静态代码块）实例"><a href="#2-）饿汉式（静态代码块）实例" class="headerlink" title="2 ）饿汉式（静态代码块）实例"></a><strong>2 ）饿汉式（静态代码块）实例</strong></h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance;<span class="hljs-comment">//  在静态代码块中 进行初始化</span><span class="hljs-keyword">static</span>&#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优缺点与上面一样</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="3-）懒汉式（线程不安全）实例"><a href="#3-）懒汉式（线程不安全）实例" class="headerlink" title="3 ）懒汉式（线程不安全）实例"></a>3 ）懒汉式（线程不安全）实例</h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest02</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式1 线程不安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程不安全）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式1 线程不安全</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优点：实现了<strong>Lazy Loading 懒加载</strong> 的效果</p></li><li><p>缺点：只能在单线程下使用，如果进入了多线程，<code>if(singletonInstance == null) </code>语句还未来得及向下执行，另一个线程也通过了这个判断语句，<strong>会导致产生多个实例，因此在严格意义上它并属于单例设计模式</strong>。在多线程下不能使用这种方式</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式。</p></li></ol><h4 id="4-）懒汉式（线程安全-同步方法）实例"><a href="#4-）懒汉式（线程安全-同步方法）实例" class="headerlink" title="4 ）懒汉式（线程安全 同步方法）实例"></a>4 ）懒汉式（线程安全 同步方法）实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest01</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式2  线程安全 同步方法&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步方法）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-comment">//利用synchronized修饰getInstance方法，使之变为同步方法 懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式2  线程安全 同步方法</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：解决了线程安全的问题</li><li>缺点：<strong>效率太低</strong>，每个线程想要执行getInstance()方法时，<strong>都要进行同步</strong>，实际上这个方法<strong>只执行一次实例化</strong>就够了，之后就直接return 实例就好了，<strong>方法进行同步效率太低</strong></li><li>结论：在实际开发中<strong>不推荐</strong>这种方式。</li></ol><h4 id="5-）懒汉式（线程不安全-同步代码块）实例"><a href="#5-）懒汉式（线程不安全-同步代码块）实例" class="headerlink" title="5 ）懒汉式（线程不安全 同步代码块）实例"></a>5 ）懒汉式（线程不安全 同步代码块）实例</h4><p>有的人也许会认为把上面同步方法换成同步代码块就可以了：如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式3 线程不安全 同步代码块&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步代码块）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 在这里设置静态代码块  并不能解决同步问题 所以这种方法不可以</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式3 线程不安全 同步代码块</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优缺点与 3） 一样</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式</p></li></ol><h4 id="6）双重检查-实例"><a href="#6）双重检查-实例" class="headerlink" title="6）双重检查 实例"></a>6）双重检查 实例</h4><p>  <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;双重检查  线程安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125; <span class="hljs-comment">// 双重检查</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> 1.volatile</span><span class="hljs-comment"> volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的         优化而省略。</span><span class="hljs-comment">2.volatile 的特性</span><span class="hljs-comment">保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程 来说是立即可见的,(即实时刷新)。（实现可见性） 禁止进行指令重排序。（实现有序性）</span><span class="hljs-comment">volatile 只能保证对单次读 / 写的原子性。i++ 这种操作不能保证原子性。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 创建一个私有的静态变量 并用volatile修饰</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 加入双重检查的代码 解决线程安全 以及懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 第一次判断  如果实例化直接返回 否则进行实例化</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 设置静态代码块  保证每次只能进入一个线程</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">// 第二次判断 保证只能实例化一次</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">双重检查  线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：双重检查（double-check） 概念时多线程开发中经常用到的，在代码中我们进行了两次<code>if(singletonInstance == null)</code>判断，解决了线程安全问题</li><li>第一个线程调用完getInstance方法后，其他的线程在第一层判断时，就会直接返回实例，避免反复进入同步代码块，解决了效率问题</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="7）静态内部类-实例"><a href="#7）静态内部类-实例" class="headerlink" title="7）静态内部类 实例"></a>7）静态内部类 实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;静态内部类  线程安全 懒加载&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-comment">// 原因：</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    在Singleton进行装载的时候 其静态内部类不进行装载，等到getInstance方法返回静态内部类中</span><span class="hljs-comment">    常量时静态内部类才进行装载，其常量才进行实例化，且装载过程为线程安全，并实现了懒加载。</span><span class="hljs-comment">    */</span><span class="hljs-comment">//创建静态内部类，利用其特性 实现线程安全，以及懒加载</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法 获得实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">静态内部类  线程安全 懒加载</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>在Singleton进行装载的时候 其<strong>静态内部类SingletonInstance并不进行装载</strong>，等到需要实例化时调用getInstance方法时，<strong>静态内部类SingletonInstance才进行装载</strong>，完成<strong>Singleton类的实例化</strong>，类的静态属性，只有在第一次装载类的时候进行初始化，JVM帮我们实现了<strong>线程的安全性</strong>，并实现了懒加载。</li><li>优点： 避免了线程的不安全，利用静态类实现延迟加载，效率高。</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="8-）枚举-实例"><a href="#8-）枚举-实例" class="headerlink" title="8 ）枚举 实例"></a>8 ）枚举 实例</h4><p><strong>代码展示：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;JDK1.5 枚举 线程安全&quot;</span>);Singleton singleton = Singleton.INSTANCE;Singleton singleton1 = Singleton.INSTANCE;System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类，实现单例</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;INSTANCE;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">JDK1.5 枚举 线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p></li><li><p>结论：推荐使用</p></li></ol><h2 id="破坏单例模式的方法及解决办法"><a href="#破坏单例模式的方法及解决办法" class="headerlink" title="破坏单例模式的方法及解决办法"></a>破坏单例模式的方法及解决办法</h2><p>1、除枚举方式外，其他方法都会通过反射的方式破坏单例，反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例，则阻止生成新的实例，解决办法如下:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonObject1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span> (instance !=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);    &#125;&#125;</code></pre></div><p>2、如果单例类实现了序列化接口 Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口，如果非得实现序列化接口，可以重写反序列化方法 readResolve (), 反序列化时直接返回相关单例对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-1</title>
    <link href="/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></blockquote><h3 id="分类及关系"><a href="#分类及关系" class="headerlink" title="分类及关系"></a>分类及关系</h3><h4 id="设计模式三大类"><a href="#设计模式三大类" class="headerlink" title="设计模式三大类"></a>设计模式三大类</h4><ul><li><p><strong>创建型模式【共五种】</strong> </p><p>工厂方法模式；抽象工厂模式；单例模式；建造者模式；原型模式。</p></li><li><p><strong>结构型模式【共七种】</strong></p><p>适配器模式；装饰器模式；代理模式；外观模式；桥接模式；组合模式；享元模式。</p></li><li><p><strong>行为型模式【共十一种】</strong></p><p>策略模式；模板方法模式；观察者模式；迭代子模式；责任链模式；命令模式；备忘录模式；状态模式；访问者模式；中介者模式；解释器模式</p></li></ul><h4 id="设计模式关系"><a href="#设计模式关系" class="headerlink" title="设计模式关系"></a>设计模式关系</h4><p><img src="https://i.loli.net/2021/01/11/ZKbFWYMqUmBS8uk.jpg" alt="designPattern.jpg"></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则 (Liskov Substitution Principle LSP) 面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对 “开 - 闭” 原则的补充。实现 “开 - 闭” 原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>原则是尽量使用合成 / 聚合的方式，而不是使用继承。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>开闭原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/01/09/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/01/09/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KMP 算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回 - 1（常用手段）。</p><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p><h3 id="kMP解决的问题"><a href="#kMP解决的问题" class="headerlink" title="kMP解决的问题"></a>kMP解决的问题</h3><p>现在有一个字符串为源字符串S,现在给你个目标字符串T，问T是否在S中存在。(下图中：上面的为S，下面的为T)</p><p><img src="https://i.loli.net/2021/01/09/qkFvCIet4xJjQgn.png" alt="kmp1.png"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><strong>遍历两个字符串</strong></p><ul><li>首先，定义两个指针i，j初始化为0</li></ul><p><img src="https://i.loli.net/2021/01/09/yB9nEYl2mROLqPS.png" alt="kmp2.png"></p><ul><li>如果i 指向的字符和 j 指向的字符一致，i和j向后移动。</li></ul><p><img src="https://i.loli.net/2021/01/09/cREG9gWDKoX3HPn.png" alt="kmp3.png"></p><ul><li>不相等，那就把 i 指针移回第 1 位（假设下标从 0 开始），j 移动到模式串的第 0 位：</li></ul><p><img src="https://i.loli.net/2021/01/09/MK4zQx1tJOmVX5h.png" alt="kmp4.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matching</span><span class="hljs-params">(String src, String pattern)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = src.length();    <span class="hljs-keyword">int</span> len2 = pattern.length();    <span class="hljs-comment">// 主串的长度小于模式串的长度时直接返回-1，说明不存在</span>    <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 主串中剩下未匹配的字符的大小&gt;=模式串的长度才继续进行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; len1 - i &gt;= len2; i++) &#123;        <span class="hljs-keyword">int</span> temp = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pattern.length(); j++) &#123;            <span class="hljs-comment">// 对照第2步</span>            <span class="hljs-keyword">if</span> (src.charAt(temp++) == pattern.charAt(j)) &#123;                <span class="hljs-comment">// pattern 数组遍历到结尾说明找到匹配的</span>                <span class="hljs-keyword">if</span> (j == pattern.length() - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// i - len2 是模式串在源串中的起始位置</span>                    <span class="hljs-keyword">return</span> i;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 不等就跳出循环 对标第三步</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://i.loli.net/2021/01/10/p3cQJqNFy4AEWHZ.gif" alt="kmp5.gif"></p><blockquote><p>如上图，在暴力求解时，每当发现字符不匹配时，主串i需要回溯，模式串的j也要回溯，这极大的影响了搜索效率。</p></blockquote><h3 id="KMP求解法"><a href="#KMP求解法" class="headerlink" title="KMP求解法"></a>KMP求解法</h3><h4 id="KMP是如何消除指针回溯问题的"><a href="#KMP是如何消除指针回溯问题的" class="headerlink" title="KMP是如何消除指针回溯问题的"></a>KMP是如何消除指针回溯问题的</h4><p>未完待续。。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/2JhlgDr1yqjCcaA.gif" alt="selectionSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = src.length;    <span class="hljs-comment">// 比较 len - 1 词</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 记录当前下标，作为之后比较使用</span>        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-comment">// 找出最小的元素,需要比较 len - 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &lt; src[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 如果最小元素下标发生改变，则交换</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            <span class="hljs-keyword">int</span> temp = src[i];            src[i] = src[min];            src[min] = temp;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。在剩下的n-1个元素中重复此操作，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。至此排序完成</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://uploader.shimo.im/f/DhBMiGl0vTmIAGGk.gif" alt="bubble"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &gt;= src[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> temp = src[j];                src[j] = src[j+<span class="hljs-number">1</span>];                src[j+<span class="hljs-number">1</span>] = temp;                flag = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从数列中挑出一个元素，称为 “基准”（pivot）;<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/ipdOu3qA8lxTf2M.gif" alt="quickSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    quickProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        swap(arr, left + ((<span class="hljs-keyword">int</span>) Math.random() * (right - left + <span class="hljs-number">1</span>)), right);        <span class="hljs-keyword">int</span>[] p = partation(arr, left, right);        quickProcess(arr, left, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);        quickProcess(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partation(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">int</span> less = left - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> more = right;    <span class="hljs-keyword">int</span> base = arr[right];    <span class="hljs-keyword">while</span> (left &lt; more) &#123;        <span class="hljs-keyword">if</span> (arr[left] &lt; base) &#123;            swap(arr, ++less, left++);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] &gt; base) &#123;            swap(arr, --more, left);        &#125; <span class="hljs-keyword">else</span> &#123;            left++;        &#125;    &#125;    swap(arr, more, right);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = arr[index1];    arr[index1] = arr[index2];    arr[index2] = temp;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码解析-JDK1-8"><a href="#HashMap源码解析-JDK1-8" class="headerlink" title="HashMap源码解析(JDK1.8)"></a>HashMap源码解析(JDK1.8)</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在进行HashMap分析前，我期望解决以下问题：</p><ul><li>HashMap的底层数据结构是什么？</li><li>HashMap中增删改查操作的底部实现原理是什么？</li><li>HashMap是如何实现扩容的？</li><li>HashMap是如何解决hash冲突的？</li><li>HashMap为什么是非线程安全的？</li></ul><h3 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h3><p>HashMap 基于哈希表的 Map 接口的实现，key唯一的value可以重复，允许存储键为null(key = null),值为null(value = null)，元素没有顺序,同时不保证该顺序恒久不变。</p><p>在 JDK 1.8 之前是由“数组+链表”组成。JDK1.8的HashMap对之前做了较大的优化，其中最重要的一个优化就是将底层的数据结构由“数组+链表”变为了“数组+链表+红黑树”，值得一提的是只有当链表的长度大于8时.。除此之外HashMap是非线程安全的，因此在多个线程同时对HashMap中的同一个元素进行修改时，不能保证数据的唯一性。</p><h3 id="剖析结构"><a href="#剖析结构" class="headerlink" title="剖析结构"></a>剖析结构</h3><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p><img src="https://i.loli.net/2021/01/07/femFXPH2T8N5ZMv.png" alt="DataStruct1.7.png"></p><p>从上图我们可以看到，在jdk1.7中，首先是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，因为Entry具有Next引用，每一个Entry实体类实际上是一个单向的链表的头部，可以用来连接下一个Entry实体，又因为HashMap是按照Key的hash值来计算Entry在HashMap中存储的位置的，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。就这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高<strong>（链表不适合查找，适合增删）</strong>，反倒是下降了不少。</p><p>于是官方在JDK1.8的时候就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。</p><p><img src="https://i.loli.net/2021/01/07/1Qv4fyFu8rlpzXE.png" alt="DataStruct1.8.png"></p><p><strong>注意：</strong> <strong>要注意的是只有在链表的长度不小于8，且数组的长度不小于64的时候才会将链表转化为红黑树，</strong></p><h4 id="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"><a href="#这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。" class="headerlink" title="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"></a><strong>这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。</strong></h4><p><strong>因为：红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找一个元素的时间复杂度会从链表的o(n)降低为o(logn)。</strong></p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>源码</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4、重复步骤 3 直到某一指针达到序列尾；<br>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/WbeJEpiD9usgR31.gif" alt="mergeSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 排序入口函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    sortProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 分治</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (right == left) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 归并左边</span>    sortProcess(arr, left, mid);    <span class="hljs-comment">// 归并右边</span>    sortProcess(arr, mid + <span class="hljs-number">1</span>, right);    merge(arr, left, mid, right);&#125;<span class="hljs-comment">// 合并</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 辅助数组 开始下标</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = left;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 合并两个数组</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 两个指针必有一个未过界 需要处理</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) &#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= right) &#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 拷贝给原数组</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[left + i] = help[i];    &#125;&#125;</code></pre></div><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度:O(nlogn)</li><li>空间复杂度:O(N) 需要一个与排序数组长度相同的数组，进行辅助排序</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>归并排序是一个稳定的排序，只需在合并方法中，合并两个数组时用这行代码<code> help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]</code>,可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架【IOC四种依赖注入】</title>
    <link href="/2020/10/22/Spring%E6%A1%86%E6%9E%B6%E3%80%90IOC%E5%9B%9B%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%91/"/>
    <url>/2020/10/22/Spring%E6%A1%86%E6%9E%B6%E3%80%90IOC%E5%9B%9B%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring-IOC-四种依赖注入"><a href="#Spring-IOC-四种依赖注入" class="headerlink" title="Spring IOC 四种依赖注入"></a>Spring IOC 四种依赖注入</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>1、创建一个Maven工程</p><p>2、创建一个实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-keyword">private</span> Integer id;<span class="hljs-keyword">private</span> String userName;<span class="hljs-keyword">private</span> String password;<span class="hljs-keyword">private</span> String note;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;<span class="hljs-keyword">this</span>.userName = userName;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;<span class="hljs-keyword">this</span>.password = password;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setNote</span><span class="hljs-params">(String note)</span> </span>&#123;<span class="hljs-keyword">this</span>.note = note;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;    <span class="hljs-comment">//注意 ：toString,get方法自行实现，</span>&#125;<span class="hljs-number">123456789101112131415161718192021222324</span></code></pre></div><p>3、引入pom依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>12345</code></pre></div><p>4、在src/main/java中创建beans.xml，并写入如下内容</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h4 id="一、静态工厂"><a href="#一、静态工厂" class="headerlink" title="一、静态工厂"></a>一、静态工厂</h4><p>1、首先创建一个静态工厂UserFactory</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> User user;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;user = <span class="hljs-keyword">new</span> User();user.setId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;王五&quot;</span>).setPassword(<span class="hljs-string">&quot;hwy499&quot;</span>).setNote(<span class="hljs-string">&quot;无&quot;</span>);&#125;<span class="hljs-keyword">return</span> user;&#125;&#125;</code></pre></div><p>2、在Beans.xml文件中配置该静态工厂</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span>       <span class="hljs-comment">&lt;!-- factory-method : 获得对象的静态方法名 class:静态工厂类的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.factory.UserFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span>  <span class="hljs-attr">id</span> =<span class="hljs-string">&quot;userFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);        <span class="hljs-comment">// 获得实例</span>User user = cpac.getBean(<span class="hljs-string">&quot;userFactory&quot;</span>, User.class);        <span class="hljs-comment">// 打印</span>System.out.println(user);         <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="二、实例工厂注入"><a href="#二、实例工厂注入" class="headerlink" title="二、实例工厂注入"></a>二、实例工厂注入</h4><p>1、创建一个工厂类UserFactory</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<span class="hljs-keyword">private</span> User user;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;user = <span class="hljs-keyword">new</span> User();user.setId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;王五&quot;</span>).setPassword(<span class="hljs-string">&quot;hwy499&quot;</span>).setNote(<span class="hljs-string">&quot;无&quot;</span>);&#125;<span class="hljs-keyword">return</span> user;&#125;&#125;</code></pre></div><p>2、在beans.xml中配置工厂类的实例</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.factory.UserFactory&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;userFactory&quot;</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);          <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="三、Set-方法注入"><a href="#三、Set-方法注入" class="headerlink" title="三、Set 方法注入"></a>三、Set 方法注入</h4><p>1、在beans.xml中进行如下配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过set方法注入 为什么这种方法叫做通过set方法注入呢？</span><span class="hljs-comment">这个跟我们在property标签中添加的name有关，在property中添加的name</span><span class="hljs-comment">并不是我们实体类中的属性名，而是我们在其中添加的set方法中set之后的名字，</span><span class="hljs-comment">假如我们现在实体类中有一个属性叫name，而它对应的set方法为setUserName,</span><span class="hljs-comment">那么我就要在property标签中添加name=&quot;username&quot;,而不是name=&quot;name&quot;</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456123&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;note&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是一个备注&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>2、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);          <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="四、通过构造方法注入"><a href="#四、通过构造方法注入" class="headerlink" title="四、通过构造方法注入"></a>四、通过构造方法注入</h4><p>1、在实体类添加构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//无参构造函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String userName, String password, String note)</span> </span>&#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">this</span>.id = id;    <span class="hljs-keyword">this</span>.userName = userName;    <span class="hljs-keyword">this</span>.password = password;    <span class="hljs-keyword">this</span>.note = note;&#125;</code></pre></div><p>2、在bens.xml中添加如下配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;note&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--或是--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--在或是 此时要注意先后问题，此时是按照你的构造函数的参数顺序依次赋值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);         <span class="hljs-comment">// User [id=1, userName=李四, password=123456, note=无备注消息]</span>&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>spring</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
