<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅析Vvolatile</title>
    <link href="/2021/01/16/%E6%B5%85%E6%9E%90volatile/"/>
    <url>/2021/01/16/%E6%B5%85%E6%9E%90volatile/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程------创建多线程的三种方式</title>
    <link href="/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程——创建多线程的三种方式"><a href="#多线程——创建多线程的三种方式" class="headerlink" title="多线程——创建多线程的三种方式"></a>多线程——创建多线程的三种方式</h2><h3 id="创建一个继承于java-lang-Thread的类"><a href="#创建一个继承于java-lang-Thread的类" class="headerlink" title="创建一个继承于java.lang.Thread的类"></a>创建一个继承于java.lang.Thread的类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>  + Thread.currentThread().getId());&#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 创建自定义线程</span>MyThread1 myThread1 = <span class="hljs-keyword">new</span> MyThread1();<span class="hljs-comment">// 开启线程</span>myThread1.start();&#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">123456789101112131415161718</span></code></pre></div><h3 id="实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装"><a href="#实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装" class="headerlink" title="实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装"></a>实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>     + Thread.currentThread().getId());   &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-comment">// 创建MyRunnable</span>   MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();   <span class="hljs-comment">// 用Thread 包装一下myRunnable</span>   Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);   <span class="hljs-comment">// 开启线程</span>   thread.start();   &#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">1234567891011121314151617181920</span></code></pre></div><blockquote><ol><li>这两种方式实现多线程的方式都是围绕着Thread类展开的，第一种方式实现线程是继承于java.lang.Thread类，然后实现run方法，最终调用Thread类中的start方法启动线程。而实现Runnable接口，则是把run写到了接口中，并由实现类实现run方法，然后再用Thread类对Runnable接口进行包装，然后在调用Thread中start方法启动线程。①②两种方式都是最终都是调用Thread中start方法进行启动线程。</li><li>两种方式在本质上没有明显的区别，但是在外观上有很大的区别，第一种方式是继承Thread类，由于Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就建议使用第二种方式。</li></ol></blockquote><h3 id="实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装"><a href="#实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装" class="headerlink" title="实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装"></a>实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tstarting...&quot;</span>);       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;           sum += i;       &#125;       Thread.sleep(<span class="hljs-number">5000</span>);       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tover...&quot;</span>);       <span class="hljs-keyword">return</span> sum;   &#125;&#125;<span class="hljs-comment">// 测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;   MyCallable myCallable = <span class="hljs-keyword">new</span> MyCallable();   <span class="hljs-comment">// 将Callable包装成FutureTask，FutureTask也是一种Runnable</span>   FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myCallable);   Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);   thread.start();   <span class="hljs-comment">// get方法会阻塞调用的线程</span>   Integer res = futureTask.get();   System.out.println(<span class="hljs-string">&quot;线程执行结果：&quot;</span>+res);   &#125;&#125;<span class="hljs-comment">//Thread-010Wed Apr 15 15:32:38 CST 2020 starting...</span><span class="hljs-comment">//Thread-010Wed Apr 15 15:32:43 CST 2020 over...</span><span class="hljs-comment">//线程执行结果：5050</span><span class="hljs-number">123456789101112131415161718192021222324252627282930</span></code></pre></div><h4 id="三种方式比较："><a href="#三种方式比较：" class="headerlink" title="三种方式比较："></a>三种方式比较：</h4><ul><li>Thread: 继承方式, 不建议使用, 因为Java是单继承的，继承了Thread就没办法继承其它类了，不够灵活</li><li>Runnable: 实现接口，比Thread类更加灵活，没有单继承的限制</li><li>Callable: Thread和Runnable都是重写的run()方法并且没有返回值，Callable是重写的call()方法并且有返回值并可以借助FutureTask类来判断线程是否已经执行完毕或者取消线程执行</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>当线程不需要返回值时使用Runnable，需要返回值时就使用Callable，一般情况下不直接把线程体代码放到Thread类中，一般通过Thread类来启动线程</li><li>Thread类是实现Runnable，</li><li>Callable封装成FutureTask，FutureTask实现RunnableFuture，RunnableFuture继承Runnable，所以Callable也算是一种Runnable，</li><li>所以三种实现方式本质上都是对Runnable实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq学习</title>
    <link href="/2021/01/13/RabbitMq%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/13/RabbitMq%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabbit-MQ-学习【7种工作模式】"><a href="#Rabbit-MQ-学习【7种工作模式】" class="headerlink" title="Rabbit MQ 学习【7种工作模式】"></a>Rabbit MQ 学习【7种工作模式】</h1><h2 id="一-simple：简单模式"><a href="#一-simple：简单模式" class="headerlink" title="一. simple：简单模式"></a>一. simple：简单模式</h2><h3 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，一个消费者。 一对一</p></blockquote><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="https://img-blog.csdnimg.cn/20200103230605348.png" alt="simple模式"></p><blockquote><p>消息发布者（Publish）将消息放入队列（默认交换机）。<br>消息的消费者（Consumer）监听消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除（隐患：消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失,这里可以设置成手动的 ack, 但如果设置成手动 ack，处理完后要及时发送 ack 消息给队列，否则会造成内存溢出）。</p><p>应用场景：聊天（中间有一个过度的服务器；P端，C端）。</p></blockquote><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）"><a href="#3-1-发布端（Publish）" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><blockquote><p>RabbitMQConfig.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义简单队列名.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String simpleQueue = <span class="hljs-string">&quot;simple_queue&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">simpleQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(simpleQueue);    &#125;&#125;<span class="hljs-comment">//https://blog.csdn.net/weixin_45393094/article/details/106160234</span></code></pre></div><blockquote><p>IMessageService.java </p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息服务接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMessageService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 推送消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span></span>;&#125;</code></pre></div><blockquote><p>MessageServiceImpl</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息服务接口实现类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMessageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span> </span>&#123;        String messageId = String.valueOf(UUID.randomUUID());        String createTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;messageId&quot;</span>, messageId);        map.put(<span class="hljs-string">&quot;messageData&quot;</span>, message);        map.put(<span class="hljs-string">&quot;createTime&quot;</span>, createTime);        <span class="hljs-comment">// 发送消息到rabbit服务器</span>        rabbitTemplate.convertAndSend(RabbitMQConfig.simpleQueue, map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><blockquote><p>MessageController.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    IMessageService messageService;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 调用服务推送消息</span>        messageService.pushMessage(<span class="hljs-string">&quot;123456&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）"><a href="#3-2-消费端（Consumer）" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><blockquote><p>MessageConsumers.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;        @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;simple_queue&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">Map message</span>)</span> &#123;        <span class="hljs-comment">// 打印日志</span>        log.info(<span class="hljs-string">&quot;消费者1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><blockquote><p>发送成功后，控制台会打印如下消息</p><p>message is {createTime=2021-01-14 15:05:22, messageId=0ab32f11-81ec-495b-856a-f77504615eb2, messageData=123456}</p></blockquote><h2 id="二-work：工作模式-资源的竞争"><a href="#二-work：工作模式-资源的竞争" class="headerlink" title="二. work：工作模式 (资源的竞争)"></a>二. work：工作模式 (资源的竞争)</h2><h3 id="1-要点-1"><a href="#1-要点-1" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，多个消费者，消息被多个消费者竞争接收。 一对多</p></blockquote><h3 id="2-原理-1"><a href="#2-原理-1" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="https://img-blog.csdnimg.cn/20200104104835781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="工作模式"></p><blockquote><p>消息产生者将消息放入队列消费者可以有多个，消费者 1, 消费者 2, 同时监听同一个队列，消息被消费。C1 C2 共同争抢当前的消息队列内容，谁先拿到谁负责消费消息</p><p>(隐患：高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关 (syncronize, 与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)。<br>应用场景： 红包；大项目中的资源调度 (任务分配系统不需知道哪一个任务执<br> 行系统在空闲，直接将任务扔到消息队列中，空闲的系统自动争抢)。</p></blockquote><h4 id="3-代码演示-1"><a href="#3-代码演示-1" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h4><h4 id="3-1-发布端（Publish）-1"><a href="#3-1-发布端（Publish）-1" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><blockquote><p>RabbitMQConfig.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义简单队列名.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String simpleQueue = <span class="hljs-string">&quot;simple_queue&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">simpleQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(simpleQueue);    &#125;&#125;<span class="hljs-comment">//https://blog.csdn.net/weixin_45393094/article/details/106160234</span></code></pre></div><blockquote><p>IMessageService.java </p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息服务接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMessageService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 推送消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span></span>;&#125;</code></pre></div><blockquote><p>MessageServiceImpl</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息服务接口实现类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMessageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span> </span>&#123;        String messageId = String.valueOf(UUID.randomUUID());        String createTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;messageId&quot;</span>, messageId);        map.put(<span class="hljs-string">&quot;messageData&quot;</span>, message);        map.put(<span class="hljs-string">&quot;createTime&quot;</span>, createTime);        <span class="hljs-comment">// 发送消息到rabbit服务器</span>        rabbitTemplate.convertAndSend(RabbitMQConfig.simpleQueue, map);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><blockquote><p>MessageController.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    IMessageService messageService;    <span class="hljs-meta">@GetMapping(&quot;/workPush&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">workPush</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">// 调用服务推送消息</span>            messageService.pushMessage(<span class="hljs-string">&quot;我是消息&quot;</span>+i);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-1"><a href="#3-2-消费端（Consumer）-1" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><blockquote><p>MessageConsumers.java</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 多个消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;       @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;simple_queue&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">Map message</span>)</span> &#123;        <span class="hljs-comment">// 打印日志</span>        log.info(<span class="hljs-string">&quot;消费者1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;simple_queue&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">Map message</span>)</span> &#123;        <span class="hljs-comment">// 打印日志</span>        log.info(<span class="hljs-string">&quot;消费者2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问workPush接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/14/utNsEbvecTCpORF.jpg" alt="#"></p><h2 id="三-publish-subscribe：发布订阅-共享资源"><a href="#三-publish-subscribe：发布订阅-共享资源" class="headerlink" title="三. publish/subscribe：发布订阅 (共享资源)"></a>三. publish/subscribe：发布订阅 (共享资源)</h2><h3 id="1-要点-2"><a href="#1-要点-2" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，多个消费者，消息复制多份，每个消费者接收相同的消息。 </p></blockquote><h3 id="2-原理-2"><a href="#2-原理-2" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><img src="https://img-blog.csdnimg.cn/20200104110859450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="发布订阅模式"></p><blockquote><p>X 代表交换机 RabbitMQ 内部组件，erlang 消息产生者是代码完成，代码的执行效率不高，消息产生者将消息放入交换机，交换机发布订阅把消息发送到所有消息队列中，对应消息队列的消费者拿到 消息进行消费<br>相关场景：邮件群发，群聊天，广播 (广告)</p></blockquote><h3 id="3-代码演示-2"><a href="#3-代码演示-2" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-2"><a href="#3-1-发布端（Publish）-2" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类"><a href="#RabbitMQ-配置类" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp">@Configuration<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> &#123;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;fanoutExchange&quot;</span>);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span>(<span class="hljs-params">Queue queue1, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span>(<span class="hljs-params">Queue queue2, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange);    &#125;&#125;</code></pre></div><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchange&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, context);    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-2"><a href="#3-2-消费端（Consumer）-2" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue2&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>持续更新中……..</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息中间件</tag>
      
      <tag>Message Queue</tag>
      
      <tag>Rabbit MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java】单例模式</title>
    <link href="/2021/01/11/%E3%80%90Java%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E3%80%90Java%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong>。</p></blockquote><p><strong>注意：</strong></p><ul><li><p>单例类只能有一个实例。</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p></li></ul><p>为什么使用单例设计模式</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点对象</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h2 id="单例设计模式8-种方法"><a href="#单例设计模式8-种方法" class="headerlink" title="单例设计模式8 种方法"></a>单例设计模式8 种方法</h2><ol><li><strong>饿汉式（静态常量）</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="单例设计模式具体实现"><a href="#单例设计模式具体实现" class="headerlink" title="单例设计模式具体实现"></a>单例设计模式具体实现</h3><h4 id="1-）饿汉式（静态常量）实例"><a href="#1-）饿汉式（静态常量）实例" class="headerlink" title="1 ）饿汉式（静态常量）实例"></a>1 ）饿汉式（静态常量）实例</h4><p> <strong>代码实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">// 公开一个方法，获得唯一实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true </span><span class="hljs-comment">    singleton.hashCode: 366712642 </span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：这种方式写法简单，在类装载的时候就完成实例化，避免了线程同步问题</li><li>缺点：在类装载的时候就完成实例化，没有达到<strong>Lazy Loading 懒加载</strong> 的效果，如果从始至终未使用过这个类，则会造成内存的浪费。（<strong>懒加载的意思就是什么时候用什么时候才加载</strong>）</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="2-）饿汉式（静态代码块）实例"><a href="#2-）饿汉式（静态代码块）实例" class="headerlink" title="2 ）饿汉式（静态代码块）实例"></a><strong>2 ）饿汉式（静态代码块）实例</strong></h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance;<span class="hljs-comment">//  在静态代码块中 进行初始化</span><span class="hljs-keyword">static</span>&#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优缺点与上面一样</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="3-）懒汉式（线程不安全）实例"><a href="#3-）懒汉式（线程不安全）实例" class="headerlink" title="3 ）懒汉式（线程不安全）实例"></a>3 ）懒汉式（线程不安全）实例</h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest02</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式1 线程不安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程不安全）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式1 线程不安全</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优点：实现了<strong>Lazy Loading 懒加载</strong> 的效果</p></li><li><p>缺点：只能在单线程下使用，如果进入了多线程，<code>if(singletonInstance == null) </code>语句还未来得及向下执行，另一个线程也通过了这个判断语句，<strong>会导致产生多个实例，因此在严格意义上它并属于单例设计模式</strong>。在多线程下不能使用这种方式</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式。</p></li></ol><h4 id="4-）懒汉式（线程安全-同步方法）实例"><a href="#4-）懒汉式（线程安全-同步方法）实例" class="headerlink" title="4 ）懒汉式（线程安全 同步方法）实例"></a>4 ）懒汉式（线程安全 同步方法）实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest01</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式2  线程安全 同步方法&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步方法）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-comment">//利用synchronized修饰getInstance方法，使之变为同步方法 懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式2  线程安全 同步方法</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：解决了线程安全的问题</li><li>缺点：<strong>效率太低</strong>，每个线程想要执行getInstance()方法时，<strong>都要进行同步</strong>，实际上这个方法<strong>只执行一次实例化</strong>就够了，之后就直接return 实例就好了，<strong>方法进行同步效率太低</strong></li><li>结论：在实际开发中<strong>不推荐</strong>这种方式。</li></ol><h4 id="5-）懒汉式（线程不安全-同步代码块）实例"><a href="#5-）懒汉式（线程不安全-同步代码块）实例" class="headerlink" title="5 ）懒汉式（线程不安全 同步代码块）实例"></a>5 ）懒汉式（线程不安全 同步代码块）实例</h4><p>有的人也许会认为把上面同步方法换成同步代码块就可以了：如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式3 线程不安全 同步代码块&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步代码块）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 在这里设置静态代码块  并不能解决同步问题 所以这种方法不可以</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式3 线程不安全 同步代码块</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优缺点与 3） 一样</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式</p></li></ol><h4 id="6）双重检查-实例"><a href="#6）双重检查-实例" class="headerlink" title="6）双重检查 实例"></a>6）双重检查 实例</h4><p>  <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;双重检查  线程安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125; <span class="hljs-comment">// 双重检查</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> 1.volatile</span><span class="hljs-comment"> volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的         优化而省略。</span><span class="hljs-comment">2.volatile 的特性</span><span class="hljs-comment">保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程 来说是立即可见的,(即实时刷新)。（实现可见性） 禁止进行指令重排序。（实现有序性）</span><span class="hljs-comment">volatile 只能保证对单次读 / 写的原子性。i++ 这种操作不能保证原子性。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 创建一个私有的静态变量 并用volatile修饰</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 加入双重检查的代码 解决线程安全 以及懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 第一次判断  如果实例化直接返回 否则进行实例化</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 设置静态代码块  保证每次只能进入一个线程</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">// 第二次判断 保证只能实例化一次</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">双重检查  线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：双重检查（double-check） 概念时多线程开发中经常用到的，在代码中我们进行了两次<code>if(singletonInstance == null)</code>判断，解决了线程安全问题</li><li>第一个线程调用完getInstance方法后，其他的线程在第一层判断时，就会直接返回实例，避免反复进入同步代码块，解决了效率问题</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="7）静态内部类-实例"><a href="#7）静态内部类-实例" class="headerlink" title="7）静态内部类 实例"></a>7）静态内部类 实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;静态内部类  线程安全 懒加载&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-comment">// 原因：</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    在Singleton进行装载的时候 其静态内部类不进行装载，等到getInstance方法返回静态内部类中</span><span class="hljs-comment">    常量时静态内部类才进行装载，其常量才进行实例化，且装载过程为线程安全，并实现了懒加载。</span><span class="hljs-comment">    */</span><span class="hljs-comment">//创建静态内部类，利用其特性 实现线程安全，以及懒加载</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法 获得实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">静态内部类  线程安全 懒加载</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>在Singleton进行装载的时候 其<strong>静态内部类SingletonInstance并不进行装载</strong>，等到需要实例化时调用getInstance方法时，<strong>静态内部类SingletonInstance才进行装载</strong>，完成<strong>Singleton类的实例化</strong>，类的静态属性，只有在第一次装载类的时候进行初始化，JVM帮我们实现了<strong>线程的安全性</strong>，并实现了懒加载。</li><li>优点： 避免了线程的不安全，利用静态类实现延迟加载，效率高。</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="8-）枚举-实例"><a href="#8-）枚举-实例" class="headerlink" title="8 ）枚举 实例"></a>8 ）枚举 实例</h4><p><strong>代码展示：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;JDK1.5 枚举 线程安全&quot;</span>);Singleton singleton = Singleton.INSTANCE;Singleton singleton1 = Singleton.INSTANCE;System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类，实现单例</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;INSTANCE;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">JDK1.5 枚举 线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p></li><li><p>结论：推荐使用</p></li></ol><h2 id="破坏单例模式的方法及解决办法"><a href="#破坏单例模式的方法及解决办法" class="headerlink" title="破坏单例模式的方法及解决办法"></a>破坏单例模式的方法及解决办法</h2><p>1、除枚举方式外，其他方法都会通过反射的方式破坏单例，反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例，则阻止生成新的实例，解决办法如下:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonObject1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span> (instance !=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);    &#125;&#125;</code></pre></div><p>2、如果单例类实现了序列化接口 Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口，如果非得实现序列化接口，可以重写反序列化方法 readResolve (), 反序列化时直接返回相关单例对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-1</title>
    <link href="/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></blockquote><h3 id="分类及关系"><a href="#分类及关系" class="headerlink" title="分类及关系"></a>分类及关系</h3><h4 id="设计模式三大类"><a href="#设计模式三大类" class="headerlink" title="设计模式三大类"></a>设计模式三大类</h4><ul><li><p><strong>创建型模式【共五种】</strong> </p><p>工厂方法模式；抽象工厂模式；单例模式；建造者模式；原型模式。</p></li><li><p><strong>结构型模式【共七种】</strong></p><p>适配器模式；装饰器模式；代理模式；外观模式；桥接模式；组合模式；享元模式。</p></li><li><p><strong>行为型模式【共十一种】</strong></p><p>策略模式；模板方法模式；观察者模式；迭代子模式；责任链模式；命令模式；备忘录模式；状态模式；访问者模式；中介者模式；解释器模式</p></li></ul><h4 id="设计模式关系"><a href="#设计模式关系" class="headerlink" title="设计模式关系"></a>设计模式关系</h4><p><img src="https://i.loli.net/2021/01/11/ZKbFWYMqUmBS8uk.jpg" alt="designPattern.jpg"></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则 (Liskov Substitution Principle LSP) 面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对 “开 - 闭” 原则的补充。实现 “开 - 闭” 原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>原则是尽量使用合成 / 聚合的方式，而不是使用继承。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>开闭原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/01/09/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/01/09/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KMP 算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回 - 1（常用手段）。</p><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p><h3 id="kMP解决的问题"><a href="#kMP解决的问题" class="headerlink" title="kMP解决的问题"></a>kMP解决的问题</h3><p>现在有一个字符串为源字符串S,现在给你个目标字符串T，问T是否在S中存在。(下图中：上面的为S，下面的为T)</p><p><img src="https://i.loli.net/2021/01/09/qkFvCIet4xJjQgn.png" alt="kmp1.png"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><strong>遍历两个字符串</strong></p><ul><li>首先，定义两个指针i，j初始化为0</li></ul><p><img src="https://i.loli.net/2021/01/09/yB9nEYl2mROLqPS.png" alt="kmp2.png"></p><ul><li>如果i 指向的字符和 j 指向的字符一致，i和j向后移动。</li></ul><p><img src="https://i.loli.net/2021/01/09/cREG9gWDKoX3HPn.png" alt="kmp3.png"></p><ul><li>不相等，那就把 i 指针移回第 1 位（假设下标从 0 开始），j 移动到模式串的第 0 位：</li></ul><p><img src="https://i.loli.net/2021/01/09/MK4zQx1tJOmVX5h.png" alt="kmp4.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matching</span><span class="hljs-params">(String src, String pattern)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = src.length();    <span class="hljs-keyword">int</span> len2 = pattern.length();    <span class="hljs-comment">// 主串的长度小于模式串的长度时直接返回-1，说明不存在</span>    <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 主串中剩下未匹配的字符的大小&gt;=模式串的长度才继续进行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; len1 - i &gt;= len2; i++) &#123;        <span class="hljs-keyword">int</span> temp = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pattern.length(); j++) &#123;            <span class="hljs-comment">// 对照第2步</span>            <span class="hljs-keyword">if</span> (src.charAt(temp++) == pattern.charAt(j)) &#123;                <span class="hljs-comment">// pattern 数组遍历到结尾说明找到匹配的</span>                <span class="hljs-keyword">if</span> (j == pattern.length() - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// i - len2 是模式串在源串中的起始位置</span>                    <span class="hljs-keyword">return</span> i;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 不等就跳出循环 对标第三步</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://i.loli.net/2021/01/10/p3cQJqNFy4AEWHZ.gif" alt="kmp5.gif"></p><blockquote><p>如上图，在暴力求解时，每当发现字符不匹配时，主串i需要回溯，模式串的j也要回溯，这极大的影响了搜索效率。</p></blockquote><h3 id="KMP求解法"><a href="#KMP求解法" class="headerlink" title="KMP求解法"></a>KMP求解法</h3><h4 id="KMP是如何消除指针回溯问题的"><a href="#KMP是如何消除指针回溯问题的" class="headerlink" title="KMP是如何消除指针回溯问题的"></a>KMP是如何消除指针回溯问题的</h4><p>未完待续。。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/2JhlgDr1yqjCcaA.gif" alt="selectionSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = src.length;    <span class="hljs-comment">// 比较 len - 1 词</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 记录当前下标，作为之后比较使用</span>        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-comment">// 找出最小的元素,需要比较 len - 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &lt; src[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 如果最小元素下标发生改变，则交换</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            <span class="hljs-keyword">int</span> temp = src[i];            src[i] = src[min];            src[min] = temp;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。在剩下的n-1个元素中重复此操作，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。至此排序完成</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://uploader.shimo.im/f/DhBMiGl0vTmIAGGk.gif" alt="bubble"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &gt;= src[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> temp = src[j];                src[j] = src[j+<span class="hljs-number">1</span>];                src[j+<span class="hljs-number">1</span>] = temp;                flag = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从数列中挑出一个元素，称为 “基准”（pivot）;<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/ipdOu3qA8lxTf2M.gif" alt="quickSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    quickProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        swap(arr, left + ((<span class="hljs-keyword">int</span>) Math.random() * (right - left + <span class="hljs-number">1</span>)), right);        <span class="hljs-keyword">int</span>[] p = partation(arr, left, right);        quickProcess(arr, left, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);        quickProcess(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partation(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">int</span> less = left - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> more = right;    <span class="hljs-keyword">int</span> base = arr[right];    <span class="hljs-keyword">while</span> (left &lt; more) &#123;        <span class="hljs-keyword">if</span> (arr[left] &lt; base) &#123;            swap(arr, ++less, left++);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] &gt; base) &#123;            swap(arr, --more, left);        &#125; <span class="hljs-keyword">else</span> &#123;            left++;        &#125;    &#125;    swap(arr, more, right);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = arr[index1];    arr[index1] = arr[index2];    arr[index2] = temp;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码解析-JDK1-8"><a href="#HashMap源码解析-JDK1-8" class="headerlink" title="HashMap源码解析(JDK1.8)"></a>HashMap源码解析(JDK1.8)</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在进行HashMap分析前，我期望解决以下问题：</p><ul><li>HashMap的底层数据结构是什么？</li><li>HashMap中增删改查操作的底部实现原理是什么？</li><li>HashMap是如何实现扩容的？</li><li>HashMap是如何解决hash冲突的？</li><li>HashMap为什么是非线程安全的？</li></ul><h3 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h3><p>HashMap 基于哈希表的 Map 接口的实现，key唯一的value可以重复，允许存储键为null(key = null),值为null(value = null)，元素没有顺序,同时不保证该顺序恒久不变。</p><p>在 JDK 1.8 之前是由“数组+链表”组成。JDK1.8的HashMap对之前做了较大的优化，其中最重要的一个优化就是将底层的数据结构由“数组+链表”变为了“数组+链表+红黑树”，值得一提的是只有当链表的长度大于8时.。除此之外HashMap是非线程安全的，因此在多个线程同时对HashMap中的同一个元素进行修改时，不能保证数据的唯一性。</p><h3 id="剖析结构"><a href="#剖析结构" class="headerlink" title="剖析结构"></a>剖析结构</h3><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p><img src="https://i.loli.net/2021/01/07/femFXPH2T8N5ZMv.png" alt="DataStruct1.7.png"></p><p>从上图我们可以看到，在jdk1.7中，首先是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，因为Entry具有Next引用，每一个Entry实体类实际上是一个单向的链表的头部，可以用来连接下一个Entry实体，又因为HashMap是按照Key的hash值来计算Entry在HashMap中存储的位置的，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。就这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高<strong>（链表不适合查找，适合增删）</strong>，反倒是下降了不少。</p><p>于是官方在JDK1.8的时候就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。</p><p><img src="https://i.loli.net/2021/01/07/1Qv4fyFu8rlpzXE.png" alt="DataStruct1.8.png"></p><p><strong>注意：</strong> <strong>要注意的是只有在链表的长度不小于8，且数组的长度不小于64的时候才会将链表转化为红黑树，</strong></p><h4 id="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"><a href="#这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。" class="headerlink" title="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"></a><strong>这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。</strong></h4><p><strong>因为：红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找一个元素的时间复杂度会从链表的o(n)降低为o(logn)。</strong></p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>源码</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4、重复步骤 3 直到某一指针达到序列尾；<br>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/WbeJEpiD9usgR31.gif" alt="mergeSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 排序入口函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    sortProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 分治</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (right == left) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 归并左边</span>    sortProcess(arr, left, mid);    <span class="hljs-comment">// 归并右边</span>    sortProcess(arr, mid + <span class="hljs-number">1</span>, right);    merge(arr, left, mid, right);&#125;<span class="hljs-comment">// 合并</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 辅助数组 开始下标</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = left;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 合并两个数组</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 两个指针必有一个未过界 需要处理</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) &#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= right) &#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 拷贝给原数组</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[left + i] = help[i];    &#125;&#125;</code></pre></div><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度:O(nlogn)</li><li>空间复杂度:O(N) 需要一个与排序数组长度相同的数组，进行辅助排序</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>归并排序是一个稳定的排序，只需在合并方法中，合并两个数组时用这行代码<code> help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]</code>,可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
