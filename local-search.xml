<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>消息队列【解耦、异步、削峰】</title>
    <link href="/2021/01/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/"/>
    <url>/2021/01/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列作用【解耦、异步、削峰】"><a href="#消息队列作用【解耦、异步、削峰】" class="headerlink" title="消息队列作用【解耦、异步、削峰】"></a>消息队列作用【解耦、异步、削峰】</h1><blockquote><p>学习消息队列的笔记</p></blockquote><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://i.loli.net/2021/01/19/CfQSvH6btWscTle.png" alt="mq.png"></p><ul><li>MQ 全称为 <code>Message Queue</code>, 消息队列（MQ）<code>是一种应用程序对应用程序的通信方法</code>。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</li><li>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</li><li>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合</strong>，<strong>异步消息</strong>，<strong>流量削锋</strong>等问题</li></ul><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现有一个系统 A 要与其他系统（BCD）打交道（即调用其中的方法，推送的元数据一样）如下图</p><h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://i.loli.net/2021/01/19/6ubPkKTeQCAlYn2.png" alt="mq_1.png"></p><p>系统运行了一段时间后，D系统不需要A系统推送数据了，同时又新增加了一个E系统需要A系统推送数据，如下图</p><p><img src="https://i.loli.net/2021/01/19/4GzdOlYFSrvRHZx.png" alt="mq_2.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果其它系统改变或者新增系统，那么 A 系统都会改变，这样的话耦合度比较高，比较麻烦,在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？。</p><h4 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h4><p>答：使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><h4 id="消息队列解耦"><a href="#消息队列解耦" class="headerlink" title="消息队列解耦"></a>消息队列解耦</h4><p><img src="https://i.loli.net/2021/01/19/WhMGblrtjYzKdRU.png" alt="mq_3.png"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><blockquote><p>用户注册后，需要发注册邮件和注册短信</p></blockquote><h3 id="传统模式-1"><a href="#传统模式-1" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h4><h5 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h5><p><img src="https://i.loli.net/2021/01/19/fQGWLHUCo4Zl9i2.png" alt="mq_5.png"></p><p><strong>响应时间150ms</strong></p><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p><img src="https://i.loli.net/2021/01/19/UmYfDwJpGaZTSie.png" alt="mq_4.png"></p><p><strong>响应时间100ms</strong></p><h3 id="消息队列优化"><a href="#消息队列优化" class="headerlink" title="消息队列优化"></a>消息队列优化</h3><p><img src="https://i.loli.net/2021/01/19/lU2Q9BxNcCDFt6a.png" alt="mq_6.png"></p><p><strong>响应时间55ms</strong></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析volatile</title>
    <link href="/2021/01/16/%E6%B5%85%E6%9E%90volatile/"/>
    <url>/2021/01/16/%E6%B5%85%E6%9E%90volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="浅析volatile"><a href="#浅析volatile" class="headerlink" title="浅析volatile"></a>浅析volatile</h2><h3 id="为什么引入volatile"><a href="#为什么引入volatile" class="headerlink" title="为什么引入volatile"></a>为什么引入volatile</h3><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>举个例子，比如说有两个线程，他们的代码里都需要读取data这个变量的值，那么他们都会从主内存里加载data变量的值到自己的工作内存，然后才可以使用那个值。好了，现在大家从图里看到，每个线程都把data这个变量的副本加载到了自己的工作内存里了，所以每个线程都可以读到data = 0这个值。</p><p>这样，在线程代码运行的过程中，对data的值都可以直接从工作内存里加载了，不需要再从主内存里加载了。</p></blockquote><p>为啥一定要让每个线程用一个工作内存来存放变量的副本以供读取呢？直接让线程每次都从主内存加载变量的值不行吗？</p><blockquote><p>因为线程运行的代码对应的是一些指令，是由CPU执行的！CPU每次执行指令运算的时候，每次需要一个变量的值，都从主内存加载，性能会比较差。</p><p>所以说后来，就是提出了线程工作内存的概念，类似于一个<strong>高速的本地缓存。</strong>这样一来，线程的代码在执行过程中，就可以直接从自己本地缓存里加载变量副本，不需要从主内存加载变量值，性能可以提升很多！</p></blockquote><p>思考：这种方法性能是提升了，但是会带来其他的问题么？</p><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>如上图：有两个线程，两个线程都需要data变量，都将变量的副本加载到了自己的工作内存。假如这时线程1需要修改data变量的值为1，修改完之后将这个修改写入自己的本地工作内存。如下图</p></blockquote><p><img src="https://i.loli.net/2021/01/17/wseOE28YBFnpZH6.png" alt="volatile1.png"></p><blockquote><p>那么此时，线程1的工作内存里的data值为1，但是，主内存以及线程2里的data值还是为0。那么接下来，在线程1的代码运行过程中，他可以直接读到data最新的值是1，但是线程2的代码运行过程中读到的data的值还是0。这就不符合逻辑了。</p></blockquote><p>上述问题就是：<strong>java并发编程中的可见性问题:</strong></p><p><strong>多个线程并发读写一个共享变量的时候，某个线程修改了共享变量的值，其他线程看不到，即对其他线程不可见。</strong></p><h3 id="引入volatile"><a href="#引入volatile" class="headerlink" title="引入volatile"></a>引入volatile</h3><blockquote><p>那如果要解决这个问题怎么办呢？这时就轮到<strong>volatile</strong>闪亮登场了！你只要给data这个变量在定义的时候加一个volatile，就直接可以完美的解决这个可见性的问题。</p></blockquote><p>比如下面的这样的代码，在加了volatile之后，会有啥作用呢？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 启用两个线程，一个线程会读取和修改data的值，一个线程会读取data的值</span></code></pre></div><ul><li><p>第一，一旦data变量定义的时候前面加了volatile来修饰的话，那么线程1只要修改data变量的值，就会在修改完自己本地工作内存的data变量值之后，强制将这个data变量最新的值刷回主内存，必须让主内存里的data变量值立马变成最新的值！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/R3dQ5fkvtGhZHCu.png" alt="volatile2.png"></p></li><li><p>第二，如果此时别的线程的工作内存中有这个data变量的本地缓存，也就是一个变量副本的话，那么会强制让其他线程的工作内存中的data变量缓存直接失效过期，不允许再次读取和使用了！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/Zh2f3Kmq8dxE1u6.png" alt="volatile3.png"></p></li></ul><ul><li><p>第三，如果线程2在代码运行过程中再次需要读取data变量的值，此时尝试从本地工作内存中读取，就会发现这个data = 0已经过期了！此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了！</p><p><strong>整个过程，参见下图：</strong></p><p><img src="https://i.loli.net/2021/01/17/CyEIxFn1TQOWa39.png" alt="volatile4.png"></p></li><li><p>至此，volatile完美解决了java并发中可见性的问题！对一个变量加了volatile关键字修饰之后，只要一个线程修改了这个变量的值，立马强制刷回主内存。接着强制过期其他线程的本地工作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！这样就保证，任何一个线程修改了变量值，其他线程立马就可以看见了。这就是所谓的volatile保证了可见性的工作原理。</p></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>注意：volatile主要作用是保证可见性以及有序性。volatile是不能保证原子性的！，原子性问题，得依赖synchronized、ReentrantLock等加锁机制来解决。</strong></p><blockquote><p>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</p><p>如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程------创建多线程的三种方式</title>
    <link href="/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程——创建多线程的三种方式"><a href="#多线程——创建多线程的三种方式" class="headerlink" title="多线程——创建多线程的三种方式"></a>多线程——创建多线程的三种方式</h2><h3 id="创建一个继承于java-lang-Thread的类"><a href="#创建一个继承于java-lang-Thread的类" class="headerlink" title="创建一个继承于java.lang.Thread的类"></a>创建一个继承于java.lang.Thread的类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>  + Thread.currentThread().getId());&#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 创建自定义线程</span>MyThread1 myThread1 = <span class="hljs-keyword">new</span> MyThread1();<span class="hljs-comment">// 开启线程</span>myThread1.start();&#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">123456789101112131415161718</span></code></pre></div><h3 id="实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装"><a href="#实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装" class="headerlink" title="实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装"></a>实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>     + Thread.currentThread().getId());   &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-comment">// 创建MyRunnable</span>   MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();   <span class="hljs-comment">// 用Thread 包装一下myRunnable</span>   Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);   <span class="hljs-comment">// 开启线程</span>   thread.start();   &#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">1234567891011121314151617181920</span></code></pre></div><blockquote><ol><li>这两种方式实现多线程的方式都是围绕着Thread类展开的，第一种方式实现线程是继承于java.lang.Thread类，然后实现run方法，最终调用Thread类中的start方法启动线程。而实现Runnable接口，则是把run写到了接口中，并由实现类实现run方法，然后再用Thread类对Runnable接口进行包装，然后在调用Thread中start方法启动线程。①②两种方式都是最终都是调用Thread中start方法进行启动线程。</li><li>两种方式在本质上没有明显的区别，但是在外观上有很大的区别，第一种方式是继承Thread类，由于Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就建议使用第二种方式。</li></ol></blockquote><h3 id="实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装"><a href="#实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装" class="headerlink" title="实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装"></a>实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tstarting...&quot;</span>);       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;           sum += i;       &#125;       Thread.sleep(<span class="hljs-number">5000</span>);       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tover...&quot;</span>);       <span class="hljs-keyword">return</span> sum;   &#125;&#125;<span class="hljs-comment">// 测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;   MyCallable myCallable = <span class="hljs-keyword">new</span> MyCallable();   <span class="hljs-comment">// 将Callable包装成FutureTask，FutureTask也是一种Runnable</span>   FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myCallable);   Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);   thread.start();   <span class="hljs-comment">// get方法会阻塞调用的线程</span>   Integer res = futureTask.get();   System.out.println(<span class="hljs-string">&quot;线程执行结果：&quot;</span>+res);   &#125;&#125;<span class="hljs-comment">//Thread-010Wed Apr 15 15:32:38 CST 2020 starting...</span><span class="hljs-comment">//Thread-010Wed Apr 15 15:32:43 CST 2020 over...</span><span class="hljs-comment">//线程执行结果：5050</span><span class="hljs-number">123456789101112131415161718192021222324252627282930</span></code></pre></div><h4 id="三种方式比较："><a href="#三种方式比较：" class="headerlink" title="三种方式比较："></a>三种方式比较：</h4><ul><li>Thread: 继承方式, 不建议使用, 因为Java是单继承的，继承了Thread就没办法继承其它类了，不够灵活</li><li>Runnable: 实现接口，比Thread类更加灵活，没有单继承的限制</li><li>Callable: Thread和Runnable都是重写的run()方法并且没有返回值，Callable是重写的call()方法并且有返回值并可以借助FutureTask类来判断线程是否已经执行完毕或者取消线程执行</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>当线程不需要返回值时使用Runnable，需要返回值时就使用Callable，一般情况下不直接把线程体代码放到Thread类中，一般通过Thread类来启动线程</li><li>Thread类是实现Runnable，</li><li>Callable封装成FutureTask，FutureTask实现RunnableFuture，RunnableFuture继承Runnable，所以Callable也算是一种Runnable，</li><li>所以三种实现方式本质上都是对Runnable实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq学习</title>
    <link href="/2021/01/13/RabbitMq%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/13/RabbitMq%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabbit-MQ-学习【7种工作模式】"><a href="#Rabbit-MQ-学习【7种工作模式】" class="headerlink" title="Rabbit MQ 学习【7种工作模式】"></a>Rabbit MQ 学习【7种工作模式】</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-首先安装Rabbit-MQ"><a href="#1-首先安装Rabbit-MQ" class="headerlink" title="1.首先安装Rabbit MQ"></a>1.首先安装Rabbit MQ</h3><blockquote><p> <strong>教程网址</strong> <a href="https://blog.csdn.net/qq_47588845/article/details/107986373">https://blog.csdn.net/qq_47588845/article/details/107986373</a></p></blockquote><h3 id="2-创建一个springboot项目"><a href="#2-创建一个springboot项目" class="headerlink" title="2.创建一个springboot项目"></a>2.创建一个springboot项目</h3><h3 id="3-导入依赖"><a href="#3-导入依赖" class="headerlink" title="3. 导入依赖"></a>3. 导入依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--lombok--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4-application-properties"><a href="#4-application-properties" class="headerlink" title="4.application.properties"></a>4.application.properties</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">##################</span><span class="hljs-comment">####rabbitmq######</span><span class="hljs-comment">##################</span><span class="hljs-comment">#主机地址</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx</span><span class="hljs-comment">#端口号</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">xxxx </span><span class="hljs-comment">#账号密码</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">xxxx</span><span class="hljs-comment">#密码</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">xxxx</span></code></pre></div><h2 id="一-简单模式-simple"><a href="#一-简单模式-simple" class="headerlink" title="一.简单模式 (simple)"></a>一.简单模式 (simple)</h2><h3 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，一个消费者。 一对一。消息发布者（Publish）将消息放入队列（默认交换机）。消息的消费者（Consumer）监听消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除</p><p><strong>隐患：</strong>消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失,这里可以设置成手动的 ack, 但如果设置成手动 ack，处理完后要及时发送 ack 消息给队列，否则会造成内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/20200103230605348.png" alt="simple模式"></p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p><strong>将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人</strong></p><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）"><a href="#3-1-发布端（Publish）" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类"><a href="#RabbitMQ-配置类" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口"><a href="#消息推送接口" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）"><a href="#3-2-消费端（Consumer）" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><blockquote><p>发送成功后，控制台会打印如下消息</p><p>Sender : hi, fanout msg </p><p>队列queue1 接收的消息 is hi, fanout msg </p></blockquote><h2 id="二-工作模式-work"><a href="#二-工作模式-work" class="headerlink" title="二.工作模式 (work)"></a>二.工作模式 (work)</h2><h3 id="1-要点-1"><a href="#1-要点-1" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，多个消费者，消息被多个消费者竞争接收。 一对多消息产生者将消息放入队列消费者可以有多个，消费者 1, 消费者 2, 同时监听同一个队列，消息被消费。C1 C2 共同争抢当前的消息队列内容，谁先拿到谁负责消费消息</p><p><strong>隐患：</strong>高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关 (syncronize, 与同步锁的性能不一样) 保证一条消息只能被一个消费者使用</p><p><img src="https://img-blog.csdnimg.cn/20200104104835781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="工作模式"></p><h3 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>一个订单的处理需要 10s，有多个订单可以同时放到消息队列，然后让多个消费者同时处理，这样就是并行了，而不是单个消费者的串行情况</p><h3 id="3-代码演示-1"><a href="#3-代码演示-1" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-1"><a href="#3-1-发布端（Publish）-1" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="rabbitMQ配置类"><a href="#rabbitMQ配置类" class="headerlink" title="rabbitMQ配置类"></a>rabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-1"><a href="#消息推送接口-1" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            messageProducer.send();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-1"><a href="#3-2-消费端（Consumer）-1" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/XJloczuLCaQtm6W.png" alt="result1.png"></p><h2 id="三-publish-subscribe：发布订阅-共享资源"><a href="#三-publish-subscribe：发布订阅-共享资源" class="headerlink" title="三. publish/subscribe：发布订阅 (共享资源)"></a>三. publish/subscribe：发布订阅 (共享资源)</h2><h3 id="1-要点-2"><a href="#1-要点-2" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，多个消费者，消息复制多份，每个消费者接收相同的消息。 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200104110859450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="发布订阅模式"></p><h3 id="2-应用场景-2"><a href="#2-应用场景-2" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p><strong>更新商品库存后需要通知多个缓存和多个数据库，这里的结构应该是：</strong></p><ul><li>一个 fanout 类型交换机扇出两个个消息队列，分别为缓存消息队列、数据库消息队列</li><li>一个缓存消息队列对应着多个缓存消费者</li><li>一个数据库消息队列对应着多个数据库消费者</li></ul><h3 id="3-代码演示-2"><a href="#3-代码演示-2" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-2"><a href="#3-1-发布端（Publish）-2" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类-1"><a href="#RabbitMQ-配置类-1" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> &#123;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;fanoutExchange&quot;</span>);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span>(<span class="hljs-params">Queue queue1, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span>(<span class="hljs-params">Queue queue2, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange);    &#125;&#125;</code></pre></div><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchange&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, context);    &#125;&#125;</code></pre></div><h5 id="接口消息推送接口"><a href="#接口消息推送接口" class="headerlink" title="接口消息推送接口"></a>接口消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-2"><a href="#3-2-消费端（Consumer）-2" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-2"><a href="#消息消费者-2" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue2&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/6OQDhpvs43y2RTN.png" alt="result2.png"></p><h2 id="四-路由模式（Routing）"><a href="#四-路由模式（Routing）" class="headerlink" title="四.路由模式（Routing）"></a>四.路由模式（Routing）</h2><h3 id="1-要点-3"><a href="#1-要点-3" class="headerlink" title="1.要点"></a>1.要点</h3><p>​        有选择地（Routing key）接收消息，发送消息到交换机并且要指定路由 key ，消费者将队列绑定到交换机时需要指定路由 key，仅消费指定路由 key 的消息</p><p><img src="https://i.loli.net/2021/01/18/JSeC3wVNFcdxUsK.png" alt="routing.png"></p><h3 id="2-应用场景-3"><a href="#2-应用场景-3" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p>​        如在商品库存中增加了 1 台 iphone12，iphone12 促销活动消费者指定 routing key 为 iphone12，只有此促销活动会接收到消息，其它促销活动不关心也不会消费此 routing key 的消息</p><h3 id="3-代码演示-3"><a href="#3-代码演示-3" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1-发布端"><a href="#3-1-发布端" class="headerlink" title="3.1 发布端"></a>3.1 发布端</h4><h5 id="RabbitMQ配置类"><a href="#RabbitMQ配置类" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.2&quot;</span>);    &#125;    &#125;</code></pre></div><h5 id="消息生产者-2"><a href="#消息生产者-2" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-2"><a href="#消息推送接口-2" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端"><a href="#3-2-消费端" class="headerlink" title="3.2 消费端"></a>3.2 消费端</h4><h5 id="消息消费者-3"><a href="#消息消费者-3" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/JGFDrAOxs7XaeqS.png" alt="result3.png"></p><h2 id="五-主题模式（Topics）"><a href="#五-主题模式（Topics）" class="headerlink" title="五.主题模式（Topics）"></a>五.主题模式（Topics）</h2><h3 id="1-要点-4"><a href="#1-要点-4" class="headerlink" title="1.要点"></a>1.要点</h3><p><img src="https://i.loli.net/2021/01/18/jC5eb47GIqRdcHz.png" alt="topic.png"></p><h3 id="2-应用场景-4"><a href="#2-应用场景-4" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><h3 id="3-代码演示-4"><a href="#3-代码演示-4" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1发布端"><a href="#3-1发布端" class="headerlink" title="3.1发布端"></a>3.1发布端</h4><h5 id="RabbitMQ配置类-1"><a href="#RabbitMQ配置类-1" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.*&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-3"><a href="#消息生产者-3" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-3"><a href="#消息推送接口-3" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2消费端"><a href="#3-2消费端" class="headerlink" title="3.2消费端"></a>3.2消费端</h4><h5 id="消息消费者-4"><a href="#消息消费者-4" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/t586oDyCvkFBlmu.png" alt="result5.png"></p><h2 id="六"><a href="#六" class="headerlink" title="六."></a>六.</h2><p>持续更新中……..</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息中间件</tag>
      
      <tag>Message Queue</tag>
      
      <tag>Rabbit MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java】单例模式</title>
    <link href="/2021/01/11/%E3%80%90Java%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E3%80%90Java%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong>。</p></blockquote><p><strong>注意：</strong></p><ul><li><p>单例类只能有一个实例。</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p></li></ul><p>为什么使用单例设计模式</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点对象</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h2 id="单例设计模式8-种方法"><a href="#单例设计模式8-种方法" class="headerlink" title="单例设计模式8 种方法"></a>单例设计模式8 种方法</h2><ol><li><strong>饿汉式（静态常量）</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="单例设计模式具体实现"><a href="#单例设计模式具体实现" class="headerlink" title="单例设计模式具体实现"></a>单例设计模式具体实现</h3><h4 id="1-）饿汉式（静态常量）实例"><a href="#1-）饿汉式（静态常量）实例" class="headerlink" title="1 ）饿汉式（静态常量）实例"></a>1 ）饿汉式（静态常量）实例</h4><p> <strong>代码实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">// 公开一个方法，获得唯一实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true </span><span class="hljs-comment">    singleton.hashCode: 366712642 </span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：这种方式写法简单，在类装载的时候就完成实例化，避免了线程同步问题</li><li>缺点：在类装载的时候就完成实例化，没有达到<strong>Lazy Loading 懒加载</strong> 的效果，如果从始至终未使用过这个类，则会造成内存的浪费。（<strong>懒加载的意思就是什么时候用什么时候才加载</strong>）</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="2-）饿汉式（静态代码块）实例"><a href="#2-）饿汉式（静态代码块）实例" class="headerlink" title="2 ）饿汉式（静态代码块）实例"></a><strong>2 ）饿汉式（静态代码块）实例</strong></h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance;<span class="hljs-comment">//  在静态代码块中 进行初始化</span><span class="hljs-keyword">static</span>&#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优缺点与上面一样</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="3-）懒汉式（线程不安全）实例"><a href="#3-）懒汉式（线程不安全）实例" class="headerlink" title="3 ）懒汉式（线程不安全）实例"></a>3 ）懒汉式（线程不安全）实例</h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest02</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式1 线程不安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程不安全）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式1 线程不安全</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优点：实现了<strong>Lazy Loading 懒加载</strong> 的效果</p></li><li><p>缺点：只能在单线程下使用，如果进入了多线程，<code>if(singletonInstance == null) </code>语句还未来得及向下执行，另一个线程也通过了这个判断语句，<strong>会导致产生多个实例，因此在严格意义上它并属于单例设计模式</strong>。在多线程下不能使用这种方式</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式。</p></li></ol><h4 id="4-）懒汉式（线程安全-同步方法）实例"><a href="#4-）懒汉式（线程安全-同步方法）实例" class="headerlink" title="4 ）懒汉式（线程安全 同步方法）实例"></a>4 ）懒汉式（线程安全 同步方法）实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest01</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式2  线程安全 同步方法&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步方法）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-comment">//利用synchronized修饰getInstance方法，使之变为同步方法 懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式2  线程安全 同步方法</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：解决了线程安全的问题</li><li>缺点：<strong>效率太低</strong>，每个线程想要执行getInstance()方法时，<strong>都要进行同步</strong>，实际上这个方法<strong>只执行一次实例化</strong>就够了，之后就直接return 实例就好了，<strong>方法进行同步效率太低</strong></li><li>结论：在实际开发中<strong>不推荐</strong>这种方式。</li></ol><h4 id="5-）懒汉式（线程不安全-同步代码块）实例"><a href="#5-）懒汉式（线程不安全-同步代码块）实例" class="headerlink" title="5 ）懒汉式（线程不安全 同步代码块）实例"></a>5 ）懒汉式（线程不安全 同步代码块）实例</h4><p>有的人也许会认为把上面同步方法换成同步代码块就可以了：如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式3 线程不安全 同步代码块&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步代码块）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 在这里设置静态代码块  并不能解决同步问题 所以这种方法不可以</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式3 线程不安全 同步代码块</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优缺点与 3） 一样</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式</p></li></ol><h4 id="6）双重检查-实例"><a href="#6）双重检查-实例" class="headerlink" title="6）双重检查 实例"></a>6）双重检查 实例</h4><p>  <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;双重检查  线程安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125; <span class="hljs-comment">// 双重检查</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> 1.volatile</span><span class="hljs-comment"> volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的         优化而省略。</span><span class="hljs-comment">2.volatile 的特性</span><span class="hljs-comment">保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程 来说是立即可见的,(即实时刷新)。（实现可见性） 禁止进行指令重排序。（实现有序性）</span><span class="hljs-comment">volatile 只能保证对单次读 / 写的原子性。i++ 这种操作不能保证原子性。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 创建一个私有的静态变量 并用volatile修饰</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 加入双重检查的代码 解决线程安全 以及懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 第一次判断  如果实例化直接返回 否则进行实例化</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 设置静态代码块  保证每次只能进入一个线程</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">// 第二次判断 保证只能实例化一次</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">双重检查  线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：双重检查（double-check） 概念时多线程开发中经常用到的，在代码中我们进行了两次<code>if(singletonInstance == null)</code>判断，解决了线程安全问题</li><li>第一个线程调用完getInstance方法后，其他的线程在第一层判断时，就会直接返回实例，避免反复进入同步代码块，解决了效率问题</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="7）静态内部类-实例"><a href="#7）静态内部类-实例" class="headerlink" title="7）静态内部类 实例"></a>7）静态内部类 实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;静态内部类  线程安全 懒加载&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-comment">// 原因：</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    在Singleton进行装载的时候 其静态内部类不进行装载，等到getInstance方法返回静态内部类中</span><span class="hljs-comment">    常量时静态内部类才进行装载，其常量才进行实例化，且装载过程为线程安全，并实现了懒加载。</span><span class="hljs-comment">    */</span><span class="hljs-comment">//创建静态内部类，利用其特性 实现线程安全，以及懒加载</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法 获得实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">静态内部类  线程安全 懒加载</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>在Singleton进行装载的时候 其<strong>静态内部类SingletonInstance并不进行装载</strong>，等到需要实例化时调用getInstance方法时，<strong>静态内部类SingletonInstance才进行装载</strong>，完成<strong>Singleton类的实例化</strong>，类的静态属性，只有在第一次装载类的时候进行初始化，JVM帮我们实现了<strong>线程的安全性</strong>，并实现了懒加载。</li><li>优点： 避免了线程的不安全，利用静态类实现延迟加载，效率高。</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="8-）枚举-实例"><a href="#8-）枚举-实例" class="headerlink" title="8 ）枚举 实例"></a>8 ）枚举 实例</h4><p><strong>代码展示：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;JDK1.5 枚举 线程安全&quot;</span>);Singleton singleton = Singleton.INSTANCE;Singleton singleton1 = Singleton.INSTANCE;System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类，实现单例</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;INSTANCE;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">JDK1.5 枚举 线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p></li><li><p>结论：推荐使用</p></li></ol><h2 id="破坏单例模式的方法及解决办法"><a href="#破坏单例模式的方法及解决办法" class="headerlink" title="破坏单例模式的方法及解决办法"></a>破坏单例模式的方法及解决办法</h2><p>1、除枚举方式外，其他方法都会通过反射的方式破坏单例，反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例，则阻止生成新的实例，解决办法如下:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonObject1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span> (instance !=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);    &#125;&#125;</code></pre></div><p>2、如果单例类实现了序列化接口 Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口，如果非得实现序列化接口，可以重写反序列化方法 readResolve (), 反序列化时直接返回相关单例对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-1</title>
    <link href="/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></blockquote><h3 id="分类及关系"><a href="#分类及关系" class="headerlink" title="分类及关系"></a>分类及关系</h3><h4 id="设计模式三大类"><a href="#设计模式三大类" class="headerlink" title="设计模式三大类"></a>设计模式三大类</h4><ul><li><p><strong>创建型模式【共五种】</strong> </p><p>工厂方法模式；抽象工厂模式；单例模式；建造者模式；原型模式。</p></li><li><p><strong>结构型模式【共七种】</strong></p><p>适配器模式；装饰器模式；代理模式；外观模式；桥接模式；组合模式；享元模式。</p></li><li><p><strong>行为型模式【共十一种】</strong></p><p>策略模式；模板方法模式；观察者模式；迭代子模式；责任链模式；命令模式；备忘录模式；状态模式；访问者模式；中介者模式；解释器模式</p></li></ul><h4 id="设计模式关系"><a href="#设计模式关系" class="headerlink" title="设计模式关系"></a>设计模式关系</h4><p><img src="https://i.loli.net/2021/01/11/ZKbFWYMqUmBS8uk.jpg" alt="designPattern.jpg"></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则 (Liskov Substitution Principle LSP) 面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对 “开 - 闭” 原则的补充。实现 “开 - 闭” 原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>原则是尽量使用合成 / 聚合的方式，而不是使用继承。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>开闭原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/01/09/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/01/09/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KMP 算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回 - 1（常用手段）。</p><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p><h3 id="kMP解决的问题"><a href="#kMP解决的问题" class="headerlink" title="kMP解决的问题"></a>kMP解决的问题</h3><p>现在有一个字符串为源字符串S,现在给你个目标字符串T，问T是否在S中存在。(下图中：上面的为S，下面的为T)</p><p><img src="https://i.loli.net/2021/01/09/qkFvCIet4xJjQgn.png" alt="kmp1.png"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><strong>遍历两个字符串</strong></p><ul><li>首先，定义两个指针i，j初始化为0</li></ul><p><img src="https://i.loli.net/2021/01/09/yB9nEYl2mROLqPS.png" alt="kmp2.png"></p><ul><li>如果i 指向的字符和 j 指向的字符一致，i和j向后移动。</li></ul><p><img src="https://i.loli.net/2021/01/09/cREG9gWDKoX3HPn.png" alt="kmp3.png"></p><ul><li>不相等，那就把 i 指针移回第 1 位（假设下标从 0 开始），j 移动到模式串的第 0 位：</li></ul><p><img src="https://i.loli.net/2021/01/09/MK4zQx1tJOmVX5h.png" alt="kmp4.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matching</span><span class="hljs-params">(String src, String pattern)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = src.length();    <span class="hljs-keyword">int</span> len2 = pattern.length();    <span class="hljs-comment">// 主串的长度小于模式串的长度时直接返回-1，说明不存在</span>    <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 主串中剩下未匹配的字符的大小&gt;=模式串的长度才继续进行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; len1 - i &gt;= len2; i++) &#123;        <span class="hljs-keyword">int</span> temp = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pattern.length(); j++) &#123;            <span class="hljs-comment">// 对照第2步</span>            <span class="hljs-keyword">if</span> (src.charAt(temp++) == pattern.charAt(j)) &#123;                <span class="hljs-comment">// pattern 数组遍历到结尾说明找到匹配的</span>                <span class="hljs-keyword">if</span> (j == pattern.length() - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// i - len2 是模式串在源串中的起始位置</span>                    <span class="hljs-keyword">return</span> i;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 不等就跳出循环 对标第三步</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://i.loli.net/2021/01/10/p3cQJqNFy4AEWHZ.gif" alt="kmp5.gif"></p><blockquote><p>如上图，在暴力求解时，每当发现字符不匹配时，主串i需要回溯，模式串的j也要回溯，这极大的影响了搜索效率。</p></blockquote><h3 id="KMP求解法"><a href="#KMP求解法" class="headerlink" title="KMP求解法"></a>KMP求解法</h3><h4 id="KMP是如何消除指针回溯问题的"><a href="#KMP是如何消除指针回溯问题的" class="headerlink" title="KMP是如何消除指针回溯问题的"></a>KMP是如何消除指针回溯问题的</h4><p>未完待续。。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/2JhlgDr1yqjCcaA.gif" alt="selectionSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = src.length;    <span class="hljs-comment">// 比较 len - 1 词</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 记录当前下标，作为之后比较使用</span>        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-comment">// 找出最小的元素,需要比较 len - 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &lt; src[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 如果最小元素下标发生改变，则交换</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            <span class="hljs-keyword">int</span> temp = src[i];            src[i] = src[min];            src[min] = temp;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。在剩下的n-1个元素中重复此操作，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。至此排序完成</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://uploader.shimo.im/f/DhBMiGl0vTmIAGGk.gif" alt="bubble"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &gt;= src[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> temp = src[j];                src[j] = src[j+<span class="hljs-number">1</span>];                src[j+<span class="hljs-number">1</span>] = temp;                flag = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从数列中挑出一个元素，称为 “基准”（pivot）;<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/ipdOu3qA8lxTf2M.gif" alt="quickSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    quickProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        swap(arr, left + ((<span class="hljs-keyword">int</span>) Math.random() * (right - left + <span class="hljs-number">1</span>)), right);        <span class="hljs-keyword">int</span>[] p = partation(arr, left, right);        quickProcess(arr, left, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);        quickProcess(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partation(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">int</span> less = left - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> more = right;    <span class="hljs-keyword">int</span> base = arr[right];    <span class="hljs-keyword">while</span> (left &lt; more) &#123;        <span class="hljs-keyword">if</span> (arr[left] &lt; base) &#123;            swap(arr, ++less, left++);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] &gt; base) &#123;            swap(arr, --more, left);        &#125; <span class="hljs-keyword">else</span> &#123;            left++;        &#125;    &#125;    swap(arr, more, right);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = arr[index1];    arr[index1] = arr[index2];    arr[index2] = temp;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码解析-JDK1-8"><a href="#HashMap源码解析-JDK1-8" class="headerlink" title="HashMap源码解析(JDK1.8)"></a>HashMap源码解析(JDK1.8)</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在进行HashMap分析前，我期望解决以下问题：</p><ul><li>HashMap的底层数据结构是什么？</li><li>HashMap中增删改查操作的底部实现原理是什么？</li><li>HashMap是如何实现扩容的？</li><li>HashMap是如何解决hash冲突的？</li><li>HashMap为什么是非线程安全的？</li></ul><h3 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h3><p>HashMap 基于哈希表的 Map 接口的实现，key唯一的value可以重复，允许存储键为null(key = null),值为null(value = null)，元素没有顺序,同时不保证该顺序恒久不变。</p><p>在 JDK 1.8 之前是由“数组+链表”组成。JDK1.8的HashMap对之前做了较大的优化，其中最重要的一个优化就是将底层的数据结构由“数组+链表”变为了“数组+链表+红黑树”，值得一提的是只有当链表的长度大于8时.。除此之外HashMap是非线程安全的，因此在多个线程同时对HashMap中的同一个元素进行修改时，不能保证数据的唯一性。</p><h3 id="剖析结构"><a href="#剖析结构" class="headerlink" title="剖析结构"></a>剖析结构</h3><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p><img src="https://i.loli.net/2021/01/07/femFXPH2T8N5ZMv.png" alt="DataStruct1.7.png"></p><p>从上图我们可以看到，在jdk1.7中，首先是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，因为Entry具有Next引用，每一个Entry实体类实际上是一个单向的链表的头部，可以用来连接下一个Entry实体，又因为HashMap是按照Key的hash值来计算Entry在HashMap中存储的位置的，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。就这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高<strong>（链表不适合查找，适合增删）</strong>，反倒是下降了不少。</p><p>于是官方在JDK1.8的时候就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。</p><p><img src="https://i.loli.net/2021/01/07/1Qv4fyFu8rlpzXE.png" alt="DataStruct1.8.png"></p><p><strong>注意：</strong> <strong>要注意的是只有在链表的长度不小于8，且数组的长度不小于64的时候才会将链表转化为红黑树，</strong></p><h4 id="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"><a href="#这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。" class="headerlink" title="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"></a><strong>这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。</strong></h4><p><strong>因为：红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找一个元素的时间复杂度会从链表的o(n)降低为o(logn)。</strong></p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>源码</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4、重复步骤 3 直到某一指针达到序列尾；<br>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/WbeJEpiD9usgR31.gif" alt="mergeSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 排序入口函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    sortProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 分治</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (right == left) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 归并左边</span>    sortProcess(arr, left, mid);    <span class="hljs-comment">// 归并右边</span>    sortProcess(arr, mid + <span class="hljs-number">1</span>, right);    merge(arr, left, mid, right);&#125;<span class="hljs-comment">// 合并</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 辅助数组 开始下标</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = left;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 合并两个数组</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 两个指针必有一个未过界 需要处理</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) &#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= right) &#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 拷贝给原数组</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[left + i] = help[i];    &#125;&#125;</code></pre></div><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度:O(nlogn)</li><li>空间复杂度:O(N) 需要一个与排序数组长度相同的数组，进行辅助排序</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>归并排序是一个稳定的排序，只需在合并方法中，合并两个数组时用这行代码<code> help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]</code>,可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
