<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Netty【入门】</title>
    <link href="/2021/01/25/Netty%E3%80%90%E5%85%A5%E9%97%A8%E3%80%91/"/>
    <url>/2021/01/25/Netty%E3%80%90%E5%85%A5%E9%97%A8%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h1 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h1><p>对于这个问题，之前我写了一篇文章<a href="https://www.toutiao.com/i6842509002530619918/?group_id=6842509002530619918?group_id=6842509002530619918">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h1 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h1><p>相对地，Netty的优点有很多：</p><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2Y5MGVhNWYwMmIzMzQ4OGRiNGFhNTlhN2EzOGJhMWZi?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p></blockquote><blockquote><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p></blockquote><blockquote><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzYzZmE3Y2MyMzQwYzQxNTY4ZTEyNTM5NGEzN2I0ZDE1?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h1><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.20.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h1 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组 boosGroup、workerGroup</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建服务端的启动对象，设置参数</span>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();           <span class="hljs-comment">//设置两个线程组boosGroup和workerGroup</span>            bootstrap.group(bossGroup, workerGroup)            <span class="hljs-comment">//设置服务端通道实现类型    </span>                .channel(NioServerSocketChannel.class)                <span class="hljs-comment">//设置线程队列得到连接个数    </span>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)                <span class="hljs-comment">//设置保持活动连接状态    </span>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)                <span class="hljs-comment">//使用匿名内部类的形式初始化通道对象    </span>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">//给pipeline管道设置处理器</span>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyServerHandler());                    &#125;                &#125;);<span class="hljs-comment">//给workerGroup的EventLoop对应的管道设置处理器</span>            System.out.println(<span class="hljs-string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);            <span class="hljs-comment">//绑定端口号，启动服务端</span>            ChannelFuture channelFuture = bootstrap.bind(<span class="hljs-number">6666</span>).sync();            <span class="hljs-comment">//对关闭通道进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully()            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><h1 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><span class="hljs-comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取客户端发送过来的消息</span>        ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;发送的消息：&quot;</span> +         byteBuf.toString(CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发送消息给客户端</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));   &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发生异常，关闭通道</span>        ctx.close();    &#125;&#125;</code></pre></div><h1 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        NioEventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//创建bootstrap对象，配置参数</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-comment">//设置线程组</span>           bootstrap.group(eventExecutors)                <span class="hljs-comment">//设置客户端的通道实现类型    </span>               .channel(NioSocketChannel.class)                <span class="hljs-comment">//使用匿名内部类初始化通道</span>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//添加客户端通道的处理器</span>                     ch.pipeline().addLast(<span class="hljs-keyword">new</span> MyClientHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);            <span class="hljs-comment">//连接服务端</span>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>).sync()            <span class="hljs-comment">//对通道关闭进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-comment">//关闭线程组</span>            eventExecutors.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><h1 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//发送消息到服务端</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       <span class="hljs-comment">//接收服务端发送过来的消息</span>       ByteBuf byteBuf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));    &#125;&#125;</code></pre></div><h1 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h1><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzA3MjJjYzJiNzQ4ZjQxNzE4YmYzZTk2YjBkZDRkYWRl?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>MyClient打印结果：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzdkYzliNTc5ZTc3MDQ3NDBiMzVmZjE3MTQzNGQyMjNl?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="五、Netty的特性与重要组件"><a href="#五、Netty的特性与重要组件" class="headerlink" title="五、Netty的特性与重要组件"></a>五、Netty的特性与重要组件</h1><h1 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h1><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取到线程池eventLoop，添加线程，执行</span>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span>                    Thread.sleep(<span class="hljs-number">1000</span>);                    System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2ExYTVhOTJjMjI3ZjRmMTA4NjBiYzJmMjNkNzRlYzE0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h1><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span>            Thread.sleep(<span class="hljs-number">1000</span>);            System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<span class="hljs-comment">//5秒后执行</span></code></pre></div><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2E4ZTUxZTdkMjFjYjQ0Yzg4MGRmMTFmMjk4NjU0MTFj?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h1><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);</code></pre></div><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//添加监听器</span>channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;    <span class="hljs-comment">//使用匿名内部类，ChannelFutureListener接口</span>    <span class="hljs-comment">//重写operationComplete方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//判断是否操作成功 </span>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;            System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;连接失败&quot;</span>);        &#125;    &#125;&#125;);</code></pre></div><h1 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h1><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2JkMDg4NzAxODA2NDQxYjViNGU4ZGUzOTNiYjczYzI3?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzc1YzNjMWMzOWYxNTRjZTVhNjg1ZTJmODkyMjgyNDYx?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h1><p>在上一篇文章<a href="https://www.toutiao.com/i6844892035749511684/?group_id=6844892035749511684">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>在上一篇文章<a href="https://www.toutiao.com/i6844892035749511684/?group_id=6844892035749511684">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><div class="hljs code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用一个常量保存</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(            <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;        logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);    &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;        <span class="hljs-comment">//如果不传入，则使用常量的值，也就是cpu核数的两倍        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span>&#125;</code></pre></div><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置bossGroup线程数为1</span>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<span class="hljs-comment">//设置workerGroup线程数为16</span>EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">16</span>);</code></pre></div><h1 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h1><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzZkZmEyZTMwNGYyNDQ5MWI5NWM3OWQxMjU0MjNlZDc4?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>使用debug模式可以看到</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2ZlOWVmMzRkNWIxOTQyMDU4ZTcyNDg1ZDQxMDQwMjY0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。 <strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。 OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//server端代码，跟上面几乎一样，只需改三个地方</span><span class="hljs-comment">//这个地方使用的是OioEventLoopGroup</span>EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> OioEventLoopGroup();ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();bootstrap.group(bossGroup)<span class="hljs-comment">//只需要设置一个线程组boosGroup</span>    .channel(OioServerSocketChannel.class)<span class="hljs-comment">//设置服务端通道实现类型</span>    <span class="hljs-comment">//client端代码，只需改两个地方</span>    <span class="hljs-comment">//使用的是OioEventLoopGroup</span>    EventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> OioEventLoopGroup();<span class="hljs-comment">//通道类型设置为OioSocketChannel</span>bootstrap.group(eventExecutors)<span class="hljs-comment">//设置线程组</span>.channel(OioSocketChannel.class)<span class="hljs-comment">//设置客户端的通道实现类型</span></code></pre></div><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。 NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h1 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h1><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。 <strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。 <strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h1 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h1><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类的形式初始化通道对象</span>bootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//给pipeline管道设置自定义的处理器</span>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> MyServerHandler());&#125;&#125;);</code></pre></div><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li>注册事件 fireChannelRegistered。</li><li>连接建立事件 fireChannelActive。</li><li>读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li>异常通知事件 fireExceptionCaught。</li><li>用户自定义事件 fireUserEventTriggered。</li><li>Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li>连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li>端口绑定 bind。</li><li>连接服务端 connect。</li><li>写事件 write。</li><li>刷新时间 flush。</li><li>读事件 read。</li><li>主动断开连接 disconnect。</li><li>关闭 channel 事件 close。</li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h1 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h1><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h1 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//释放掉所有的资源，包括创建的线程</span>bossGroup.shutdownGracefully();workerGroup.shutdownGracefully();</code></pre></div><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h1 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h1><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),</p><p>the configuration parameters of the channel (e.g. receive buffer size),</p><p>the I/O operations that the channel supports (e.g. read, write, connect, and bind),</p><p>and the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li>通道当前的状态（例如它是打开？还是已连接？）</li><li>channel的配置参数（例如接收缓冲区的大小）</li><li>channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h1 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h1><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//如果通道打开，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRegistered</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果通道注册到EventLoop，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果通道处于活动状态并且已连接，则返回true</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</span></code></pre></div><p>以上就是获取channel的四种状态的方法。</p><h1 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h1><p>获取单条配置信息，使用getOption()，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelConfig config = channel.config();<span class="hljs-comment">//获取配置参数</span><span class="hljs-comment">//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);</span><span class="hljs-comment">//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</span></code></pre></div><p>获取多条配置信息，使用getOptions()，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();<span class="hljs-keyword">for</span> (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123; System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">SO_REUSEADDR : false</span><span class="hljs-comment">WRITE_BUFFER_LOW_WATER_MARK : 32768</span><span class="hljs-comment">WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)</span><span class="hljs-comment">SO_BACKLOG : 128</span><span class="hljs-comment"></span><span class="hljs-comment">以下省略...</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span></code></pre></div><h1 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h1><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;这波啊，这波是肉蛋葱鸡~&quot;</span>, CharsetUtil.UTF_8))&#125;</code></pre></div><p>客户端控制台：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>收到服务端/<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6666</span>的消息：这波啊，这波是肉蛋葱鸡~</code></pre></div><p><strong>连接</strong>操作，代码演示：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ChannelFuture connect = channelFuture.channel().connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>));<span class="hljs-comment">//一般使用启动器，这种方式不常用</span></code></pre></div><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取ChannelPipeline对象</span>ChannelPipeline pipeline = ctx.channel().pipeline();<span class="hljs-comment">//往pipeline中添加ChannelHandler处理器，装配流水线</span>pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());</code></pre></div><h1 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h1><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://www.toutiao.com/i6842509002530619918/?group_id=6842509002530619918?group_id=6842509002530619918">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzRhOTA5NDc1MWFiZTRkODdhMDMxZTk0NGI2NTVjYzM0?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h1><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wNi10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzU2OGQ1ZTcxZjBlMzRiZWU4NzdiZTNhMjQ3NjBjNzZk?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h1 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h1><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzMyMzZlNDIzYjgwNzRmYjA5ZTkwYThjOTA4ODRjZjky?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123; <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>); succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>); voidPromise =  <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>); <span class="hljs-comment">//设置头结点head，尾结点tail</span> tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>); head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>); head.next = tail; tail.prev = head;&#125;</code></pre></div><p>下面我用一张图来表示，会更加清晰一点：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzlmYzRmYzQwNTljYTQyNDI5MmFhOGYwMjEwOTE0Zjc1?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><h1 id="5-9-EventLoopGroup"><a href="#5-9-EventLoopGroup" class="headerlink" title="5.9 EventLoopGroup"></a>5.9 EventLoopGroup</h1><p>我们先看一下EventLoopGroup的类图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlLzAzNjEwOTRjNDkzYzRmNTg5ZjExOWE3NzRlZmYyOTE3?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h1 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h1><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger idx = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//idx.getAndIncrement()相当于idx++，然后对任务长度取模</span>    <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];&#125;</code></pre></div><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy10dC5ieXRlaW1nLmNvbS9vcmlnaW4vcGdjLWltYWdlL2JiMDUzZDczMDZlMDRhYjI5ZWE0OGRkNTM2MjNjNmFj?x-oss-process=image/format,png" alt="超详细Netty入门，看这篇就够了"></p><p>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构【前缀树】</title>
    <link href="/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%89%8D%E7%BC%80%E6%A0%91%E3%80%91/"/>
    <url>/2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%90%E5%89%8D%E7%BC%80%E6%A0%91%E3%80%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ【高可用】</title>
    <link href="/2021/01/25/RabbitMQ%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%91/"/>
    <url>/2021/01/25/RabbitMQ%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h1><blockquote><p> RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p></blockquote><h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。谈不到高可用。</p><h2 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h2><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个，生产者创建的queue只会放在一个RabbitMQ的实例中，其余的实例会同步queue的元数据(元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例)，在消费者进行消费的时候，连接到另一个实例上时，这个实例会通过同步的元数据找到queue所在的实例，然后请求数据。</p><p><img src="https://i.loli.net/2021/01/25/lFR4BHY8fn95hUE.png" alt="jiqun01.png"></p><p>这种方式很麻烦，也不怎么好。因为这中集群方式，导致消费者要么每次随机连接一个实例然后拉取数据，要么固定连接那个 <strong>queue</strong> 所在实例消费数据，前者有<strong>数据拉取的开销</strong>，后者会有<strong>单实例性能瓶颈</strong>。这种集群模式还会有一个<strong>严重的后果</strong>就是如果那个存放 queue 的RabbitMQ实例<strong>宕机</strong>了，会导致接下来其他RabbitMQ实例就无法从那个实例拉取，如果你<strong>开启了消息持久化</strong>，让 RabbitMQ 落地存储消息的话，<strong>消息不一定会丢</strong>，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据,如果<strong>没开消息持久化</strong>，queue的数据还会丢失。</p><p>这种集群其余节点<strong>高度依赖</strong>queue所在的RabbitMQ节点，这样就<strong>没有什么所谓的高可用性</strong>，<strong>这方案倒是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><h2 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h2><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/mq-8.png" alt="mq-8"></p><h3 id="如何开启这个镜像集群模式呢？"><a href="#如何开启这个镜像集群模式呢？" class="headerlink" title="如何开启这个镜像集群模式呢？"></a>如何开启这个镜像集群模式呢？</h3><p>其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><h3 id="镜像集群模式优缺点"><a href="#镜像集群模式优缺点" class="headerlink" title="镜像集群模式优缺点"></a>镜像集群模式优缺点</h3><p>优点：你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。</p><p>缺点：</p><ul><li>第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！</li><li>第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis【主从复制】</title>
    <link href="/2021/01/24/redis%E3%80%90%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%91/"/>
    <url>/2021/01/24/redis%E3%80%90%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="redis【主从复制】"><a href="#redis【主从复制】" class="headerlink" title="redis【主从复制】"></a>redis【主从复制】</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>如果redis要支撑超过10万+的并发，那应该怎么做？</p><p>单机的redis几乎不太可能说QPS超过10万+，除非一些特殊情况，比如你的机器性能特别好，配置特别高，物理机，维护做的特别好，而且你的整体的操作不是太复杂。一般来说redis单机在几万上下。</p><p>如果想要超过10w+的并发，就要读写分离了。一般来说，对缓存一般都是用来支撑读高并发的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千，大量的请求都是读，一秒钟二十万次读</p></blockquote><h2 id="利用-redis-master-salve-replication【主从复制】实现的读写分离"><a href="#利用-redis-master-salve-replication【主从复制】实现的读写分离" class="headerlink" title="利用 redis master-salve replication【主从复制】实现的读写分离"></a>利用 redis master-salve replication【主从复制】实现的读写分离</h2><h3 id="1、图解redis-replication基本原理"><a href="#1、图解redis-replication基本原理" class="headerlink" title="1、图解redis replication基本原理"></a>1、图解redis replication基本原理</h3><p><img src="https://i.loli.net/2021/01/24/vjDWRi76h5XK9I4.png" alt="redis_1.png"></p><h3 id="2、redis-replication的核心机制"><a href="#2、redis-replication的核心机制" class="headerlink" title="2、redis replication的核心机制"></a>2、redis replication的核心机制</h3><p>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量<br>（2）一个master node是可以配置多个slave node的<br>（3）slave node也可以连接其他的slave node<br>（4）slave node做复制的时候，是不会block master node的正常工作的<br>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了<br>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</p><h3 id="3、master-node-持久化对于主从架构的安全保障的意义"><a href="#3、master-node-持久化对于主从架构的安全保障的意义" class="headerlink" title="3、master node 持久化对于主从架构的安全保障的意义"></a>3、master node 持久化对于主从架构的安全保障的意义</h3><h4 id="如果采用了主从架构，建议必须开启master-node的持久化！"><a href="#如果采用了主从架构，建议必须开启master-node的持久化！" class="headerlink" title="如果采用了主从架构，建议必须开启master node的持久化！"></a>如果采用了主从架构，建议必须开启master node的持久化！</h4><p>答：我们知道主从复制的架构中，所有的写操作交由master负责，slave分担读的操作，slave中的数据是从master同步过来的。假如master的rdb和aof都关闭了，数据全部在内存中，那么master宕机重启时，发现本地没有可以恢复的数据，导致master内存数据为空，然后master将空的数据集同步到slave节点，导致slave的数据全部清空。因此master必须要开启持久化！<br>即使我们采用高可用机制的哨兵模式，即master宕机时，slave节点通过选举转变为master节点，在这种情况下，可能哨兵模式还没检测到master节点宕机，master节点就自动重启了，因此还是可能导致所有slave节点数据清空。</p><h4 id="使用持久化机制master的各种备份方案，要不要做？"><a href="#使用持久化机制master的各种备份方案，要不要做？" class="headerlink" title="使用持久化机制master的各种备份方案，要不要做？"></a>使用持久化机制master的各种备份方案，要不要做？</h4><p>答案：<strong>要做的</strong>，如果说本地的所有文件丢失了，这时我们就可以从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的。</p><h3 id="4、redis-replication主从复制的核心原理"><a href="#4、redis-replication主从复制的核心原理" class="headerlink" title="4、redis replication主从复制的核心原理"></a>4、redis replication主从复制的核心原理</h3><ul><li><p>slave node启动的时候，会发送一个PSYNC命令给master node，</p></li><li><p>slave node第一次连接master node，那么会触发一次full resynchronization（全量备份）：</p><p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p></li><li><p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据;。</p></li><li><p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p></li></ul><h3 id="5、主从复制的断点续传"><a href="#5、主从复制的断点续传" class="headerlink" title="5、主从复制的断点续传"></a>5、主从复制的断点续传</h3><p>​           从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份，master node会在内存中创建一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p><p>但是如果没有找到对应的offset，那么就会执行一次resynchronization</p><h3 id="6、无磁盘化复制"><a href="#6、无磁盘化复制" class="headerlink" title="6、无磁盘化复制"></a>6、无磁盘化复制</h3><p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p><p>repl-diskless-sync<br>repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p><h3 id="7、过期key处理"><a href="#7、过期key处理" class="headerlink" title="7、过期key处理"></a>7、过期key处理</h3><p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>redis</tag>
      
      <tag>读写分离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis【持久化】</title>
    <link href="/2021/01/23/redis%E3%80%90%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%91/"/>
    <url>/2021/01/23/redis%E3%80%90%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="redis【持久化】"><a href="#redis【持久化】" class="headerlink" title="redis【持久化】"></a>redis【持久化】</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​         redis的缓存是基于内存的缓存，当redis突然挂掉的时候（不管是因为什么原因），其存放在内存中的数据就全部都丢失了，redis重启后数据就全部都没有了，这个时候就体现到了redis持久化的意义了。对于一个企业级的redis架构来说，持久化更是不可减少的。企业级redis集群架构的特点<strong>海量数据、高并发、高可用</strong>，持久化主要是做灾难恢复，数据恢复，但可以归类到高可用。</p><p><strong>没有做持久化的后果？</strong></p><p>​        如果你的redis宕机了，因为没有做持久化redis重启redis后，redis内数据是空的，这个时候如果大量请求打过来，redis数据为空，这时就会发生<strong>缓存雪崩</strong>问题，所有请求，没有在redis中命中，这时就会去数据库这种数据源头中去查询数据，大量的sql查询导致数据库并发量激增，然后就挂掉了，数据库挂掉后，你都没法去找数据缓存到redis里面去，redis的数据从哪儿来？从数据库来。数据库挂掉后还会影响其他系统应用。发生更大的灾难。</p><h2 id="1、RDB和AOF两种持久化机制的介绍"><a href="#1、RDB和AOF两种持久化机制的介绍" class="headerlink" title="1、RDB和AOF两种持久化机制的介绍"></a>1、RDB和AOF两种持久化机制的介绍</h2><ul><li>RDB持久化机制：对redis中的数据执行<strong>周期性的持久化</strong>。</li><li>AOF机制：对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</li></ul><p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制。通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云，云服务，如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务，需要注意的是：如果<strong>同时使用</strong>RDB和AOF两种持久化机制，那么在<strong>redis重启</strong>的时候，会使用<strong>AOF来重新构建数据</strong>，因为<strong>AOF中的数据更加完整</strong></p><h2 id="2、redis使用RDB"><a href="#2、redis使用RDB" class="headerlink" title="2、redis使用RDB"></a>2、redis使用RDB</h2><h3 id="默认开启RDB策略"><a href="#默认开启RDB策略" class="headerlink" title="默认开启RDB策略"></a>默认开启RDB策略</h3><p><code>redis.config</code> 中RDB相关配置</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">################################ SNAPSHOTTING  ################################</span><span class="hljs-comment">#</span><span class="hljs-comment"># Save the DB on disk:</span><span class="hljs-comment">#</span><span class="hljs-comment">#   save &lt;seconds&gt; &lt;changes&gt;</span><span class="hljs-comment">#</span><span class="hljs-comment">#   Will save the DB if both the given number of seconds and the given</span><span class="hljs-comment">#   number of write operations against the DB occurred.</span><span class="hljs-comment">#</span><span class="hljs-comment">#   In the example below the behaviour will be to save:</span><span class="hljs-comment">#   after 900 sec (15 min) if at least 1 key changed</span><span class="hljs-comment">#   after 300 sec (5 min) if at least 10 keys changed</span><span class="hljs-comment">#   after 60 sec if at least 10000 keys changed</span><span class="hljs-comment">#</span><span class="hljs-comment">#   <span class="hljs-doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span><span class="hljs-comment">#</span><span class="hljs-comment">#   It is also possible to remove all the previously configured save</span><span class="hljs-comment">#   points by adding a save directive with a single empty string argument</span><span class="hljs-comment">#   like in the following example:</span><span class="hljs-comment">#</span><span class="hljs-comment">#   save &quot;&quot;</span><span class="hljs-attr">save</span> <span class="hljs-string">900 1</span><span class="hljs-attr">save</span> <span class="hljs-string">300 10</span><span class="hljs-attr">save</span> <span class="hljs-string">60 10000</span></code></pre></div><p><code>save 60 10000</code> 的说明：每隔60s，如果有超过10000个key发生了变更，就会生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，这个操作也被称之为snapshotting-快照。也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成，save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件，会覆盖之前的dump.rdb文件。</p><p><strong>注意：</strong>在执行<code>redis-cli shutdow</code>命令时，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照。要想测试发生故障的需要<code>ps -ef|grep redis</code> 查看redis进程号pid，然后<code>kill -9 pid</code> 。这样就能测试RDB了。</p><h3 id="RDB持久化机制的工作流程"><a href="#RDB持久化机制的工作流程" class="headerlink" title="RDB持久化机制的工作流程"></a>RDB持久化机制的工作流程</h3><p>（1）redis根据配置自己尝试去生成rdb快照文件<br>（2）fork一个子进程出来<br>（3）子进程尝试将数据dump到临时的rdb快照文件中<br>（4）完成rdb快照文件的生成之后，就替换之前的旧的快照文件</p><h2 id="3、redis-使用AOF"><a href="#3、redis-使用AOF" class="headerlink" title="3、redis 使用AOF"></a>3、redis 使用AOF</h2><p>AOF持久化：默认是关闭的，默认开启RDB机制。</p><h3 id="开启AOF持久化机制"><a href="#开启AOF持久化机制" class="headerlink" title="开启AOF持久化机制"></a>开启AOF持久化机制</h3><p><code>redis.config</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">############################# APPEND ONLY MODE ###############################</span><span class="hljs-comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><span class="hljs-comment"># good enough in many applications, but an issue with the Redis process or</span><span class="hljs-comment"># a power outage may result into a few minutes of writes lost (depending on</span><span class="hljs-comment"># the configured save points).</span><span class="hljs-comment">#</span><span class="hljs-comment"># The Append Only File is an alternative persistence mode that provides</span><span class="hljs-comment"># much better durability. For instance using the default data fsync policy</span><span class="hljs-comment"># (see later in the config file) Redis can lose just one second of writes in a</span><span class="hljs-comment"># dramatic event like a server power outage, or a single write if something</span><span class="hljs-comment"># wrong with the Redis process itself happens, but the operating system is</span><span class="hljs-comment"># still running correctly.</span><span class="hljs-comment">#</span><span class="hljs-comment"># AOF and RDB persistence can be enabled at the same time without problems.</span><span class="hljs-comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><span class="hljs-comment"># with the better durability guarantees.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Please check http://redis.io/topics/persistence for more information.</span><span class="hljs-comment"># appendonly no</span><span class="hljs-comment"># 需要将appendonly 设置为yes 来开启 appendonly</span><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes </span></code></pre></div><p>打开AOF持久化机制之后，redis每次接收到一条写命令，就会写入日志文件中，再写入日志文件之前，先写入os cache的，然后每隔一定时间再fsync一下，将数据刷入日志文件。RDB和AOF同时开启，恢复数据时采用AOF机制。</p><h3 id="redis在进行fsync时有三种策略可以选择"><a href="#redis在进行fsync时有三种策略可以选择" class="headerlink" title="redis在进行fsync时有三种策略可以选择"></a>redis在进行fsync时有三种策略可以选择</h3><ul><li><strong>always</strong>  每次写入一条数据，立即将这个数据对应的写日志 fsync 到磁盘上去，性能非常非常差，吞吐量很低; 确保说redis里的数据一条都不丢，那就只能这样了</li><li><strong>everysec</strong> 每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万。</li><li><strong>no</strong> 仅仅redis负责将数据写入os cache就撒手不管了，然后后面 os 自己会时不时有自己的策略将数据刷入磁盘，不可控了</li></ul><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># The fsync() call tells the Operating System to actually write data on disk</span><span class="hljs-comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span><span class="hljs-comment"># data on disk, some other OS will just try to do it ASAP.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Redis supports three different modes:</span><span class="hljs-comment">#</span><span class="hljs-comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster. </span><span class="hljs-comment"># always: fsync after every write to the append only log. Slow, Safest.</span><span class="hljs-comment"># everysec: fsync only one time every second. Compromise.</span><span class="hljs-comment">#</span><span class="hljs-comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><span class="hljs-comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><span class="hljs-comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span><span class="hljs-comment"># it wants, for better performances (but if you can live with the idea of</span><span class="hljs-comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><span class="hljs-comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><span class="hljs-comment"># everysec.</span><span class="hljs-comment">#</span><span class="hljs-comment"># More details please check the following article:</span><span class="hljs-comment"># http://antirez.com/post/redis-persistence-demystified.html</span><span class="hljs-comment">#</span><span class="hljs-comment"># If unsure, use &quot;everysec&quot;.</span><span class="hljs-comment"># appendfsync always </span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec</span><span class="hljs-comment"># appendfsync no</span></code></pre></div><h3 id="AOF-Rewrite"><a href="#AOF-Rewrite" class="headerlink" title="AOF Rewrite"></a>AOF Rewrite</h3><p>redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉，redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中，所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件只有一个，会不断的膨胀，到很大很大。</p><p>所以AOF会自动在后台每隔一定时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了; redis此时内存只剩下10万; 基于内存中当前的10万数据构建一套最新的日志并写入到AOF中，覆盖之前的老日志;。确保AOF日志文件不会过大，保持跟redis内存数据量一致。</p><p><strong>需要注意的是</strong>：<strong>redis 2.4</strong>之前，还需要手动，开发一些脚本，crontab，通过BGREWRITEAOF命令去执行AOF rewrite，但是redis 2.4之后，会自动进行rewrite操作。</p><p>在redis.config中，可以配置rewrite策略，这个一般不用配置。</p><p><strong>rewrite过程</strong></p><p>（1）redis fork一个子进程<br>（2）子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志<br>（3）redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件<br>（4）子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中<br>（5）用新的日志文件替换掉旧的日志文件</p><h3 id="AOF破损文件的修复"><a href="#AOF破损文件的修复" class="headerlink" title="AOF破损文件的修复"></a>AOF破损文件的修复</h3><p>如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损，用<code>redis-check-aof --fix filename  </code>命令来修复破损的AOF文件。</p><h2 id="4、AOF和RDB同时工作"><a href="#4、AOF和RDB同时工作" class="headerlink" title="4、AOF和RDB同时工作"></a>4、AOF和RDB同时工作</h2><p>（1）如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis在执行AOF rewrite，那么就不会执行RDB snapshotting。<br>（2）如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行 AOF rewrite。<br>（3）同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整。</p><h2 id="5、RDB持久化机制的优缺点"><a href="#5、RDB持久化机制的优缺点" class="headerlink" title="5、RDB持久化机制的优缺点"></a>5、RDB持久化机制的优缺点</h2><h3 id="RDB持久化机制的优点"><a href="#RDB持久化机制的优点" class="headerlink" title="RDB持久化机制的优点"></a>RDB持久化机制的优点</h3><p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，以预定好的备份策略来定期备份redis中的数据</p><p>（2）RDB对redis对外提供的读写服务，对redis影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。</p><p>（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速。</p><h3 id="RDB持久化机制的缺点"><a href="#RDB持久化机制的缺点" class="headerlink" title="RDB持久化机制的缺点"></a>RDB持久化机制的缺点</h3><p>（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候一旦redis进程宕机，那么会丢失最近5分钟的数据。</p><p>（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</p><h2 id="6、AOF持久化机制的优缺点"><a href="#6、AOF持久化机制的优缺点" class="headerlink" title="6、AOF持久化机制的优缺点"></a>6、AOF持久化机制的优缺点</h2><h3 id="AOF持久化机制的优点"><a href="#AOF持久化机制的优点" class="headerlink" title="AOF持久化机制的优点"></a>AOF持久化机制的优点</h3><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p><p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p><p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><h3 id="AOF持久化机制的缺点"><a href="#AOF持久化机制的缺点" class="headerlink" title="AOF持久化机制的缺点"></a>AOF持久化机制的缺点</h3><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。</p><p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p><h2 id="7、RDB和AOF到底该如何选择"><a href="#7、RDB和AOF到底该如何选择" class="headerlink" title="7、RDB和AOF到底该如何选择"></a>7、RDB和AOF到底该如何选择</h2><p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据</p><p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p><p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p><h2 id="8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？"><a href="#8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？" class="headerlink" title="8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？"></a>8、企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？</h2><h3 id="1、企业级的持久化的配置策略"><a href="#1、企业级的持久化的配置策略" class="headerlink" title="1、企业级的持久化的配置策略"></a>1、企业级的持久化的配置策略</h3><p>在企业中，RDB的生成策略，用默认的也差不多</p><p>对于这个save 60 10000：如果你希望尽可能确保说，RDB最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，低峰期，数据量很少，也没必要</p><p>10000-&gt;生成RDB，1000-&gt;RDB，这个根据你自己的应用和业务的数据量，你自己去决定</p><p>AOF机制要一定要打开，选择 everysec 即可。 </p><p>auto-aof-rewrite-percentage 100: 就是当前AOF大小膨胀到超过上次100%，上次的两倍<br>auto-aof-rewrite-min-size 64mb: 根据你的数据量来定，16mb，32mb</p><h3 id="2、企业级的数据备份方案"><a href="#2、企业级的数据备份方案" class="headerlink" title="2、企业级的数据备份方案"></a>2、企业级的数据备份方案</h3><p>RDB非常适合做冷备，每次生成之后，就不会再有修改了</p><h4 id="数据备份方案"><a href="#数据备份方案" class="headerlink" title="数据备份方案"></a>数据备份方案</h4><p>（1）写crontab定时调度脚本去做数据备份<br>（2）每小时都copy一份rdb的备份，到一个目录中去，仅仅保留最近48小时的备份<br>（3）每天都保留一份当日的rdb的备份，到一个目录中去，仅仅保留最近1个月的备份<br>（4）每次copy备份的时候，都把太旧的备份给删了<br>（5）每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去</p><h4 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h4><p>每小时copy一次备份，删除48小时前的数据</p><p><code>redis_rab_copy_hourly.sh</code></p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh </span>cur_date=`date +%Y%m%d%k`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>mkdir /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>cp /var/redis/6379/dump.rdb /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>del_date=`date -d -48hour +%Y%m%d%k`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$del_date</span></code></pre></div><p>创建定时任务执行<code>crontab -e</code> 写入 下面内容 实现每小时执行redis_rab_copy_hourly.sh</p><div class="hljs code-wrapper"><pre><code class="hljs bash">0 * * * * sh /usr/<span class="hljs-built_in">local</span>/redis/copy/redis_rdb_copy_hourly.sh</code></pre></div><p>每天copy一次备份删除一个月以前的数据</p><p>执行<code>vi redis_rdb_copy_daily.sh</code> 写入一下内容</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh </span>cur_date=`date +%Y%m%d`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>mkdir /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>cp /var/redis/6379/dump.rdb /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$cur_date</span>del_date=`date -d -1month +%Y%m%d`rm -rf /usr/<span class="hljs-built_in">local</span>/redis/snapshotting/<span class="hljs-variable">$del_date</span></code></pre></div><p>创建定时任务执行<code>crontab -e</code> 写入 下面内容 实现每小时执行redis_rab_copy_hourly.sh</p><div class="hljs code-wrapper"><pre><code class="hljs bash">0 0 * * * sh /usr/<span class="hljs-built_in">local</span>/redis/copy/redis_rdb_copy_daily.sh</code></pre></div><h4 id="数据恢复方案"><a href="#数据恢复方案" class="headerlink" title="数据恢复方案"></a>数据恢复方案</h4><p>（1）如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据，如果fsync选择的策略为 everysec，最多就丢一秒的数</p><p>（2）如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，AOF没有破损，也是可以直接基于AOF恢复的，AOF append-only，顺序写入，如果AOF文件破损，那么用redis-check-aof fix进行修复。</p><p>（3）如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复</p><p>当前最新的AOF和RDB文件都出现了丢失/损坏到无法恢复，一般不是机器的故障，这时找到RDB最新的一份备份，小时级的备份可以了，小时级的肯定是最新的，copy到redis里面去，就可以恢复到某一个小时的数据。</p><p>（4）如果当前机器上的所有RDB文件全部损坏，那么从远程的云服务上拉取最新的RDB快照回来恢复数据</p><p>（5）如果是发现有重大的数据错误，比如某个小时上线的程序一下子将数据全部污染了，数据全错了，那么可以选择某个更早的时间点，对数据进行恢复。</p><h4 id="恢复注意"><a href="#恢复注意" class="headerlink" title="恢复注意"></a>恢复注意</h4><p>AOF和RDB都开启的时候，会优先用AOF恢复数据，如果此时appendonly.aof不存在，redis会创建一个新的空的aof文件，会导致redis中没有任何数据。因此如果开启了AOF机制，一定要保证appendonly.aof一定要存在，并且数据是正确的。</p><p>这时发现AOF文件出错，需要基于RDB进行恢复，我们怎么能，完美的恢复数据，同时还保持aof和rdb的双开？</p><p>停止redis，关闭aof，拷贝rdb备份，重启redis，确认数据恢复，直接在命令行热修改redis配置，打开aof，这个redis就会将内存中的数据对应的日志，写入aof文件中</p><p>此时aof和rdb两份数据文件的数据就同步了</p><p><strong>注意：</strong>redis config set 热修改配置参数，可能配置文件中的实际的参数没有被持久化的修改，再次停止redis，手动修改配置文件，打开aof的命令，再次重启redis。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
      <tag>持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq学习</title>
    <link href="/2021/01/19/RabbitMq%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/19/RabbitMq%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabbit-MQ-学习【7种工作模式】"><a href="#Rabbit-MQ-学习【7种工作模式】" class="headerlink" title="Rabbit MQ 学习【7种工作模式】"></a>Rabbit MQ 学习【7种工作模式】</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-首先安装Rabbit-MQ"><a href="#1-首先安装Rabbit-MQ" class="headerlink" title="1.首先安装Rabbit MQ"></a>1.首先安装Rabbit MQ</h3><blockquote><p> <strong>教程网址</strong> <a href="https://blog.csdn.net/qq_47588845/article/details/107986373">https://blog.csdn.net/qq_47588845/article/details/107986373</a></p></blockquote><h3 id="2-创建一个springboot项目"><a href="#2-创建一个springboot项目" class="headerlink" title="2.创建一个springboot项目"></a>2.创建一个springboot项目</h3><h3 id="3-导入依赖"><a href="#3-导入依赖" class="headerlink" title="3. 导入依赖"></a>3. 导入依赖</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--lombok--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4-application-properties"><a href="#4-application-properties" class="headerlink" title="4.application.properties"></a>4.application.properties</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">##################</span><span class="hljs-comment">####rabbitmq######</span><span class="hljs-comment">##################</span><span class="hljs-comment">#主机地址</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx</span><span class="hljs-comment">#端口号</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">xxxx </span><span class="hljs-comment">#账号密码</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">xxxx</span><span class="hljs-comment">#密码</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">xxxx</span></code></pre></div><h2 id="一-简单模式-simple"><a href="#一-简单模式-simple" class="headerlink" title="一.简单模式 (simple)"></a>一.简单模式 (simple)</h2><h3 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，一个消费者。 一对一。消息发布者（Publish）将消息放入队列（默认交换机）。消息的消费者（Consumer）监听消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除</p><p><strong>隐患：</strong>消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失,这里可以设置成手动的 ack, 但如果设置成手动 ack，处理完后要及时发送 ack 消息给队列，否则会造成内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/20200103230605348.png" alt="simple模式"></p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p><strong>将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人</strong></p><h3 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）"><a href="#3-1-发布端（Publish）" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类"><a href="#RabbitMQ-配置类" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口"><a href="#消息推送接口" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）"><a href="#3-2-消费端（Consumer）" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><blockquote><p>发送成功后，控制台会打印如下消息</p><p>Sender : hi, fanout msg </p><p>队列queue1 接收的消息 is hi, fanout msg </p></blockquote><h2 id="二-工作模式-work"><a href="#二-工作模式-work" class="headerlink" title="二.工作模式 (work)"></a>二.工作模式 (work)</h2><h3 id="1-要点-1"><a href="#1-要点-1" class="headerlink" title="1. 要点"></a>1. 要点</h3><p>一个生产者，多个消费者，消息被多个消费者竞争接收。 一对多消息产生者将消息放入队列消费者可以有多个，消费者 1, 消费者 2, 同时监听同一个队列，消息被消费。C1 C2 共同争抢当前的消息队列内容，谁先拿到谁负责消费消息</p><p><strong>隐患：</strong>高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关 (syncronize, 与同步锁的性能不一样) 保证一条消息只能被一个消费者使用</p><p><img src="https://img-blog.csdnimg.cn/20200104104835781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="工作模式"></p><h3 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>一个订单的处理需要 10s，有多个订单可以同时放到消息队列，然后让多个消费者同时处理，这样就是并行了，而不是单个消费者的串行情况</p><h3 id="3-代码演示-1"><a href="#3-代码演示-1" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-1"><a href="#3-1-发布端（Publish）-1" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="rabbitMQ配置类"><a href="#rabbitMQ配置类" class="headerlink" title="rabbitMQ配置类"></a>rabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>,context);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-1"><a href="#消息推送接口-1" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            messageProducer.send();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-1"><a href="#3-2-消费端（Consumer）-1" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;消费者2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/XJloczuLCaQtm6W.png" alt="result1.png"></p><h2 id="三-publish-subscribe：发布订阅-共享资源"><a href="#三-publish-subscribe：发布订阅-共享资源" class="headerlink" title="三. publish/subscribe：发布订阅 (共享资源)"></a>三. publish/subscribe：发布订阅 (共享资源)</h2><h3 id="1-要点-2"><a href="#1-要点-2" class="headerlink" title="1. 要点"></a>1. 要点</h3><blockquote><p>一个生产者，多个消费者，消息复制多份，每个消费者接收相同的消息。 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200104110859450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg3NzIwNA==,size_16,color_FFFFFF,t_70" alt="发布订阅模式"></p><h3 id="2-应用场景-2"><a href="#2-应用场景-2" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p><strong>更新商品库存后需要通知多个缓存和多个数据库，这里的结构应该是：</strong></p><ul><li>一个 fanout 类型交换机扇出两个个消息队列，分别为缓存消息队列、数据库消息队列</li><li>一个缓存消息队列对应着多个缓存消费者</li><li>一个数据库消息队列对应着多个数据库消费者</li></ul><h3 id="3-代码演示-2"><a href="#3-代码演示-2" class="headerlink" title="3. 代码演示"></a>3. 代码演示</h3><h4 id="3-1-发布端（Publish）-2"><a href="#3-1-发布端（Publish）-2" class="headerlink" title="3.1 发布端（Publish）"></a>3.1 发布端（Publish）</h4><h5 id="RabbitMQ-配置类-1"><a href="#RabbitMQ-配置类-1" class="headerlink" title="RabbitMQ 配置类"></a>RabbitMQ 配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  rabbitMQ配置类</span><span class="hljs-comment"> */</span>@Configuration<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> &#123;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    @Bean    <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(<span class="hljs-string">&quot;fanoutExchange&quot;</span>);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span>(<span class="hljs-params">Queue queue1, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange);    &#125;    @Bean    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span>(<span class="hljs-params">Queue queue2, FanoutExchange fanoutExchange</span>)</span> &#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange);    &#125;&#125;</code></pre></div><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, context);        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchange&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, context);    &#125;&#125;</code></pre></div><h5 id="接口消息推送接口"><a href="#接口消息推送接口" class="headerlink" title="接口消息推送接口"></a>接口消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        messageProducer.send();        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端（Consumer）-2"><a href="#3-2-消费端（Consumer）-2" class="headerlink" title="3.2 消费端（Consumer）"></a>3.2 消费端（Consumer）</h4><h5 id="消息消费者-2"><a href="#消息消费者-2" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span>@Component@Slf4j<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> &#123;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue1&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    @RabbitListener(queuesToDeclare = @Queue(<span class="hljs-string">&quot;queue2&quot;</span>))    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span>(<span class="hljs-params">String message</span>)</span> &#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/17/6OQDhpvs43y2RTN.png" alt="result2.png"></p><h2 id="四-路由模式（Routing）"><a href="#四-路由模式（Routing）" class="headerlink" title="四.路由模式（Routing）"></a>四.路由模式（Routing）</h2><h3 id="1-要点-3"><a href="#1-要点-3" class="headerlink" title="1.要点"></a>1.要点</h3><p>​        有选择地（Routing key）接收消息，发送消息到交换机并且要指定路由 key ，消费者将队列绑定到交换机时需要指定路由 key，仅消费指定路由 key 的消息</p><p><img src="https://i.loli.net/2021/01/18/JSeC3wVNFcdxUsK.png" alt="routing.png"></p><h3 id="2-应用场景-3"><a href="#2-应用场景-3" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p>​        如在商品库存中增加了 1 台 iphone12，iphone12 促销活动消费者指定 routing key 为 iphone12，只有此促销活动会接收到消息，其它促销活动不关心也不会消费此 routing key 的消息</p><h3 id="3-代码演示-3"><a href="#3-代码演示-3" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1-发布端"><a href="#3-1-发布端" class="headerlink" title="3.1 发布端"></a>3.1 发布端</h4><h5 id="RabbitMQ配置类"><a href="#RabbitMQ配置类" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, DirectExchange directExchange)</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(directExchange).with(<span class="hljs-string">&quot;hello.queue.2&quot;</span>);    &#125;    &#125;</code></pre></div><h5 id="消息生产者-2"><a href="#消息生产者-2" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-2"><a href="#消息推送接口-2" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.direct&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-消费端"><a href="#3-2-消费端" class="headerlink" title="3.2 消费端"></a>3.2 消费端</h4><h5 id="消息消费者-3"><a href="#消息消费者-3" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/JGFDrAOxs7XaeqS.png" alt="result3.png"></p><h2 id="五-主题模式（Topics）"><a href="#五-主题模式（Topics）" class="headerlink" title="五.主题模式（Topics）"></a>五.主题模式（Topics）</h2><h3 id="1-要点-4"><a href="#1-要点-4" class="headerlink" title="1.要点"></a>1.要点</h3><p><img src="https://i.loli.net/2021/01/18/jC5eb47GIqRdcHz.png" alt="topic.png"></p><h3 id="2-应用场景-4"><a href="#2-应用场景-4" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><h3 id="3-代码演示-4"><a href="#3-代码演示-4" class="headerlink" title="3.代码演示"></a>3.代码演示</h3><h4 id="3-1发布端"><a href="#3-1发布端" class="headerlink" title="3.1发布端"></a>3.1发布端</h4><h5 id="RabbitMQ配置类-1"><a href="#RabbitMQ配置类-1" class="headerlink" title="RabbitMQ配置类"></a>RabbitMQ配置类</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * RabbitMQ配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue2&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个交换机</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue1</span><span class="hljs-params">(Queue queue1, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue1).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.1&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingExchangeQueue2</span><span class="hljs-params">(Queue queue2, TopicExchange topicExchange)</span> </span>&#123;        <span class="hljs-comment">// 将交换机与队列绑定</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue2).to(topicExchange).with(<span class="hljs-string">&quot;hello.queue.*&quot;</span>);    &#125;&#125;</code></pre></div><h5 id="消息生产者-3"><a href="#消息生产者-3" class="headerlink" title="消息生产者"></a>消息生产者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息生产者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String exchange, String routingKey, String msg)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;Sender : &#123;&#125;&quot;</span>, msg);        rabbitTemplate.convertAndSend(exchange, routingKey, msg);    &#125;&#125;</code></pre></div><h5 id="消息推送接口-3"><a href="#消息推送接口-3" class="headerlink" title="消息推送接口"></a>消息推送接口</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息推送接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageProducer messageProducer;    <span class="hljs-meta">@GetMapping(&quot;/push&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//偶数往2里发，奇数往1里发</span>            String key = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;hello.queue.2&quot;</span> : <span class="hljs-string">&quot;hello.queue.1&quot;</span>;            messageProducer.send(<span class="hljs-string">&quot;hello.exchange.topic&quot;</span>, key, key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="3-2消费端"><a href="#3-2消费端" class="headerlink" title="3.2消费端"></a>3.2消费端</h4><h5 id="消息消费者-4"><a href="#消息消费者-4" class="headerlink" title="消息消费者"></a>消息消费者</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 消息消费者</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumers</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue1&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers1</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue1 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;queue2&quot;))</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumers2</span><span class="hljs-params">(String message)</span> </span>&#123;        log.info(<span class="hljs-string">&quot;队列queue2 接收的消息 is &#123;&#125;&quot;</span>, message);    &#125;&#125;</code></pre></div><p>启动成功后，访问push接口 向rabbitmq发送消息：</p><p><img src="https://i.loli.net/2021/01/18/t586oDyCvkFBlmu.png" alt="result5.png"></p><h2 id="六"><a href="#六" class="headerlink" title="六."></a>六.</h2><p>持续更新中……..</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息中间件</tag>
      
      <tag>Message Queue</tag>
      
      <tag>Rabbit MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析volatile</title>
    <link href="/2021/01/16/%E6%B5%85%E6%9E%90volatile/"/>
    <url>/2021/01/16/%E6%B5%85%E6%9E%90volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="浅析volatile"><a href="#浅析volatile" class="headerlink" title="浅析volatile"></a>浅析volatile</h2><h3 id="为什么引入volatile"><a href="#为什么引入volatile" class="headerlink" title="为什么引入volatile"></a>为什么引入volatile</h3><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>举个例子，比如说有两个线程，他们的代码里都需要读取data这个变量的值，那么他们都会从主内存里加载data变量的值到自己的工作内存，然后才可以使用那个值。好了，现在大家从图里看到，每个线程都把data这个变量的副本加载到了自己的工作内存里了，所以每个线程都可以读到data = 0这个值。</p><p>这样，在线程代码运行的过程中，对data的值都可以直接从工作内存里加载了，不需要再从主内存里加载了。</p></blockquote><p>为啥一定要让每个线程用一个工作内存来存放变量的副本以供读取呢？直接让线程每次都从主内存加载变量的值不行吗？</p><blockquote><p>因为线程运行的代码对应的是一些指令，是由CPU执行的！CPU每次执行指令运算的时候，每次需要一个变量的值，都从主内存加载，性能会比较差。</p><p>所以说后来，就是提出了线程工作内存的概念，类似于一个<strong>高速的本地缓存。</strong>这样一来，线程的代码在执行过程中，就可以直接从自己本地缓存里加载变量副本，不需要从主内存加载变量值，性能可以提升很多！</p></blockquote><p>思考：这种方法性能是提升了，但是会带来其他的问题么？</p><p><img src="https://i.loli.net/2021/01/17/frxhGLzC8VTpwmg.png" alt="内存模型"></p><blockquote><p>如上图：有两个线程，两个线程都需要data变量，都将变量的副本加载到了自己的工作内存。假如这时线程1需要修改data变量的值为1，修改完之后将这个修改写入自己的本地工作内存。如下图</p></blockquote><p><img src="https://i.loli.net/2021/01/17/wseOE28YBFnpZH6.png" alt="volatile1.png"></p><blockquote><p>那么此时，线程1的工作内存里的data值为1，但是，主内存以及线程2里的data值还是为0。那么接下来，在线程1的代码运行过程中，他可以直接读到data最新的值是1，但是线程2的代码运行过程中读到的data的值还是0。这就不符合逻辑了。</p></blockquote><p>上述问题就是：<strong>java并发编程中的可见性问题:</strong></p><p><strong>多个线程并发读写一个共享变量的时候，某个线程修改了共享变量的值，其他线程看不到，即对其他线程不可见。</strong></p><h3 id="引入volatile"><a href="#引入volatile" class="headerlink" title="引入volatile"></a>引入volatile</h3><blockquote><p>那如果要解决这个问题怎么办呢？这时就轮到<strong>volatile</strong>闪亮登场了！你只要给data这个变量在定义的时候加一个volatile，就直接可以完美的解决这个可见性的问题。</p></blockquote><p>比如下面的这样的代码，在加了volatile之后，会有啥作用呢？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 启用两个线程，一个线程会读取和修改data的值，一个线程会读取data的值</span></code></pre></div><ul><li><p>第一，一旦data变量定义的时候前面加了volatile来修饰的话，那么线程1只要修改data变量的值，就会在修改完自己本地工作内存的data变量值之后，强制将这个data变量最新的值刷回主内存，必须让主内存里的data变量值立马变成最新的值！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/R3dQ5fkvtGhZHCu.png" alt="volatile2.png"></p></li><li><p>第二，如果此时别的线程的工作内存中有这个data变量的本地缓存，也就是一个变量副本的话，那么会强制让其他线程的工作内存中的data变量缓存直接失效过期，不允许再次读取和使用了！</p><p><strong>整个过程，如下图所示：</strong></p><p><img src="https://i.loli.net/2021/01/17/Zh2f3Kmq8dxE1u6.png" alt="volatile3.png"></p></li></ul><ul><li><p>第三，如果线程2在代码运行过程中再次需要读取data变量的值，此时尝试从本地工作内存中读取，就会发现这个data = 0已经过期了！此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了！</p><p><strong>整个过程，参见下图：</strong></p><p><img src="https://i.loli.net/2021/01/17/CyEIxFn1TQOWa39.png" alt="volatile4.png"></p></li><li><p>至此，volatile完美解决了java并发中可见性的问题！对一个变量加了volatile关键字修饰之后，只要一个线程修改了这个变量的值，立马强制刷回主内存。接着强制过期其他线程的本地工作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！这样就保证，任何一个线程修改了变量值，其他线程立马就可以看见了。这就是所谓的volatile保证了可见性的工作原理。</p></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>注意：volatile主要作用是保证可见性以及有序性。volatile是不能保证原子性的！，原子性问题，得依赖synchronized、ReentrantLock等加锁机制来解决。</strong></p><blockquote><p>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</p><p>如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程------创建多线程的三种方式</title>
    <link href="/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程——创建多线程的三种方式"><a href="#多线程——创建多线程的三种方式" class="headerlink" title="多线程——创建多线程的三种方式"></a>多线程——创建多线程的三种方式</h2><h3 id="创建一个继承于java-lang-Thread的类"><a href="#创建一个继承于java-lang-Thread的类" class="headerlink" title="创建一个继承于java.lang.Thread的类"></a>创建一个继承于java.lang.Thread的类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>  + Thread.currentThread().getId());&#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 创建自定义线程</span>MyThread1 myThread1 = <span class="hljs-keyword">new</span> MyThread1();<span class="hljs-comment">// 开启线程</span>myThread1.start();&#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">123456789101112131415161718</span></code></pre></div><h3 id="实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装"><a href="#实现java-lang-Runnable接口，重写run-方法，然后使用Thread类来包装" class="headerlink" title="实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装"></a>实现java.lang.Runnable接口，重写run()方法，然后使用Thread类来包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;   <span class="hljs-comment">// 在run方法中实现此线程需要实现的功能</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   System.out.println(<span class="hljs-string">&quot;线程名字：&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;\t线程ID：&quot;</span>     + Thread.currentThread().getId());   &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <span class="hljs-comment">// 创建MyRunnable</span>   MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();   <span class="hljs-comment">// 用Thread 包装一下myRunnable</span>   Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);   <span class="hljs-comment">// 开启线程</span>   thread.start();   &#125;&#125;<span class="hljs-comment">// 输出 ：线程名字：Thread-0线程ID：10</span><span class="hljs-number">1234567891011121314151617181920</span></code></pre></div><blockquote><ol><li>这两种方式实现多线程的方式都是围绕着Thread类展开的，第一种方式实现线程是继承于java.lang.Thread类，然后实现run方法，最终调用Thread类中的start方法启动线程。而实现Runnable接口，则是把run写到了接口中，并由实现类实现run方法，然后再用Thread类对Runnable接口进行包装，然后在调用Thread中start方法启动线程。①②两种方式都是最终都是调用Thread中start方法进行启动线程。</li><li>两种方式在本质上没有明显的区别，但是在外观上有很大的区别，第一种方式是继承Thread类，由于Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就建议使用第二种方式。</li></ol></blockquote><h3 id="实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装"><a href="#实现-java-util-concurrent-Callable，用java-util-concurrent-FutureTask类对其包装，然后再用java-lang-Thread类对java-util-concurrent-FutureTask的实现类进行包装" class="headerlink" title="实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装"></a>实现 java.util.concurrent.Callable，用java.util.concurrent.FutureTask类对其包装，然后再用java.lang.Thread类对java.util.concurrent.FutureTask的实现类进行包装</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tstarting...&quot;</span>);       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;           sum += i;       &#125;       Thread.sleep(<span class="hljs-number">5000</span>);       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot; \tover...&quot;</span>);       <span class="hljs-keyword">return</span> sum;   &#125;&#125;<span class="hljs-comment">// 测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;   MyCallable myCallable = <span class="hljs-keyword">new</span> MyCallable();   <span class="hljs-comment">// 将Callable包装成FutureTask，FutureTask也是一种Runnable</span>   FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myCallable);   Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);   thread.start();   <span class="hljs-comment">// get方法会阻塞调用的线程</span>   Integer res = futureTask.get();   System.out.println(<span class="hljs-string">&quot;线程执行结果：&quot;</span>+res);   &#125;&#125;<span class="hljs-comment">//Thread-010Wed Apr 15 15:32:38 CST 2020 starting...</span><span class="hljs-comment">//Thread-010Wed Apr 15 15:32:43 CST 2020 over...</span><span class="hljs-comment">//线程执行结果：5050</span><span class="hljs-number">123456789101112131415161718192021222324252627282930</span></code></pre></div><h4 id="三种方式比较："><a href="#三种方式比较：" class="headerlink" title="三种方式比较："></a>三种方式比较：</h4><ul><li>Thread: 继承方式, 不建议使用, 因为Java是单继承的，继承了Thread就没办法继承其它类了，不够灵活</li><li>Runnable: 实现接口，比Thread类更加灵活，没有单继承的限制</li><li>Callable: Thread和Runnable都是重写的run()方法并且没有返回值，Callable是重写的call()方法并且有返回值并可以借助FutureTask类来判断线程是否已经执行完毕或者取消线程执行</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>当线程不需要返回值时使用Runnable，需要返回值时就使用Callable，一般情况下不直接把线程体代码放到Thread类中，一般通过Thread类来启动线程</li><li>Thread类是实现Runnable，</li><li>Callable封装成FutureTask，FutureTask实现RunnableFuture，RunnableFuture继承Runnable，所以Callable也算是一种Runnable，</li><li>所以三种实现方式本质上都是对Runnable实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列【解耦、异步、削峰】</title>
    <link href="/2021/01/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/"/>
    <url>/2021/01/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%90%E8%A7%A3%E8%80%A6%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列作用【解耦、异步、削峰】"><a href="#消息队列作用【解耦、异步、削峰】" class="headerlink" title="消息队列作用【解耦、异步、削峰】"></a>消息队列作用【解耦、异步、削峰】</h1><blockquote><p>学习消息队列的笔记</p></blockquote><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://i.loli.net/2021/01/19/CfQSvH6btWscTle.png" alt="mq.png"></p><ul><li>MQ 全称为 <code>Message Queue</code>, 消息队列（MQ）<code>是一种应用程序对应用程序的通信方法</code>。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</li><li>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</li><li>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合</strong>，<strong>异步消息</strong>，<strong>流量削锋</strong>等问题</li></ul><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现有一个系统 A 要与其他系统（BCD）打交道（即调用其中的方法，推送的元数据一样）如下图</p><h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://i.loli.net/2021/01/19/6ubPkKTeQCAlYn2.png" alt="mq_1.png"></p><p>系统运行了一段时间后，D系统不需要A系统推送数据了，同时又新增加了一个E系统需要A系统推送数据，如下图</p><p><img src="https://i.loli.net/2021/01/19/4GzdOlYFSrvRHZx.png" alt="mq_2.png"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果其它系统改变或者新增系统，那么 A 系统都会改变，这样的话耦合度比较高，比较麻烦,在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？。</p><h3 id="消息队列解耦"><a href="#消息队列解耦" class="headerlink" title="消息队列解耦"></a>消息队列解耦</h3><p>使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://i.loli.net/2021/01/19/WhMGblrtjYzKdRU.png" alt="mq_3.png"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><blockquote><p>用户注册后，需要发注册邮件和注册短信</p></blockquote><h3 id="传统模式-1"><a href="#传统模式-1" class="headerlink" title="传统模式"></a>传统模式</h3><h4 id="架构图-1"><a href="#架构图-1" class="headerlink" title="架构图"></a>架构图</h4><h5 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h5><p><img src="https://i.loli.net/2021/01/19/fQGWLHUCo4Zl9i2.png" alt="mq_5.png"></p><p><strong>响应时间150ms</strong></p><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p><img src="https://i.loli.net/2021/01/19/UmYfDwJpGaZTSie.png" alt="mq_4.png"></p><p><strong>响应时间100ms</strong></p><h3 id="消息队列优化"><a href="#消息队列优化" class="headerlink" title="消息队列优化"></a>消息队列优化</h3><p><img src="https://i.loli.net/2021/01/19/lU2Q9BxNcCDFt6a.png" alt="mq_6.png"></p><p><strong>响应时间55ms</strong></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式【Java】</title>
    <link href="/2021/01/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90Java%E3%80%91/"/>
    <url>/2021/01/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90Java%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><blockquote><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式</strong>，可以直接访问，<strong>不需要实例化该类的对象</strong>。</p></blockquote><p><strong>注意：</strong></p><ul><li><p>单例类只能有一个实例。</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p></li></ul><p>为什么使用单例设计模式</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点对象</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h2 id="单例设计模式8-种方法"><a href="#单例设计模式8-种方法" class="headerlink" title="单例设计模式8 种方法"></a>单例设计模式8 种方法</h2><ol><li><strong>饿汉式（静态常量）</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全，同步方法）</li><li>懒汉式（线程安全，同步代码块）</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ol><h3 id="单例设计模式具体实现"><a href="#单例设计模式具体实现" class="headerlink" title="单例设计模式具体实现"></a>单例设计模式具体实现</h3><h4 id="1-）饿汉式（静态常量）实例"><a href="#1-）饿汉式（静态常量）实例" class="headerlink" title="1 ）饿汉式（静态常量）实例"></a>1 ）饿汉式（静态常量）实例</h4><p> <strong>代码实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">// 公开一个方法，获得唯一实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true </span><span class="hljs-comment">    singleton.hashCode: 366712642 </span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：这种方式写法简单，在类装载的时候就完成实例化，避免了线程同步问题</li><li>缺点：在类装载的时候就完成实例化，没有达到<strong>Lazy Loading 懒加载</strong> 的效果，如果从始至终未使用过这个类，则会造成内存的浪费。（<strong>懒加载的意思就是什么时候用什么时候才加载</strong>）</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="2-）饿汉式（静态代码块）实例"><a href="#2-）饿汉式（静态代码块）实例" class="headerlink" title="2 ）饿汉式（静态代码块）实例"></a><strong>2 ）饿汉式（静态代码块）实例</strong></h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（静态变量）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance;<span class="hljs-comment">//  在静态代码块中 进行初始化</span><span class="hljs-keyword">static</span>&#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果 </span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优缺点与上面一样</li><li>结论：懒汉式单例设计模式可以用，但是会造成内存的浪费</li></ol><h4 id="3-）懒汉式（线程不安全）实例"><a href="#3-）懒汉式（线程不安全）实例" class="headerlink" title="3 ）懒汉式（线程不安全）实例"></a>3 ）懒汉式（线程不安全）实例</h4><p><strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest02</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式1 线程不安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程不安全）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式1 线程不安全</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优点：实现了<strong>Lazy Loading 懒加载</strong> 的效果</p></li><li><p>缺点：只能在单线程下使用，如果进入了多线程，<code>if(singletonInstance == null) </code>语句还未来得及向下执行，另一个线程也通过了这个判断语句，<strong>会导致产生多个实例，因此在严格意义上它并属于单例设计模式</strong>。在多线程下不能使用这种方式</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式。</p></li></ol><h4 id="4-）懒汉式（线程安全-同步方法）实例"><a href="#4-）懒汉式（线程安全-同步方法）实例" class="headerlink" title="4 ）懒汉式（线程安全 同步方法）实例"></a>4 ）懒汉式（线程安全 同步方法）实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest01</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式2  线程安全 同步方法&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步方法）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量 并进行初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<span class="hljs-comment">//利用synchronized修饰getInstance方法，使之变为同步方法 懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式2  线程安全 同步方法</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：解决了线程安全的问题</li><li>缺点：<strong>效率太低</strong>，每个线程想要执行getInstance()方法时，<strong>都要进行同步</strong>，实际上这个方法<strong>只执行一次实例化</strong>就够了，之后就直接return 实例就好了，<strong>方法进行同步效率太低</strong></li><li>结论：在实际开发中<strong>不推荐</strong>这种方式。</li></ol><h4 id="5-）懒汉式（线程不安全-同步代码块）实例"><a href="#5-）懒汉式（线程不安全-同步代码块）实例" class="headerlink" title="5 ）懒汉式（线程不安全 同步代码块）实例"></a>5 ）懒汉式（线程不安全 同步代码块）实例</h4><p>有的人也许会认为把上面同步方法换成同步代码块就可以了：如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;懒汉式3 线程不安全 同步代码块&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">//懒汉式（线程安全 同步代码块）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">// 创建一个私有的静态变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 即懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 在这里设置静态代码块  并不能解决同步问题 所以这种方法不可以</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">懒汉式3 线程不安全 同步代码块</span><span class="hljs-comment">    true</span><span class="hljs-comment">    singleton.hashCode: 366712642</span><span class="hljs-comment">    singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>优缺点与 3） 一样</p></li><li><p>结论：在实际开发中<strong>不要使用</strong>这种方式</p></li></ol><h4 id="6）双重检查-实例"><a href="#6）双重检查-实例" class="headerlink" title="6）双重检查 实例"></a>6）双重检查 实例</h4><p>  <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;双重检查  线程安全&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125; <span class="hljs-comment">// 双重检查</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> 1.volatile</span><span class="hljs-comment"> volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的         优化而省略。</span><span class="hljs-comment">2.volatile 的特性</span><span class="hljs-comment">保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程 来说是立即可见的,(即实时刷新)。（实现可见性） 禁止进行指令重排序。（实现有序性）</span><span class="hljs-comment">volatile 只能保证对单次读 / 写的原子性。i++ 这种操作不能保证原子性。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 创建一个私有的静态变量 并用volatile修饰</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singletonInstance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法，用到该方法时才实例化对象 加入双重检查的代码 解决线程安全 以及懒加载</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 第一次判断  如果实例化直接返回 否则进行实例化</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 设置静态代码块  保证每次只能进入一个线程</span><span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">// 第二次判断 保证只能实例化一次</span><span class="hljs-keyword">if</span>(singletonInstance == <span class="hljs-keyword">null</span>) &#123;singletonInstance = <span class="hljs-keyword">new</span> Singleton();&#125;&#125;&#125;<span class="hljs-keyword">return</span> singletonInstance;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果：</span><span class="hljs-comment">双重检查  线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>优点：双重检查（double-check） 概念时多线程开发中经常用到的，在代码中我们进行了两次<code>if(singletonInstance == null)</code>判断，解决了线程安全问题</li><li>第一个线程调用完getInstance方法后，其他的线程在第一层判断时，就会直接返回实例，避免反复进入同步代码块，解决了效率问题</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="7）静态内部类-实例"><a href="#7）静态内部类-实例" class="headerlink" title="7）静态内部类 实例"></a>7）静态内部类 实例</h4><p> <strong>代码实现</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;静态内部类  线程安全 懒加载&quot;</span>);Singleton singleton = Singleton.getInstance();Singleton singleton1 = Singleton.getInstance();System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-comment">// 原因：</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    在Singleton进行装载的时候 其静态内部类不进行装载，等到getInstance方法返回静态内部类中</span><span class="hljs-comment">    常量时静态内部类才进行装载，其常量才进行实例化，且装载过程为线程安全，并实现了懒加载。</span><span class="hljs-comment">    */</span><span class="hljs-comment">//创建静态内部类，利用其特性 实现线程安全，以及懒加载</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonInstance</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-comment">// 构造器私有化 外部不能new</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;  &#125;<span class="hljs-comment">// 提供一个公共的静态方法 获得实例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">静态内部类  线程安全 懒加载</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li>在Singleton进行装载的时候 其<strong>静态内部类SingletonInstance并不进行装载</strong>，等到需要实例化时调用getInstance方法时，<strong>静态内部类SingletonInstance才进行装载</strong>，完成<strong>Singleton类的实例化</strong>，类的静态属性，只有在第一次装载类的时候进行初始化，JVM帮我们实现了<strong>线程的安全性</strong>，并实现了懒加载。</li><li>优点： 避免了线程的不安全，利用静态类实现延迟加载，效率高。</li><li>结论：在实际开发中<strong>推荐使用</strong>这种方式。</li></ol><h4 id="8-）枚举-实例"><a href="#8-）枚举-实例" class="headerlink" title="8 ）枚举 实例"></a>8 ）枚举 实例</h4><p><strong>代码展示：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> single;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;JDK1.5 枚举 线程安全&quot;</span>);Singleton singleton = Singleton.INSTANCE;Singleton singleton1 = Singleton.INSTANCE;System.out.println(singleton == singleton1);System.out.println(<span class="hljs-string">&quot;singleton.hashCode: &quot;</span> + singleton.hashCode());System.out.println(<span class="hljs-string">&quot;singleto1.hashCode: &quot;</span> + singleton1.hashCode());&#125;&#125;<span class="hljs-comment">// 静态内部类，实现单例</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;INSTANCE;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">JDK1.5 枚举 线程安全</span><span class="hljs-comment">true</span><span class="hljs-comment">singleton.hashCode: 366712642</span><span class="hljs-comment">singleto1.hashCode: 366712642</span><span class="hljs-comment">*/</span></code></pre></div><p><strong>优缺点与总结</strong>：</p><ol><li><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p></li><li><p>结论：推荐使用</p></li></ol><h2 id="破坏单例模式的方法及解决办法"><a href="#破坏单例模式的方法及解决办法" class="headerlink" title="破坏单例模式的方法及解决办法"></a>破坏单例模式的方法及解决办法</h2><p>1、除枚举方式外，其他方法都会通过反射的方式破坏单例，反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例，则阻止生成新的实例，解决办法如下:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonObject1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span> (instance !=<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);    &#125;&#125;</code></pre></div><p>2、如果单例类实现了序列化接口 Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口，如果非得实现序列化接口，可以重写反序列化方法 readResolve (), 反序列化时直接返回相关单例对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-1</title>
    <link href="/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></blockquote><h3 id="分类及关系"><a href="#分类及关系" class="headerlink" title="分类及关系"></a>分类及关系</h3><h4 id="设计模式三大类"><a href="#设计模式三大类" class="headerlink" title="设计模式三大类"></a>设计模式三大类</h4><ul><li><p><strong>创建型模式【共五种】</strong> </p><p>工厂方法模式；抽象工厂模式；单例模式；建造者模式；原型模式。</p></li><li><p><strong>结构型模式【共七种】</strong></p><p>适配器模式；装饰器模式；代理模式；外观模式；桥接模式；组合模式；享元模式。</p></li><li><p><strong>行为型模式【共十一种】</strong></p><p>策略模式；模板方法模式；观察者模式；迭代子模式；责任链模式；命令模式；备忘录模式；状态模式；访问者模式；中介者模式；解释器模式</p></li></ul><h4 id="设计模式关系"><a href="#设计模式关系" class="headerlink" title="设计模式关系"></a>设计模式关系</h4><p><img src="https://i.loli.net/2021/01/11/ZKbFWYMqUmBS8uk.jpg" alt="designPattern.jpg"></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>里氏代换原则 (Liskov Substitution Principle LSP) 面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对 “开 - 闭” 原则的补充。实现 “开 - 闭” 原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>原则是尽量使用合成 / 聚合的方式，而不是使用继承。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>开闭原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/01/09/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/01/09/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KMP 算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回 - 1（常用手段）。</p><p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p><h3 id="kMP解决的问题"><a href="#kMP解决的问题" class="headerlink" title="kMP解决的问题"></a>kMP解决的问题</h3><p>现在有一个字符串为源字符串S,现在给你个目标字符串T，问T是否在S中存在。(下图中：上面的为S，下面的为T)</p><p><img src="https://i.loli.net/2021/01/09/qkFvCIet4xJjQgn.png" alt="kmp1.png"></p><h3 id="暴力解决法"><a href="#暴力解决法" class="headerlink" title="暴力解决法"></a>暴力解决法</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><strong>遍历两个字符串</strong></p><ul><li>首先，定义两个指针i，j初始化为0</li></ul><p><img src="https://i.loli.net/2021/01/09/yB9nEYl2mROLqPS.png" alt="kmp2.png"></p><ul><li>如果i 指向的字符和 j 指向的字符一致，i和j向后移动。</li></ul><p><img src="https://i.loli.net/2021/01/09/cREG9gWDKoX3HPn.png" alt="kmp3.png"></p><ul><li>不相等，那就把 i 指针移回第 1 位（假设下标从 0 开始），j 移动到模式串的第 0 位：</li></ul><p><img src="https://i.loli.net/2021/01/09/MK4zQx1tJOmVX5h.png" alt="kmp4.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matching</span><span class="hljs-params">(String src, String pattern)</span> </span>&#123;    <span class="hljs-keyword">int</span> len1 = src.length();    <span class="hljs-keyword">int</span> len2 = pattern.length();    <span class="hljs-comment">// 主串的长度小于模式串的长度时直接返回-1，说明不存在</span>    <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 主串中剩下未匹配的字符的大小&gt;=模式串的长度才继续进行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; len1 - i &gt;= len2; i++) &#123;        <span class="hljs-keyword">int</span> temp = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pattern.length(); j++) &#123;            <span class="hljs-comment">// 对照第2步</span>            <span class="hljs-keyword">if</span> (src.charAt(temp++) == pattern.charAt(j)) &#123;                <span class="hljs-comment">// pattern 数组遍历到结尾说明找到匹配的</span>                <span class="hljs-keyword">if</span> (j == pattern.length() - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">// i - len2 是模式串在源串中的起始位置</span>                    <span class="hljs-keyword">return</span> i;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 不等就跳出循环 对标第三步</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="https://i.loli.net/2021/01/10/p3cQJqNFy4AEWHZ.gif" alt="kmp5.gif"></p><blockquote><p>如上图，在暴力求解时，每当发现字符不匹配时，主串i需要回溯，模式串的j也要回溯，这极大的影响了搜索效率。</p></blockquote><h3 id="KMP求解法"><a href="#KMP求解法" class="headerlink" title="KMP求解法"></a>KMP求解法</h3><h4 id="KMP是如何消除指针回溯问题的"><a href="#KMP是如何消除指针回溯问题的" class="headerlink" title="KMP是如何消除指针回溯问题的"></a>KMP是如何消除指针回溯问题的</h4><p>未完待续。。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/2JhlgDr1yqjCcaA.gif" alt="selectionSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = src.length;    <span class="hljs-comment">// 比较 len - 1 词</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// 记录当前下标，作为之后比较使用</span>        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-comment">// 找出最小的元素,需要比较 len - 1</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &lt; src[min]) &#123;                min = j;            &#125;        &#125;        <span class="hljs-comment">// 如果最小元素下标发生改变，则交换</span>        <span class="hljs-keyword">if</span> (min != i) &#123;            <span class="hljs-keyword">int</span> temp = src[i];            src[i] = src[min];            src[min] = temp;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。在剩下的n-1个元素中重复此操作，持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。至此排序完成</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://uploader.shimo.im/f/DhBMiGl0vTmIAGGk.gif" alt="bubble"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] src)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = src.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            <span class="hljs-keyword">if</span> (src[j] &gt;= src[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> temp = src[j];                src[j] = src[j+<span class="hljs-number">1</span>];                src[j+<span class="hljs-number">1</span>] = temp;                flag = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>从数列中挑出一个元素，称为 “基准”（pivot）;<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/ipdOu3qA8lxTf2M.gif" alt="quickSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    quickProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        swap(arr, left + ((<span class="hljs-keyword">int</span>) Math.random() * (right - left + <span class="hljs-number">1</span>)), right);        <span class="hljs-keyword">int</span>[] p = partation(arr, left, right);        quickProcess(arr, left, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);        quickProcess(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, right);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partation(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">int</span> less = left - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> more = right;    <span class="hljs-keyword">int</span> base = arr[right];    <span class="hljs-keyword">while</span> (left &lt; more) &#123;        <span class="hljs-keyword">if</span> (arr[left] &lt; base) &#123;            swap(arr, ++less, left++);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] &gt; base) &#123;            swap(arr, --more, left);        &#125; <span class="hljs-keyword">else</span> &#123;            left++;        &#125;    &#125;    swap(arr, more, right);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = arr[index1];    arr[index1] = arr[index2];    arr[index2] = temp;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码解析-JDK1-8"><a href="#HashMap源码解析-JDK1-8" class="headerlink" title="HashMap源码解析(JDK1.8)"></a>HashMap源码解析(JDK1.8)</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在进行HashMap分析前，我期望解决以下问题：</p><ul><li>HashMap的底层数据结构是什么？</li><li>HashMap中增删改查操作的底部实现原理是什么？</li><li>HashMap是如何实现扩容的？</li><li>HashMap是如何解决hash冲突的？</li><li>HashMap为什么是非线程安全的？</li></ul><h3 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h3><p>HashMap 基于哈希表的 Map 接口的实现，key唯一的value可以重复，允许存储键为null(key = null),值为null(value = null)，元素没有顺序,同时不保证该顺序恒久不变。</p><p>在 JDK 1.8 之前是由“数组+链表”组成。JDK1.8的HashMap对之前做了较大的优化，其中最重要的一个优化就是将底层的数据结构由“数组+链表”变为了“数组+链表+红黑树”，值得一提的是只有当链表的长度大于8时.。除此之外HashMap是非线程安全的，因此在多个线程同时对HashMap中的同一个元素进行修改时，不能保证数据的唯一性。</p><h3 id="剖析结构"><a href="#剖析结构" class="headerlink" title="剖析结构"></a>剖析结构</h3><h4 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h4><p><img src="https://i.loli.net/2021/01/07/femFXPH2T8N5ZMv.png" alt="DataStruct1.7.png"></p><p>从上图我们可以看到，在jdk1.7中，首先是HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，因为Entry具有Next引用，每一个Entry实体类实际上是一个单向的链表的头部，可以用来连接下一个Entry实体，又因为HashMap是按照Key的hash值来计算Entry在HashMap中存储的位置的，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。就这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高<strong>（链表不适合查找，适合增删）</strong>，反倒是下降了不少。</p><p>于是官方在JDK1.8的时候就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。</p><p><img src="https://i.loli.net/2021/01/07/1Qv4fyFu8rlpzXE.png" alt="DataStruct1.8.png"></p><p><strong>注意：</strong> <strong>要注意的是只有在链表的长度不小于8，且数组的长度不小于64的时候才会将链表转化为红黑树，</strong></p><h4 id="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"><a href="#这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。" class="headerlink" title="这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。"></a><strong>这里我们需要考虑为什么要把链表转为红黑树，而不是其他的数据结构。</strong></h4><p><strong>因为：红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找一个元素的时间复杂度会从链表的o(n)降低为o(logn)。</strong></p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>源码</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4、重复步骤 3 直到某一指针达到序列尾；<br>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://i.loli.net/2021/01/08/WbeJEpiD9usgR31.gif" alt="mergeSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 排序入口函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    sortProcess(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">// 分治</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (right == left) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 归并左边</span>    sortProcess(arr, left, mid);    <span class="hljs-comment">// 归并右边</span>    sortProcess(arr, mid + <span class="hljs-number">1</span>, right);    merge(arr, left, mid, right);&#125;<span class="hljs-comment">// 合并</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// 辅助数组</span>    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 辅助数组 开始下标</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p1 = left;    <span class="hljs-keyword">int</span> p2 = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 合并两个数组</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    <span class="hljs-comment">// 两个指针必有一个未过界 需要处理</span>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) &#123;        help[i++] = arr[p1++];    &#125;    <span class="hljs-keyword">while</span> (p2 &lt;= right) &#123;        help[i++] = arr[p2++];    &#125;    <span class="hljs-comment">// 拷贝给原数组</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;        arr[left + i] = help[i];    &#125;&#125;</code></pre></div><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度:O(nlogn)</li><li>空间复杂度:O(N) 需要一个与排序数组长度相同的数组，进行辅助排序</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>归并排序是一个稳定的排序，只需在合并方法中，合并两个数组时用这行代码<code> help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]</code>,可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架【IOC四种依赖注入】</title>
    <link href="/2020/10/22/Spring%E6%A1%86%E6%9E%B6%E3%80%90IOC%E5%9B%9B%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%91/"/>
    <url>/2020/10/22/Spring%E6%A1%86%E6%9E%B6%E3%80%90IOC%E5%9B%9B%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring-IOC-四种依赖注入"><a href="#Spring-IOC-四种依赖注入" class="headerlink" title="Spring IOC 四种依赖注入"></a>Spring IOC 四种依赖注入</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>1、创建一个Maven工程</p><p>2、创建一个实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-keyword">private</span> Integer id;<span class="hljs-keyword">private</span> String userName;<span class="hljs-keyword">private</span> String password;<span class="hljs-keyword">private</span> String note;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;<span class="hljs-keyword">this</span>.userName = userName;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;<span class="hljs-keyword">this</span>.password = password;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setNote</span><span class="hljs-params">(String note)</span> </span>&#123;<span class="hljs-keyword">this</span>.note = note;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;    <span class="hljs-comment">//注意 ：toString,get方法自行实现，</span>&#125;<span class="hljs-number">123456789101112131415161718192021222324</span></code></pre></div><p>3、引入pom依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>12345</code></pre></div><p>4、在src/main/java中创建beans.xml，并写入如下内容</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><h4 id="一、静态工厂"><a href="#一、静态工厂" class="headerlink" title="一、静态工厂"></a>一、静态工厂</h4><p>1、首先创建一个静态工厂UserFactory</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> User user;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;user = <span class="hljs-keyword">new</span> User();user.setId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;王五&quot;</span>).setPassword(<span class="hljs-string">&quot;hwy499&quot;</span>).setNote(<span class="hljs-string">&quot;无&quot;</span>);&#125;<span class="hljs-keyword">return</span> user;&#125;&#125;</code></pre></div><p>2、在Beans.xml文件中配置该静态工厂</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span>       <span class="hljs-comment">&lt;!-- factory-method : 获得对象的静态方法名 class:静态工厂类的全限定类名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.factory.UserFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span>  <span class="hljs-attr">id</span> =<span class="hljs-string">&quot;userFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);        <span class="hljs-comment">// 获得实例</span>User user = cpac.getBean(<span class="hljs-string">&quot;userFactory&quot;</span>, User.class);        <span class="hljs-comment">// 打印</span>System.out.println(user);         <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="二、实例工厂注入"><a href="#二、实例工厂注入" class="headerlink" title="二、实例工厂注入"></a>二、实例工厂注入</h4><p>1、创建一个工厂类UserFactory</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<span class="hljs-keyword">private</span> User user;<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;user = <span class="hljs-keyword">new</span> User();user.setId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;王五&quot;</span>).setPassword(<span class="hljs-string">&quot;hwy499&quot;</span>).setNote(<span class="hljs-string">&quot;无&quot;</span>);&#125;<span class="hljs-keyword">return</span> user;&#125;&#125;</code></pre></div><p>2、在beans.xml中配置工厂类的实例</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.factory.UserFactory&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;userFactory&quot;</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);          <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="三、Set-方法注入"><a href="#三、Set-方法注入" class="headerlink" title="三、Set 方法注入"></a>三、Set 方法注入</h4><p>1、在beans.xml中进行如下配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--通过set方法注入 为什么这种方法叫做通过set方法注入呢？</span><span class="hljs-comment">这个跟我们在property标签中添加的name有关，在property中添加的name</span><span class="hljs-comment">并不是我们实体类中的属性名，而是我们在其中添加的set方法中set之后的名字，</span><span class="hljs-comment">假如我们现在实体类中有一个属性叫name，而它对应的set方法为setUserName,</span><span class="hljs-comment">那么我就要在property标签中添加name=&quot;username&quot;,而不是name=&quot;name&quot;</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456123&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;note&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是一个备注&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>2、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);          <span class="hljs-comment">//User [id=1, userName=王五, password=hwy499, note=无]</span>&#125;&#125;</code></pre></div><h4 id="四、通过构造方法注入"><a href="#四、通过构造方法注入" class="headerlink" title="四、通过构造方法注入"></a>四、通过构造方法注入</h4><p>1、在实体类添加构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//无参构造函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String userName, String password, String note)</span> </span>&#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">this</span>.id = id;    <span class="hljs-keyword">this</span>.userName = userName;    <span class="hljs-keyword">this</span>.password = password;    <span class="hljs-keyword">this</span>.note = note;&#125;</code></pre></div><p>2、在bens.xml中添加如下配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;note&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--或是--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--在或是 此时要注意先后问题，此时是按照你的构造函数的参数顺序依次赋值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;无备注消息&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>3、测试</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorTest</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//加载 beans.xml</span>ClassPathXmlApplicationContext cpac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<span class="hljs-comment">//User user = cpac.getBean(&quot;userFactory&quot;, User.class);</span>User user = cpac.getBean(<span class="hljs-string">&quot;user&quot;</span>,User.class);System.out.println(user);         <span class="hljs-comment">// User [id=1, userName=李四, password=123456, note=无备注消息]</span>&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>spring</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
